# 自旋锁 与 互斥锁

## 核心机制
*   **忙等待 (Busy-Waiting)**：当一个线程尝试获取一个已经被持有的自旋锁时，它会在一个**循环中不断地检查锁的状态**（“自旋”），直到锁变得可用。
*   **实现级别**：通常直接在**用户空间**通过原子操作（如CPU的`CAS` - Compare-And-Swap指令）实现，不依赖于操作系统调度器。
*   **底层依赖**：依赖CPU提供的**原子指令**来确保测试和设置锁的操作是原子的、不可中断的。

#### 特点
*   **开销**：在等待期间**消耗CPU资源**。线程始终处于运行状态（Runnable/Running）。
*   **阻塞**：线程**不会被挂起**，没有上下文切换的开销。
*   **持有时间**：**仅适用于锁被持有的时间非常短的场景**（例如，只有几条指令的时间）。

#### 适用场景
1.  **临界区代码执行时间极短**（例如，只是修改一个指针、一个标志位）。
2.  **在多核处理器系统上**（在单核CPU上使用自旋锁通常是浪费，因为持有锁的线程无法被调度运行来释放锁）。
3.  **在中断上下文或底层内核代码中**，这些场合不允许睡眠或调度（例如，中断处理函数不能调用会导致睡眠的函数）。



## 互斥锁 (Mutex)

#### 核心机制
*   **睡眠等待 (Sleep-Waiting)**：当一个线程尝试获取一个已经被持有的互斥锁时，操作系统内核会**将该线程的状态置为阻塞（Blocked）**，并将其从调度器的运行队列中移出。当锁被释放时，内核会唤醒其中一个等待的线程。
*   **实现级别**：是操作系统提供的一种**系统调用**，涉及到内核态的切换。
*   **底层依赖**：依赖操作系统的**调度器**来管理等待队列和线程的唤醒。

#### 特点
*   **开销**：在等待期间**不消耗CPU资源**。线程处于睡眠状态。
*   **阻塞**：线程会被挂起，会有**两次上下文切换的开销**（获取锁失败时挂起一次，锁可用时被唤醒一次）。
*   **功能丰富**：通常支持更复杂的机制，如**优先级继承**（解决优先级反转问题）、**递归加锁**等。

#### 适用场景
1.  **临界区代码执行时间较长**（例如，操作一个链表、进行文件I/O）。
2.  **任何需要等待相对较长时间的场景**。
3.  **用户态应用程序开发**（这是最常用的锁类型）。

---

### 对比总结表

| 特性                  | 自旋锁 (Spinlock)                   | 互斥锁 (Mutex)                           |
| :-------------------- | :---------------------------------- | :--------------------------------------- |
| **等待机制**          | **忙等待 (Busy-Waiting)**           | **睡眠等待 (Sleep-Waiting)**             |
| **实现层面**          | 通常为用户态（基于原子指令）        | 内核态（系统调用）                       |
| **开销**              | 等待时消耗CPU时间                   | 等待时不消耗CPU，但有上下文切换开销      |
| **性能影响**          | 持有锁时间长会导致CPU空转，浪费资源 | 上下文切换有固定开销，锁竞争激烈时开销大 |
| **适用场景**          | 临界区**非常短**，多核CPU           | 临界区**执行时间较长**                   |
| **OS调度**            | 线程始终处于运行状态，不会被挂起    | 线程会被挂起，等待被内核唤醒             |
| **在单核CPU上的使用** | **通常不适用**（除非禁用内核抢占）  | **适用**                                 |

### 如何选择？

选择的关键在于**评估临界区代码的执行时间**：

1.  **如果临界区执行时间非常短（例如，少于两次上下文切换的开销）**，或者你在开发内核/底层代码且不能睡眠，**优先考虑自旋锁**。因为上下文切换的开销可能比直接自旋等待更大。
2.  **如果临界区执行时间较长或不确定**，**绝对要使用互斥锁**。让出CPU给其他线程运行远比白白浪费CPU周期自旋等待要高效得多。

**简单规则**：
*   **短操作 -> 自旋锁**
*   **长操作 -> 互斥锁**

在现代编程中（如Java的`synchronized`，C++的`std::mutex`），开发者接触到的大部分都是互斥锁的封装，因为其更通用、更安全。自旋锁则更多用于系统级编程和性能极其敏感的特定场景。