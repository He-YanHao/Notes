# ARM寄存器

## 基础

ARM架构有多个版本（如ARMv7, ARMv8），其寄存器集也有所不同。

这里介绍经典的 **ARMv7-A**（32位架构，常用于Cortex-A系列应用处理器）为例进行介绍，然后再简要对比ARMv8。



## ARMv7 / ARM32 寄存器集

ARMv7 提供了 **37 个 32 位寄存器**，但这些寄存器并非同时全部可见。处理器工作在**不同的模式**下，会使用不同的**寄存器组（Banked registers）**，这是ARM寄存器设计的一个巧妙之处。

这些寄存器可分为三类：

### **通用寄存器 (R0 - R15)**

- **R0 - R12**：通用寄存器，  绝大部分指令都可以使用它们。**没有**架构定义的特殊用途，但遵循重要的约定俗成。
  - **R0-R3**: 通常用于**传递参数**给函数。
  - **R0**: 通常用于**存放函数的返回值**。
  - **R4-R8**: 用于存放局部变量。被调函数必须保存并恢复这些值（**Callee-saved**）。
  -  **R9-R11**: 具体用途可能因平台而异。
- **R13**(**SP**)：栈指针，每个异常模式都有自己的banked SP寄存器（如`SP_svc`, `SP_irq`），指向当前模式的栈顶。

- **R14**(**LR**)：链接寄存器，当执行`BL`（带链接的分支）指令调用函数时，**PC的下一跳地址（返回地址）会自动存入LR**。函数结束时，通过`BX LR`或`MOV PC, LR`返回。
- **R15**(**PC**)：程序计数器，指向**当前正在取指的指令地址**（在ARM状态下，PC = 当前指令地址 + 8）。



### **程序状态寄存器 (CPSR & SPSR)**

- **当前程序状态寄存器CPSR**：这是一个非常关键的寄存器，包含了：
  - **条件标志位 (N, Z, C, V)**：保存上一条ALU操作的结果，用于条件执行。
  - **中断禁止位 (I, F)**：用于使能/禁用IRQ和FIQ中断。
  - **执行状态位 (T)**：指示处理器处于**ARM状态**(T=0)还是**Thumb状态**(T=1)。
  - **模式位**：指示处理器当前的工作模式（如User, IRQ, SVC等）。
- **保存的程序状态寄存器SPSR**：当发生**异常**（如中断、SWI）时，**当前模式的CPSR会自动保存到新异常模式的SPSR中**。当异常返回时，可以用SPSR来恢复CPSR。**User和System模式没有SPSR**。



### **处理器模式与Banked寄存器**

这是ARM设计的精髓。为了快速处理异常，某些模式拥有**自己独有的**（banked）寄存器副本，从而在进入异常时**无需手动保存通用寄存器**，极大地减少了开销。

- **User**：用户模式，运行普通应用程序。
  - 无
- **FIQ**：**快速中断**模式
  - **R8_fiq - R12_fiq**, **SP_fiq**, **LR_fiq**, **SPSR_fiq**
- **IRQ**：普通中断模式
  - **SP_irq**, **LR_irq**, **SPSR_irq**
- **Supervisor (SVC)**：监管模式，操作系统内核
  - **SP_svc**, **LR_svc**, **SPSR_svc**
- **Abort**：数据/指令预取终止模式
  - **SP_abt**, **LR_abt**, **SPSR_abt**
- **Undefined**：未定义指令异常模式
  - **SP_und**, **LR_und**, **SPSR_und**
- **System**：系统模式，特权级的用户模式
  - 无（使用User模式的寄存器）

**关键点**：

*   **FIQ模式为什么“快”**？因为它有**5个**独有的寄存器（R8-R12）。进入FIQ异常时，**根本不需要保存R8-R12**，可以直接使用它们，节省了压栈/出栈的时间。
*   发生IRQ/FIQ中断时，返回地址会自动保存到`LR_<exception_mode>`中。
*   发生任何异常后，处理器会自动切换到对应的异常模式。



## ARMv8 / AArch64 寄存器简介

ARMv8引入了64位架构（AArch64），寄存器集有了显著变化：

1.  **数量增加**：通用寄存器从**16个（R0-R15）增加到32个（X0-X30）**，并且全部是64位（也可用作32位，如`W0`是`X0`的低32位）。
2.  **寄存器命名**：
    *   **X0 - X30**： 64位通用寄存器。
    *   **XZR**： 64位零寄存器，读它总是返回0，写它无效。
    *   **SP**： 64位栈指针寄存器，不再是通用寄存器之一。
    *   **PC**： 程序计数器。**在AArch64中，它不再是通用寄存器，无法被大多数指令直接访问**。
3.  **功能寄存器**：
    *   **LR**： 链接寄存器，现在是**X30**。
    *   参数传递：函数调用时，前8个参数使用**X0-X7**传递。
    *   返回值：使用**X0**传递。
4.  **程序状态寄存器**：
    *   **PSTATE**： 替代了CPSR，但它不是单一寄存器，而是通过特殊寄存器（如`NZCV`）访问的一组状态字段。



## 总结与关键点

1.  **Banked寄存器是核心优势**：ARM通过为不同模式提供私有寄存器，实现了**极低延迟的异常处理**，尤其FIQ模式的设计非常巧妙。
2.  **R13, R14, R15的特殊角色**：必须牢记`SP`, `LR`, `PC`的专用功能。
3.  **CPSR是控制中心**：它控制着处理器的状态（ARM/Thumb）、中断开关、条件标志和运行模式。
4.  **AArch64的现代化改进**：寄存器数量大幅增加，简化了编程模型（如参数传递），并明确了专用寄存器的角色（如PC不可随意访问）。



## ARM寄存器为何够用？

这是一个极其出色和深刻的问题！答案是：**对于单个时刻的单一任务来说，这些寄存器是精心设计的，完全够用。但对于复杂的现代计算任务来说，当然不够。**

这引出了计算机体系结构中一个最核心的设计哲学：**如何在有限的、昂贵的高速存储（寄存器）和巨大的、廉价的低速存储（内存）之间取得平衡。**

下面我为你详细解释为什么“既够用，又不够用”，以及系统是如何解决这个矛盾的。

---

### 1. 为什么说“够用”？—— 寄存器的设计哲学

寄存器是CPU**直接操作**数据的地方，它们的速度极快，但成本极高（占用大量芯片面积）。因此，其数量是CPU设计中的一个重要权衡。

ARM的16个通用寄存器（R0-R12, SP, LR, PC）对于**处理一个简单的、连续的指令流**是高度优化的：

*   **专注于当前任务**：CPU正在执行的几条指令通常只需要操作很少的几个数据。例如，计算 `a = b + c * d`，编译器可以安排：
    1.  将 `c` 和 `d` 分别加载到 R1 和 R2。
    2.  用一条乘法指令 `MUL R0, R1, R2`（结果 `c*d` 存入 R0）。
    3.  将 `b` 加载到 R3。
    4.  用一条加法指令 `ADD R0, R0, R3`（结果 `c*d + b` 存入 R0）。
    5.  将 R0 的值存回内存中 `a` 的位置。
    在这个过程中，只用了 R0-R3 四个寄存器，远远不到16个。

*   **专用寄存器效率极高**：`SP`、`LR`、`PC` 的专用化使得函数调用、栈操作和指令获取这些最基础、最频繁的操作变得非常高效，无需占用通用寄存器。

所以，对于CPU的**执行单元**来说，在任何一个**时钟周期**内，需要直接使用的数据就那么几个，十几个寄存器足以满足“工作台”的需求。

---

### 2. 为什么说“不够用”？—— 现实的复杂性

当任务变复杂时，寄存器数量立刻显得捉襟见肘：

1.  **函数调用嵌套**：
    *   函数A调用了函数B，函数B又调用了函数C。
    *   函数A正在使用 R4-R10 存放一些重要的局部变量。
    *   当执行到函数C时，它也需要使用寄存器来进行自己的计算。如果它直接覆盖了 R4-R10，那么当返回到函数A时，函数A的数据就丢失了，程序会完全错误。

2.  **中断处理**：
    *   一个程序正在愉快地用自己的寄存器做计算。
    *   突然一个硬件中断（如网络数据包到达）发生，CPU必须立刻跳转到中断处理程序（ISR）去执行。
    *   ISR也需要使用寄存器。如果它覆盖了被中断程序的寄存器，那么中断返回后，原程序就无法继续正确执行了。

3.  **大量的变量和数据**：
    *   一个复杂的程序可能有上百个变量和复杂的数据结构。显然，不可能把所有数据都塞进这十来个寄存器里。

---

### 3. 解决方案：寄存器与内存的协同 —— “寄存器溢出”

既然寄存器不够用，那么就用速度较慢但容量巨大的**内存（RAM）** 来作为“后备仓库”。这个过程是自动的，由编译器和操作系统共同管理。核心机制就是 **“栈”**。

#### 关键概念：调用约定 (Calling Convention)

这是一种编译器、汇编器和操作系统之间约定的规则，明确规定函数调用时：
*   哪些寄存器用来**传递参数**（ARM上通常是R0-R3）。
*   哪些寄存器用来**存放返回值**（通常是R0）。
*   **哪些寄存器必须由被调函数保存和恢复**（称为 **Callee-saved registers**，如 R4-R8, R10-R11）。
*   **哪些寄存器可以被被调函数随意使用，调用者自己负责保存**（称为 **Caller-saved registers**，如 R0-R3, R9, R12）。

#### 如何工作？（以函数调用为例）

当一个函数（调用者）需要调用另一个函数（被调者）时：

1.  **调用者的工作**：
    *   它将需要传递给被调者的参数放入 R0-R3（如果参数很多，超出的部分会放在栈上）。
    *   它如果有一些放在 **Caller-saved寄存器**（如R0-R3）中的重要数据，它需要**自己**在调用前把这些数据**保存（PUSH）到自己的栈帧里**。

2.  **执行调用**：使用 `BL function_name` 指令，这会跳转到函数并将返回地址存入LR。

3.  **被调者的工作**：
    *   被调者函数一开始，如果它打算使用任何 **Callee-saved寄存器**（如R4-R8），它必须**首先**将这些寄存器的当前值**压入栈（PUSH）** 保存起来。
    *   然后它才能自由地使用这些寄存器进行计算。
    *   函数结束时，它必须**从栈中恢复（POP）** 所有它保存过的Callee-saved寄存器，使其值恢复到函数被调用时的状态。
    *   最后，使用 `BX LR` 返回。

4.  **调用者恢复**：
    *   调用者再从自己的栈帧中，恢复之前保存的Caller-saved寄存器。

通过这套严格的“规矩”，**所有函数都遵守同一个内存游戏规则**，保证了无论函数调用嵌套多深，寄存器都能被安全地共享和重复使用。内存中的“栈”扮演了临时的数据仓库角色，在需要时保存寄存器的状态，在用完后恢复。

**对于中断**，其过程类似但由硬件触发：CPU在跳转到中断程序前，会自动保存关键寄存器（如CPSR, PC）到异常模式的栈上，ISR程序开始后也会首先手动保存它要使用的通用寄存器。

### 总结

*   **寄存器是CPU的工作台**，数量少但速度快，用于进行**当前的、即时的**计算。
*   **内存是仓库**，容量巨大但速度慢，用于**长期存储**和**临时备份**寄存器的工作状态。
*   **调用约定和栈机制**是连接工作台和仓库的“物流系统”，它确保了大量任务能够有条不紊地、高效地共享有限的高速寄存器。

所以，回答你的问题：**寄存器本身不够用，但“寄存器+内存+一套严格的管理规则”这个系统，使得计算机能够高效地处理无限复杂的任务。** 这是一个在速度、成本和复杂性之间取得的完美平衡。