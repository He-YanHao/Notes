# STM32F1

## 新建工程

新建工程文件夹，并在下面新建`Doc`工程说明`Hardware`硬件驱动函数`Library`HAL库函数`Start`单片机启动引导函数`System`单片机本身的函数`User`主函数，子文件夹，并添加对应文件，作用如下，其余自动生成。

| 名称        | 作用                                          | 翻译   |
| ----------- | --------------------------------------------- | ------ |
| DebugConfig | 存储调试配置文件                              |        |
| Doc         | 工程说明.txt                                  |        |
| Hardware    | 存放硬件对应驱动程序                          | 硬件   |
| Library     | 存放库函数                                    | 图书馆 |
| Listings    | 存放编译器编译时候产生的c/汇编/链接的列表清单 | 清单   |
| Objects     | 编译过程的一些中间文件                        | 对象   |
| Start       | 存放引导函数                                  | 启动   |
| System      | 存放系统本身的驱动程序                        | 系统   |
| User        | 存放main函数                                  | 用户   |

> 其中System有可能用Core代替
>
> 其中Library有可能用Drivers代替

在KEIL5里面选择新建项目，选择项目文件夹，输入项目名称。

选择芯片型号。

在工程里创建对应的`Hardware`	`Library`	`Start`	`System`	`User`	子文件夹，并添加文件。

注意：Start文件夹里后缀为.s的文件只需要添加startup_stm32f10x_md.s，其他.c .h文件全部添加。

> 启动文件（.s文件）包含STM32的启动代码，其主要作用包括：1、堆栈（SP）的初始化；2、初始化程序计数器（PC）；3、设置向量表异常事件的入口地址；4、调用main函数等，是每个工程必不可少的一个文件，我们在本书第九章会有详细介绍。

配置魔术棒选项卡

选择C/C++选项

Define 输入 USE_STDPERIPH_DRIVER

Include Paths内声明所有包含头文件的文件夹

Debug 

在仿真器连接好电脑和开发板且开发板供电正常的情况下，打开编译软件KEIL，在魔术棒选项卡里面选择仿真器的型号，Debug 选项配置，选择对应的下载器。

旁边的Settings 选择Flash  Download，勾选Reset and Run



## 储存器架构 ## 



## CRC计算单元

使用CRC-32(以太网)多项式：0x4C11DB7  ─ X32 + X26 + X23 + X22 + X16 + X12 + X11 + X10 + X8 + X7 + X4 + X2 + X +1。



## PWR电源控制

STM32的低功耗模式分为三种：

| 模式     | 进入                                         | 唤醒                             | 特点                                         |
| -------- | -------------------------------------------- | -------------------------------- | -------------------------------------------- |
| 睡眠模式 | WFI(wait for interrupt)和WFE(wait for event) | 任何中断或事件都可以唤醒睡眠模式 | CPU时钟关闭，但是其他所有的外设仍可以运行    |
| 停止模式 |                                              | 任何EXTI线                       | 所有的时钟都关闭，所有的外设也就停止了工作。 |
| 待机模式 |                                              | 唤醒事件                         |                                              |

## BKP备份寄存器

备份寄存器是42个16位的寄存器，可用来存储84个字节的用户应用程序数据。掉电不丢失。

他们处在备份域里，当VDD电源被切断，他们仍然由VBAT维持供电。

当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位。

此外，BKP控制寄存器用来管理侵入检测和RTC校准功能。

复位后，对备份寄存器和RTC的访问被禁止，并且备份域被保护以防止可能存在的意外的写操作。

**使用流程：**

1. 开启对备份寄存器的访问
   1. 通过设置寄存器RCC_APB1ENR的PWREN和BKPEN位来打开电源和后备接口的时钟。
   2. 电源控制寄存器(PWR_CR)的DBP位来使能对后备寄存器和RTC的访问。
2. 开始使用库函数或者寄存器对备份寄存器的写入。

## RCC时钟

STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。



三种不同的时钟源可被用来驱动系统时钟(SYSCLK)：

- HSI振荡器时钟，由内部 8 MHz RC 振荡器生成，可直接作为系统时钟或在2分频后作为PLL输入。HSI RC 振荡器的优点是成本较低（无需使用外部组件）。此外，其启动速度也要比HSE 晶振块，但即使校准后，其精度也不及外部晶振或陶瓷谐振器。

  > 系统复位时，工厂校准值被装载到时钟控制寄存器的HSICAL[7:0]位。如果用户的应用基于不同的电压或环境温度，这将会影响RC振荡器的精度。可以通过时钟控制寄存器里的HSITRIM[4:0]位来调整HSI频率。

- HSE振荡器时钟，高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。

  > 高速外部时钟信号(HSE)由以下两种时钟源产生：
  >
  > ● HSE外部晶体/陶瓷谐振器
  >
  > ● HSE用户外部时钟
  >
  > 为了减少时钟输出的失真和缩短启动稳定时间，晶体/陶瓷谐振器和负载电容器必须尽可能地靠近振荡器引脚。负载电容值必须根据所选择的振荡器来调整。

- PLL时钟，锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。

  > 内部PLL可以用来倍频HSI RC的输出时钟或HSE晶体输出时钟。参考图8和时钟控制寄存器。
  >
  > PLL的设置(选择HIS振荡器除2或HSE振荡器为PLL的输入时钟，和选择倍频因子)必须在其被激活前完成。一旦PLL被激活，这些参数就不能被改动。
  >
  > 如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪时，可产生中断申请。
  >
  > 如果需要在应用中使用USB接口，PLL必须被设置为输出48或72MHZ时钟，用于提供48MHz的USBCLK时钟。

- LSI是低速内部时钟，RC振荡器，频率为40kHz。

  > LSI  RC担当一个低功耗时钟源的角色，它可以在停机和待机模式下保持运行，为独立看门狗和自动唤醒单元提供时钟。LSI时钟频率大约40kHz(在30kHz和60kHz之间)。进一步信息请参考数据手册中有关电气特性部分。

- LSE是低速外部时钟，接频率为32.768kHz的石英晶体。

  > LSE晶体是一个32.768kHz的低速外部晶体或陶瓷谐振器。它为实时时钟或者其他定时功能提供一个低功耗且精确的时钟源。

当不被使用时，任一个时钟源都可被独立地启动或关闭，由此优化系统功耗。

系统时钟(SYSCLK)选择

系统复位后，HSI振荡器被选为系统时钟。当时钟源被直接或通过PLL间接作为系统时钟时，它将不能被停止。只有当目标时钟源准备就绪了(经过启动稳定阶段的延迟或PLL稳定)，从一个时钟源到另一个时钟源的切换才会发生。在被选择时钟源没有就绪时，系统时钟的切换不会发生。直至目标时钟源就绪，才发生切换。在时钟控制寄存器(RCC_CR)里的状态位指示哪个时钟已经准备好了，哪个时钟目前被用作系统时钟。

## GPIO和AFIO

首先开启时钟，然后定义结构体，再依此对GPIO口的位置，工作模式，速度进行配置。

位置通过A~E和0~15决定

速度有三个档次

工作模式有八种：

​	其中四种输入四种输出，四种输入为数字输入和模拟输入，根据悬空默认电平分为三种，模拟输入。

​	根据高电平的不同区分开漏和推挽，二者驱动力不同；有片上外设控制输出为复用。



### **STM32的八种工作模式**

| 代码                  | 模式名称     | 性质     | 特征                                                        |
| --------------------- | ------------ | -------- | ----------------------------------------------------------- |
| GPIO_Mode_IN_FLOATING | 浮空输入     | 数字输入 | 可读取电平，若引脚悬空，则电平不稳定。                      |
| GPIO_Mode_IPU         | 上拉输入     | 数字输入 | 可读取引脚电平，内部接上拉电阻，悬空默认高电平。            |
| GPIO_Mode_IPD         | 下拉输入     | 数字输入 | 可读取引脚电平，内部接下拉电阻，悬空默认低电平。            |
| GPIO_Mode_AIN         | 模拟输入     | 模拟输入 | GPIO无效，接入内部ADC。                                     |
| GPIO_Mode_Out_OD      | 开漏输出     | 数字输出 | 可输出引脚电平，高电平为高阻态，低电平接VCC。驱动能力较小。 |
| GPIO_Mode_Out_PP      | 推挽输出     | 数字输出 | 可输出引脚电平，高电平为VDD，低电平接VCC。驱动能力较大。    |
| GPIO_Mode_AF_OD       | 复用开漏输出 | 数字输出 | 有片上外设控制，高电平为高阻态，低电平接VCC。               |
| GPIO_Mode_AF_PP       | 复用推挽输出 | 数字输出 | 有片上外设控制，高电平为VDD，低电平接VCC。                  |



## 中断

出现特定条件则中断原有程序，开始处理中断程序，完毕后回到原有程序继续运行。

68个可屏蔽中断通道包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设。

中断分为多个优先级，低级可以嵌套高级。

### NVIC

NVIC为嵌套中断向量控制器，用来统一分配中断优先级和管理中断的。

嵌套由响应优先级和抢占优先级决定。

**响应优先级越高则可以响应的越快，抢占优先级越高则可以嵌套的越深。**

响应优先级和抢占优先级共同由一个四位寄存器决定。

> 配置NVIC为分组2，即抢占优先级范围：0~3，响应优先级范围：0~3。
>
> 此分组配置在整个工程中仅需调用一次。若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置。
>
> | 分组  | 抢占优先级      | 响应优先级      |
> | ----- | --------------- | --------------- |
> | 分组0 | 0位，取值为0    | 4位，取值为0~15 |
> | 分组1 | 1位，取值为0~1  | 3位，取值为0~7  |
> | 分组2 | 2位，取值为0~3  | 2位，取值为0~3  |
> | 分组3 | 3位，取值为0~7  | 1位，取值为0~1  |
> | 分组4 | 4位，取值为0~15 | 0位，取值为0    |

**NVIC配置流程：**

* 定义结构体；
* NVIC_IRQChannel：选择配置中断函数的名称。
* NVIC_IRQChannelCmd：指定NVIC线路使能。
* NVIC_IRQChannelPreemptionPriority：指定NVIC线路的抢占优先级。
* NVIC_IRQChannelSubPriority：指定NVIC线路的响应优先级。
* 存放结构体变量交给NVIC_Init，配置NVIC外设。

### EXTI

中断分为内部中断和外部中断，外部中断常见为绑定某个GPIO口，监测电位，名为EXTI。

EXTI支持23个外部中断/事件请求，这些都是信息输入端，也就是上面提及到了输入线，具体如下：

> - EXTI线0~15：对应外部IO口的输入中断
> - EXTI线16：连接到PVD输出
> - EXTI线17：连接到RTC闹钟事件
> - EXTI线18：连接到USB唤醒事件
> - EXTI线19：连接到以太网唤醒事件
> - EXTI线20：连接到USBOTG HS（在FS中配置）唤醒事件
> - EXTI线21：连接到RTC入侵和时间戳事件
> - EXTI线22：连接到RTC唤醒事件

从上面可以看出，STM32F407供给IO口使用的中断线只有16个，但是STM32F407的IO口却远远不止16个，所以STM32把GPIO管脚GPIOx.0~GPIOx.15(x=A,B,C,D,E,F,G)分别对应中断线0~15。这样子每个中断线对应了最多7个IO口，以线0为例：它对应了GPIOA.0、GPIOB.0、GPIOC.0、GPIOD.0、GPIOE.0、GPIOF.0和GPIOG.0。而中断线每次只能连接到1个IO口上，这样就需要通过配置决定对应的中断线配置到哪个GPIO上了，所以编号相同的GPIO口使用同一个EXTI外设，无法同时中断。

EXTI0到EXTI4有自己的中断函数，EXTI5到EXTI9使用EXTI9_5_IRQHandler，EXTI10到EXTI15使用EXTI15_10_IRQHandler。

**EXTI初始化的步骤为：**

首先开启AFIO和对应GPIO口的时钟，将外部中断的X号线映射到GPIOX，即选择(0~15)为外部中断引脚。

初始好对应的GPIO口，设置为上拉输入或下拉输入。

定义EXTI和NVIC的结构体变量，并绑定。

写中断函数。

## DMA控制器

将数据从一个地方搬运到另一个地方，借助了硬件，减少了对CPU的占用。



## ADC模拟数字转化

ADC读取模拟电路将其转化为数字电路，



## DAC数字模拟转换



## TIM定时器

## 定时器

STM32总共有8个定时器，分别是2个高级定时器（TIM1、TIM8），4个通用定时器（TIM2、TIM3、TIM4、TIM5）和2个基本定时器（TIM5、TIM6）。

计数周期TIM_Period，即ARR的值，实际就是设定自动重载寄存器的值，在事件生成时更新到影子寄存器。可设置范围为 0 至 65535。

预分频器TIM_Prescaler，即PSC的值，时钟源经该预分频器才是定时器时钟，它设定 TIMx_PSC寄存器的值。可设置范围为 0 至 65535，实现 1 至 65536 分频。

根据定时器时钟的频率，比如时钟的频率是72MHZ，可以理解为一秒钟STM32会自己数72M次，预分频系数就是将频率分割，比如分频系数是72，则该时钟的频率会变成72MHZ/72=1MHZ，但是在设置的时候要注意，数值应该是72-1。

假定分频系数是72-1，那么频率变成1MHZ，也就意味着STM32在一秒钟会数1M次，即1us数一次。

好了，接下来就是确定预装载值，比如需要定时1ms，由于1ms=1us*1000,那么预装载值就是1000-1；如此类推，在预分频系数确定的情况下，定时的时长就由预装载值确定了。至于要把值减一的原因，估计是计数是从0开始，所以要减一。

时钟源来自RCC的TIMXCLK，就是内部时钟（CK_INT）直接经过控制器传给时基单元充当CK_PSC。

> 计数器寄存器（TIMx_PSC)
> TIM_Prescaler = 72 - 1;	预分频器，即PSC的值
> 可将时钟频率按1到65535之间的任意值进行分频，可在运行时改变其设置值；
>
> 自动装载寄存器（TIMx_ARR)
> TIM_Period = 200 - 1; 计数周期，即ARR的值
> 如果TIMx_CR1寄存器中的ARPE位为0，ARR寄存器的内容将直接写入影子寄存器；如果ARPE为1，ARR寄存器的那日同将在每次的更新时间UEV发生时，传送到影子寄存器；

- 定时时间(单位us)=((PSC+1)*(ARR+1))/TimeClockFren（输入时钟频率（单位MHZ））。

- 计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)。

- 计数器溢出：CK_CNT_OV = CK_CNT / (ARR + 1) = CK_PSC / (PSC + 1) / (ARR + 1)



**定时器配置流程为：**

1. 开启定时器时钟
2. 选择内部时钟或其他时钟
3. 开始定义时钟的结构体：选项包括分频，计数器模式，计数周期，预分频器，高级定时器的重复计数器，存放结构体变量。
4. 清除定时器更新标志位，若不清除此标志位，则开启中断后，会立刻进入一次中断。
5. 开启TIM2的更新中断，定时器中断开始运行。
6. 使能TIM2，定时器开始运行。

定时器的中断函数为TIM(x)_IRQn



```
void TIM2_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
	{
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
	}
}
```



### 高级定时器

## PWM

PWM为脉冲宽度调控。

重点有三个参数，

**频率Freq = CK_PSC / (PSC + 1) / (ARR + 1)**

**占空比Duty = CCR / (ARR + 1)**

**分辨率Reso = 1 / (ARR + 1)**



**定时器工作在递增计数模式时：**

* 当CNT<CCRx时，IO输出低电平（逻辑0）；
* 当CNT>=CCRx时，IO输出高电平（逻辑1）；
* 当CNT=ARR时，定时器溢出，CNT的值被清零；然后继续递增，依次循环。

在这个循环中，改变CCRx的值，就可以改变PWM的占空比，改变ARR的值，就可以改变PWM的频率，这就是PWM输出的原理。





**开启PWM的流程：**

1. 开启TIM(x)的时钟

2. 重映射

3. 初始化好TIM结构体

4. 输出比较初始化：

   先整体初始化确定一个默认值，避免出现问题。

   TIM_OCMode_PWM(x)：输出比较模式，选择PWM模式(x)。

   TIM_OCPolarity：确定输出极性，选择为高，若选择极性为低，则输出高低电平取反。

   TIM_OutputState：输出使能

   TIM_Pulse：初始的CCR值

5. 将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1

/**

  * 函    数：PWM设置CCR
  * 参    数：Compare 要写入的CCR的值，范围：0~100
  * 返 回 值：无
  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比
  * 占空比Duty = CCR / (ARR + 1)
    */
    void PWM_SetCompare1(uint16_t Compare)
    {
    TIM_SetCompare1(TIM2, Compare);		//设置CCR1的值
    }

```
void PWM_Init(void)
{
	/*GPIO重映射*/
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);			//开启AFIO的时钟，重映射必须先开启AFIO的时钟
//	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);			//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册
//	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);		//将JTAG引脚失能，作为普通GPIO引脚使用

	/*输出比较初始化*/

}


```

```
/**
  * 函    数：PWM设置CCR
  * 参    数：Compare 要写入的CCR的值，范围：0~100
  * 返 回 值：无
  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比
  *           占空比Duty = CCR / (ARR + 1)
  */
void PWM_SetCompare1(uint16_t Compare)
{
	TIM_SetCompare1(TIM2, Compare);		//设置CCR1的值
}
```

WW

### 通用定时器

### 基本定时器

## RTC实时时钟

STM32F407的RTC时钟源（RTCCLK）通过时钟控制器，可以从LSE时钟、LSI时钟以及HSE时钟三者中选择其一（通过设置RCC_BDCR寄存器选择）。一般我们选择LSE，即外部32.768KHz晶振作为时钟源(RTCCLK)。外部晶振具有精度高的优点。LSI是STM32芯片内部的低速RC 振荡器，频率约32 KHz，缺点是精度较低，所以一般不建议使用。比如当没有外部低速晶振（32.768KHz）的时候，分频后的HSE可以作为备选使用的时钟源。

一个六位uint16_t类型数组取地址后存放在time_t time_cnt;秒计数器数据类型的变量里，就是- 8 * 60 * 60为东八区的时区调整

1. 
2. 

```
/**
  * 函    数：RTC设置时间
  * 参    数：无
  * 返 回 值：无
  * 说    明：调用此函数后，全局数组里时间值将刷新到RTC硬件电路
  */
void MyRTC_SetTime(void)
{
	time_t time_cnt;		//定义秒计数器数据类型
	struct tm time_date;	//定义日期时间数据类型
	
	time_date.tm_year = MyRTC_Time[0] - 1900;		//将数组的时间赋值给日期时间结构体
	time_date.tm_mon = MyRTC_Time[1] - 1;
	time_date.tm_mday = MyRTC_Time[2];
	time_date.tm_hour = MyRTC_Time[3];
	time_date.tm_min = MyRTC_Time[4];
	time_date.tm_sec = MyRTC_Time[5];
	
	time_cnt = mktime(&time_date) - 8 * 60 * 60;	//调用mktime函数，将日期时间转换为秒计数器格式
													//- 8 * 60 * 60为东八区的时区调整
	
	RTC_SetCounter(time_cnt);						//将秒计数器写入到RTC的CNT中
	RTC_WaitForLastTask();							//等待上一次操作完成
}

/**
  * 函    数：RTC读取时间
  * 参    数：无
  * 返 回 值：无
  * 说    明：调用此函数后，RTC硬件电路里时间值将刷新到全局数组
  */
void MyRTC_ReadTime(void)
{
	time_t time_cnt;		//定义秒计数器数据类型
	struct tm time_date;	//定义日期时间数据类型
	
	time_cnt = RTC_GetCounter() + 8 * 60 * 60;		//读取RTC的CNT，获取当前的秒计数器
													//+ 8 * 60 * 60为东八区的时区调整
	
	time_date = *localtime(&time_cnt);				//使用localtime函数，将秒计数器转换为日期时间格式
	
	MyRTC_Time[0] = time_date.tm_year + 1900;		//将日期时间结构体赋值给数组的时间
	MyRTC_Time[1] = time_date.tm_mon + 1;
	MyRTC_Time[2] = time_date.tm_mday;
	MyRTC_Time[3] = time_date.tm_hour;
	MyRTC_Time[4] = time_date.tm_min;
	MyRTC_Time[5] = time_date.tm_sec;
}

```





## IWDG独立看门狗 ## 

独立看门狗本质上是一个定时器，这个定时器有一个输出端，可以输出复位信号。该定时器是一个12位的递减计数器，当计数器的值减到0的时候，就会产生一个复位信号。如果在计数没减到0之前，重置计数器的值的话，那么就不会产生复位信号，这个动作我们称为喂狗。看门狗功能由VDD电压域供电，在停止模式和待机模式下仍然可以工作。

STM32F1系列的独立看门狗频率为40KHz，则溢出时间为[1s/(频率/分频数)]*(重装值+1) 秒，若超过该时间则自动复位，可以通过重装计数器的方式（俗称喂狗）将时间清零。



## WWDG窗口看门狗

和独立看门狗不同的是，窗口看门狗存在一个下限和一个上限。

当计数器的值减到0x40之后喂狗，下一个计数仍会重启，这个值称为窗口的下限值，是固定的值，不能改变。

当计数器的值减到某一个值之前喂狗，下一个计数仍会重启，这个值称为窗口的上限值，可以自己设定。

窗口看门狗计数器的上限值和下限值就是窗口的含义，喂狗也必须在窗口之内，否则就会复位。



## FSMC静态储存控制器

## SDIO接口

## USB全速设备接口





## bxCAN控制器局部网

## SPI串行外设接口

SPI 通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为，它们的作用介绍如下：

* SCK(Serial Clock) ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如STM32的SPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。

* MOSI(Master Output，Slave Input) ：主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。

* MISO(Master Input,，Slave Output) ：主设备输入/从设备输出引脚。主机从这条信线读入数据， 从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。

* SS(Slave Select)：从设备选择信号线，或片选信号线，也称为NSS、CS。当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并 联到相同的SPI总线上，即无论有多少个从设备，都共同只使用这3条总线；而每个从设备都有独立的这一条NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就 有多少条片选信号线。

  SPI通信没有设备地址，通过SS线确定，当主机要选择从设备时， 把该从设备的SS信号线设置为低电平，该从设备即被选中，即片选有效，所以SS默认高电平，接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以SS线置低电平为开始信号，以SS线 被拉高作为结束信号。

MISO初始化为上拉输入，其余初始化为推挽输出。



## I2C接口

通过SCL(时钟线)和SDA(数据线)来完成数据的交换。配置为开漏输出模式或者复用开漏输出模式，且均需添加4.7KΩ的上拉电阻。

I2C 使用 SDA 信号线来传输数据，使用SCL信号线进行数据同步。

SDA数据线在 SCL 的每个时钟周期传输一位数据。

传输时，SCL为高电平的时候SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。

当SCL为低电平时，SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备。

I2C可以通过普通GPIO口用软件模拟出来，称为软件I2C，或者使用单片机本身的I2C功能，称为硬件I2C。

**I2C的电位变化**

SCL和SDA平时均为高电平，当主机的SDA下降时，从机复位，并且主机的SCL下降，这是**I2C的开始**。

> 先释放主机的SCL和SDA，即将二者都拉高，作为平时状态，然后在SCL高电平期间，拉低SDA，产生起始信号，起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接。

**I2C结束**时SCL回到高电平，SDA跟着回到高电平。

> 拉低SDA，确保SDA为低电平，释放SCL，使SCL呈现高电平，在SCL高电平期间，释放SDA，产生终止信号。

**发送一个字节的数据**：主机的SCL低电平期间，将主机的数据位依此放在SDA线上， 从机读取，之后主机SCL恢复高电平，结束第一位，重复八次可以发送一个字节。

**接受一个字节的数据**：主机的SCL低电平期间，从机依次将数据位依此放在SDA线上，然后释放SCL，读取SDA的电平，结束第一位，重复八次可以发送一个字节。

**I2C基本写过程**

* 起始信号开始

  > 先释放主机的SCL和SDA，即将二者都拉高，作为平时状态，然后在SCL高电平期间，拉低SDA，产生起始信号，起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接。

* 发送7位从机地址

  > I2C设备从机地址一般为七位，可以通过特定引脚的高低电平来改变地址。

* 发送读或写

  > 传输方向选择位，1为读，0为写，与从机地址共同构成一个字节。
  >
  > 这里一般是将从机地址末尾加0，作为一个字节发送，读的时候与0x01取或。

* 从机应答或不应答

  > I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到I2C传输的一个字节数据或地址后，若希望对方继 续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。
  >
  > 传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制 SDA，若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。

* 发送数据

  > 一般包含两部分，指令和数据。
  >
  > 上面的整体可以理解为刚发送一个字节和一个位，接下来发送的数据一般是寄存器的地址，可以开启寄存器特定功能，发送给特定的寄存器后可以发送数据。





*并非每传输8位数据之后，都会有ACK信号，有以下3中例外*

1. *当从机不能响应从机地址时(例如它正忙于其他事而无法响应IIC总线的操作，或者这个地址没有对应的从机)，在第9个SCL周期内SDA线没有拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。*
2. *如果从机接收器在传输过程中不能接收更多的数据时，它不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。*
3. *主机接收器在接收到最后一个字节后，也不会发出ACK信号。于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。*



## USART通用同步异步发射器

拥有**TX发送端口**和**RX接收端口**，二者交叉连接，若电平标准不一需要进行转化。



## USB OTG全速

## MAC以太网 



## 器件签名

## DBG调试支持

