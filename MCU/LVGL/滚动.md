这个问题问得**非常好，而且你看到的两种现象都是真的**。
关键在于：**你看到的是两个“默认行为被不同条件触发”的结果**。

我们把这件事一次性说清楚，不留歧义。

------

## 结论先给（很重要）

>   **LVGL 默认：**
>
>   -   **父对象是“可滚动的（scrollable）” → 子对象超出 → 出现滚动行为**
>   -   **父对象不是可滚动的 → 子对象超出 → 被裁剪（不显示）**

也就是说：

>   ❗**是否显示滚动条，取决于父对象是否开启了“滚动能力”，而不是“有没有子对象超界”本身**

------

## 1️⃣ 先明确两个完全不同的机制

### LVGL 里有两件独立的事：

1.  **裁剪（clip）**
2.  **滚动（scroll）**

很多文档/教程把它们混在一句话里说，导致严重误解。

------

## 2️⃣ 默认情况下，父对象到底“能不能滚动”？

### 答案是：**看对象类型**

#### 普通 `lv_obj_create()`：

```c
lv_obj_t * parent = lv_obj_create(scr);
```

在 **LVGL v8** 中：

>   ✔ **默认是可滚动的（scrollable）**

也就是说：

-   子对象超出
-   父对象内容尺寸变大
-   **可以滚动查看**

------

## 3️⃣ 那为什么你见过“超出就不显示”？

因为下面几种情况之一成立 👇

------

## 情况 A：父对象关闭了滚动

```c
lv_obj_clear_flag(parent, LV_OBJ_FLAG_SCROLLABLE);
```

此时：

-   子对象仍然存在
-   但绘制被裁剪
-   **超出部分不显示**
-   没有滚动条

👉 **这是最常见的原因**

------

## 情况 B：父对象开启了裁剪

```c
lv_obj_set_style_clip_corner(parent, true, 0);
```

这会导致：

-   子对象超出父对象区域
-   **直接被裁掉**
-   与滚动无关

很多人误以为这是“没滚动条”

------

## 情况 C：父对象本身不是“容器型对象”

例如：

-   `lv_btn`
-   `lv_label`
-   `lv_img`

这些对象：

-   设计目的不是当“滚动容器”
-   即使有子对象
-   也常常表现为 **裁剪而不是滚动**

------

## 4️⃣ 滚动条 ≠ 滚动能力（这是一个坑）

再强调一次：

>   **滚动条只是“视觉提示”**
>   **滚动能力是“行为属性”**

------

### 默认情况下：

-   父对象 **可以滚动**
-   但 **滚动条可能是隐藏的**

取决于：

```c
lv_obj_set_scrollbar_mode(parent, LV_SCROLLBAR_MODE_AUTO);
```

几种模式：

| 模式     | 含义           |
| -------- | -------------- |
| `OFF`    | 永不显示       |
| `ON`     | 一直显示       |
| `AUTO`   | 需要时显示     |
| `ACTIVE` | 正在滚动时显示 |

------

## 5️⃣ 一个最小对比实验（你可以自己试）

### 情况 1：默认（会滚）

```c
lv_obj_t * parent = lv_obj_create(scr);
lv_obj_set_size(parent, 100, 100);

lv_obj_t * child = lv_obj_create(parent);
lv_obj_set_size(child, 100, 200);
```

👉 结果：

-   parent 可滚动
-   child 超出
-   可以上下滑动

------

### 情况 2：关闭滚动（被裁）

```c
lv_obj_clear_flag(parent, LV_OBJ_FLAG_SCROLLABLE);
```

👉 结果：

-   child 超出部分不显示
-   无法滚动

------

## 6️⃣ 那“默认自动开启滚动条”这句话哪里不严谨？

更严谨的说法应该是：

>   **当父对象是可滚动对象，且内容尺寸超出时，LVGL 会启用滚动机制，并根据 scrollbar 模式决定是否显示滚动条**

很多资料为了省事，直接说成了：

>   “子对象超出 → 自动有滚动条”

这是 **不完整甚至误导的说法**。

------

## 7️⃣ 给你一个可以长期记住的判断公式

你可以用这三步判断“为什么没显示”：

1.  **父对象有没有 `LV_OBJ_FLAG_SCROLLABLE`？**
2.  **有没有启用 clip？**
3.  **对象类型是否设计成容器？**

------

## 最终总结（强烈建议你记这段）

>   -   子对象超出 ≠ 一定有滚动条
>   -   **滚动是行为，滚动条是外观**
>   -   默认 `lv_obj_create()` 是可滚动的
>   -   关闭 scroll → 超出就裁掉
>   -   clip 会强制裁剪
>   -   你看到的两种情况都“对”，只是前提不同

------

你现在问的已经是 **LVGL 对象行为模型** 的细节了，
这正是从“能跑 demo”迈向“能写稳定 UI”的分水岭。

如果你愿意，下一步我可以帮你把：

👉 **scroll / clip / layout / align 这四者的关系画成一张“不会混”的 mental model**

这一步做完，你之后基本不会再被这类问题坑。