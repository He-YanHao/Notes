对齐（**Alignment**）是 LVGL 里**非常核心、但又极容易被误解**的一块。
你如果把“对齐”理解成**摆放规则**，而不是“算坐标的工具”，后面所有布局都会顺得多。

我会按：**是什么 → 怎么算 → 有哪些方式 → 常见坑 → 工程经验** 来讲。

------

## 一句话定义

>   **对齐 = 以某个对象为参考，把当前对象放到一个“语义位置”上**

它的本质不是“移动像素”，而是**建立相对关系**。

------

## 1️⃣ 对齐和 `set_pos()` 的根本区别

### `lv_obj_set_pos(obj, x, y)`

-   你在**直接指定坐标**
-   不关心父对象大小
-   分辨率一变就可能炸

### `lv_obj_align()`

-   你在说：

    >   “把我放在它的左上 / 中央 / 右下”

-   LVGL 自动算坐标

------

## 2️⃣ 对齐一定有“参照物”

对齐永远回答三个问题：

1.  **谁要被对齐？**（obj）
2.  **对齐到谁？**（base）
3.  **对齐到哪个方位？**（align type）

------

## 3️⃣ 最核心 API

### ① 对齐到父对象（最常用）

```c
lv_obj_align(obj, LV_ALIGN_TOP_LEFT, 0, 0);
```

含义是：

>   **把 obj 对齐到父对象的左上角**

如果你传 `NULL`：

```c
lv_obj_align(obj, LV_ALIGN_CENTER, 0, 0);
```

👉 默认对齐到父对象（screen 也算父对象）

------

### ② 对齐到另一个对象

```c
lv_obj_align_to(obj, ref, LV_ALIGN_OUT_RIGHT_MID, 10, 0);
```

含义是：

>   **把 obj 放在 ref 的右侧中间，间隔 10px**

------

## 4️⃣ 对齐类型（你真正要理解的部分）

### 对齐类型 = **“点 + 点”**

不是魔法。

例如：

| 对齐方式                | 意义                    |
| ----------------------- | ----------------------- |
| `LV_ALIGN_TOP_LEFT`     | obj 的左上 → ref 的左上 |
| `LV_ALIGN_CENTER`       | obj 的中心 → ref 的中心 |
| `LV_ALIGN_BOTTOM_RIGHT` | obj 的右下 → ref 的右下 |

------

### “OUT” 系列（非常重要）

| 类型                      | 含义             |
| ------------------------- | ---------------- |
| `LV_ALIGN_OUT_TOP_MID`    | 放在参考对象上方 |
| `LV_ALIGN_OUT_BOTTOM_MID` | 放在下方         |
| `LV_ALIGN_OUT_LEFT_MID`   | 左侧             |
| `LV_ALIGN_OUT_RIGHT_MID`  | 右侧             |

>   **OUT = 不重叠**

------

## 5️⃣ 对齐是“即时计算”的

这是一个非常重要但容易忽略的点。

```c
lv_obj_align(obj, LV_ALIGN_CENTER, 0, 0);
```

**只在调用时算一次坐标。**

如果：

-   父对象尺寸改变
-   屏幕分辨率改变

👉 **不会自动重新对齐**

------

### 那怎么办？

#### 方法 1（最简单）

重新调用 `lv_obj_align()`

#### 方法 2（更工程化）

用 **Flex / Grid 布局**

------

## 6️⃣ 对齐和 Z-order 没关系

-   对齐：决定 **在哪里**
-   Z-order：决定 **谁在上面**

你可以对齐两个对象到同一位置：

-   后创建的会盖住前面的

------

## 7️⃣ 对齐和 Style 没关系

Style 只影响：

-   外观
-   padding / margin（在布局中）

对齐只关心：

-   外框（bounding box）

------

## 8️⃣ 常见误区（你大概率会踩）

### ❌ “对齐会一直生效”

不会。
它不是约束系统。

------

### ❌ “对齐会影响子对象”

不会。
只影响当前对象。

------

### ❌ “对齐 = 布局”

不是。
对齐是**一次性摆放**，布局是**持续管理**。

------

## 9️⃣ 工程级经验总结（你可以直接记）

>   -   **临时摆位置 → 用 align**
>   -   **复杂界面 → 用 flex / grid**
>   -   **OUT_xxx 是最常用的**
>   -   **不要在循环里 align**
>   -   **分辨率可变时，别依赖 align**

------

## 10️⃣ 一个极小示例（强化直觉）

```c
lv_obj_t * a = lv_obj_create(scr);
lv_obj_set_size(a, 40, 40);

lv_obj_t * b = lv_obj_create(scr);
lv_obj_set_size(b, 20, 20);

lv_obj_align(a, LV_ALIGN_CENTER, 0, 0);
lv_obj_align_to(b, a, LV_ALIGN_OUT_RIGHT_MID, 5, 0);
```

你会看到：

-   a 在中间
-   b 紧贴在 a 右侧

------

## 最终一句话（请记住）

>   **对齐不是算坐标，而是建立“相对位置语义”**

你已经掌握了：

-   Object
-   Z-order
-   Style
-   透明度
-   对齐

下一步非常自然的进阶就是：

👉 **Flex 布局（真正“不用算坐标”）**

如果你愿意，我可以用**一个和你现在知识完全衔接的方式**来讲 Flex。