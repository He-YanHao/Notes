# 低功耗使用理念

## 实际使用建议

-   **启用调试接口**：在进入低功耗模式前，如果使用了调试器（如J-Link），可能需要配置MCU的调试模块，确保唤醒后调试连接依然正常。例如STM32可使用 `DBGMCU_Config(DBGMCU_SLEEP, ENABLE)`。
-   **功耗与唤醒的平衡**：进入越深的低功耗模式，功耗越低，但唤醒所需的时间和能量也越多。需要根据应用场景（如最大可容忍的响应延迟）来选择合适的低功耗级别。
-   **注意外设管理**：在进入睡眠前，通过 `configPRE_SLEEP_PROCESSING` 宏对应的函数，关闭不必要的 GPIO、外设时钟等，以进一步降低功耗。唤醒后，再在 `configPOST_SLEEP_PROCESSING` 对应的函数中恢复。



## 功耗优化关键措施

### 时钟与外设管理  

- 休眠前降频主时钟或切换至内部RC振荡器。
- 关闭未使用外设时钟（如ADC、UART）。

### IO状态配置  

- 睡眠/停止模式：保持IO原状态。
- 待机模式：IO置高阻态（除唤醒引脚外）。

### 中断与调试影响  

- 避免调试器连接时测量功耗（调试接口会增加电流）。
- 确保唤醒中断优先级低于调度器中断（防止任务调度被打断）。



## 重要注意事项

### 执行时间限制

```c
void vPreSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 必须快速执行！
    // 执行时间过长会影响低功耗效果
}
```

### 中断安全性

```c
void vPreSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 在调用这些函数时，调度器已被挂起
    // 但中断仍然启用
    
    // 可以安全地操作硬件寄存器
    // 但要避免调用FreeRTOS API函数
}
```

### **外设状态管理**

```c
void vPreSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 在关闭外设前保存状态
    SavePeripheralState();
    
    // 关闭外设
    DisablePeripherals();
}

void vPostSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 恢复外设到之前的状态
    RestorePeripheralState();
}
```

## 最佳实践建议

### 分层电源管理

```c
void vPreSleepProcessing( TickType_t xExpectedIdleTime )
{
    if( xExpectedIdleTime < 5 ) {
        // Level 1: 最浅睡眠
        LightSleep();
    } else if( xExpectedIdleTime < 50 ) {
        // Level 2: 中等睡眠  
        MediumSleep();
    } else {
        // Level 3: 深度睡眠
        DeepSleep();
    }
}
```

### 状态保存与恢复

```c
typedef struct {
    uint32_t gpioConfig;
    uint32_t clockConfig;
    uint32_t peripheralState;
} SleepContext_t;

static SleepContext_t g_sleepContext;

void vPreSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 保存当前状态
    g_sleepContext.gpioConfig = SaveGPIOState();
    g_sleepContext.clockConfig = SaveClockState();
    g_sleepContext.peripheralState = SavePeripheralState();
    
    // 进入低功耗
    EnterLowPowerMode();
}

void vPostSleepProcessing( TickType_t xExpectedIdleTime )
{
    // 恢复之前的状态
    RestoreGPIOState( g_sleepContext.gpioConfig );
    RestoreClockState( g_sleepContext.clockConfig );
    RestorePeripheralState( g_sleepContext.peripheralState );
}
```

