# FreeRTOS低功耗

## 基本介绍

FreeRTOS的低功耗设计核心在于其**Tickless模式**，该模式通过动态抑制系统节拍（Tick）中断，显著延长MCU在空闲任务中的低功耗状态时间，从而大幅降低整体功耗。以下从原理、实现、配置及优化角度系统解析：



## Tickless模式的工作原理
### 问题背景

- 传统RTOS在空闲任务中通过`WFI`/`WFE`指令进入睡眠模式，但周期性Tick中断（通常1ms一次）会频繁唤醒MCU，导致功耗增加。
- 频繁唤醒不仅增加能耗，还阻碍MCU进入深度睡眠模式（如Stop模式）。



### 解决方案

Tickless设计

- **动态Tick抑制**：当空闲任务成为唯一可运行任务时，FreeRTOS关闭Tick中断，根据下一个任务的唤醒时间计算低功耗时长，并设置定时器在此时间后唤醒。
- **系统时钟补偿**：唤醒后，通过低功耗定时器（如RTC、LPTIM）记录休眠时间，补偿给系统时钟，确保任务调度时序正确。



## 关键实现机制
### 触发条件

- 空闲任务运行时，且无其他就绪任务。
- 预计空闲时间 ≥ `configEXPECTED_IDLE_TIME_BEFORE_SLEEP`（默认2个Tick，需≥2）。



### 核心函数与配置

- **`portSUPPRESS_TICKS_AND_SLEEP(xExpectedIdleTime)`** 
  由空闲任务调用，负责关闭Tick中断、计算休眠时长、设置唤醒定时器及进入低功耗模式。
- **预处理与后处理钩子**  
  
  - `configPRE_SLEEP_PROCESSING()`：休眠前关闭外设时钟、切换低速时钟源等。
  - `configPOST_SLEEP_PROCESSING()`：唤醒后恢复时钟和外设。
- **启用配置**  
  在`FreeRTOSConfig.h`中设置：
  ```c
  #define configUSE_TICKLESS_IDLE  1  // 启用Tickless
  #define configEXPECTED_IDLE_TIME_BEFORE_SLEEP  3 // 最小休眠Tick数
  ```



## 与MCU低功耗模式结合
FreeRTOS默认使用**睡眠模式（Sleep）**，但可扩展至更深度模式（如STM32的Stop/Standby模式）：

| **模式**     | **功耗** | **唤醒延迟** | **实现方式**                                                 |
| ------------ | -------- | ------------ | ------------------------------------------------------------ |
| **睡眠模式** | 中       | 极低（µs级） | 默认模式，通过`WFI`进入，任何中断唤醒。                      |
| **停止模式** | 低       | 中等（ms级） | 需在`configPRE_SLEEP_PROCESSING`中配置，关闭高速时钟，由外部中断/RTC唤醒。 |
| **待机模式** | 极低     | 高（复位）   | 应用较少，唤醒后系统复位。                                   |

**示例：STM32停止模式集成**  

- 替换Tick定时器为RTC/LPTIM（因SysTick在Stop模式下停止工作）。
- 在`vPortSuppressTicksAndSleep()`中配置RTC唤醒时间，并通过`HAL_PWR_EnterSTOPMode()`进入Stop模式。




