# 互斥量 (Mutex - Mutual Exclusion Semaphore)

## 官方描述

互斥锁是包含优先级继承机制的二进制信号量 。鉴于二进制信号量是实现同步（任务之间或任务与中断之间） 的更好方式，因此互斥锁更适合实现简单的 相互排斥（即互斥）。

用于互斥时， 互斥锁就像用于保护资源的令牌。当一个 任务希望访问资源时，必须首先获得（“获取”）该令牌。使用完资源后， 任务必须“返还”令牌，以便其他任务有机会访问 相同的资源。

互斥锁使用相同的信号量访问 API 函数，因此也能指定阻塞时间。该 阻塞时间表示一个任务试图“获取”互斥锁，而互斥锁无法立即使用时， 任务应进入阻塞状态的最大“滴答”数。然而，与二进制信号量不同， 互斥锁采用优先级继承机制。这意味着如果高优先级任务进入阻塞状态，同时 尝试获取当前由低优先级任务持有的互斥锁（令牌）， 则持有令牌的任务的优先级会暂时提高到阻塞任务的优先级。这项机制 旨在确保较高优先级的任务保持阻塞状态的时间尽可能短， 从而最大限度减少已经发生的“优先级反转”现象。

优先级继承无法解决优先级反转！只是在某些情况下将影响降至最低。  硬实时应用程序的设计应从一开始就避免发生优先级反转。

不能从中断中使用互斥锁的原因是：

-   互斥锁使用的优先级继承机制要求 从任务中（而不是从中断中）拿走和放入互斥锁。
-   中断无法保持阻塞来等待一个被互斥锁保护的资源 变为可用。

### 简化优先级继承

FreeRTOS 实现了基本的优先级继承机制，旨在优化 空间和执行周期。完全的优先级继承机制需要多得多的数据和处理器 周期来确定任何时刻的继承优先级，特别是在任务同时占用超过一个互斥锁时 。

请牢记优先级继承机制的这些特定行为：

-   如果一个任务在占用一个互斥锁时没有先释放它已占用的互斥锁， 则可以进一步提升其继承优先级。
-   任务在释放其占有的所有互斥锁之前，一直保持最高继承优先级。 这与释放互斥锁的顺序无关。
-   如果多个互斥锁被占用，无论在任何一个被占用的互斥锁上等待的任务是否完成等待（超时）， 则任务将保持最高继承优先级 。





## 目的

确保在任何时刻，只有一个任务可以访问某个特定的共享资源或临界区代码。



## 特点

一种特殊类型的二值信号量，专门用于实现**互斥访问**共享资源。核心区别在于它实现了**优先级继承**机制。



## 行为

*   创建时初始化为 1（可用）。
*   `xSemaphoreTake()`：尝试获取互斥量所有权。
    *   如果可用（1），则获取成功，拥有者设置为当前任务，值变为 0。
    *   如果已被其他任务占用（0），则当前任务阻塞。
*   `xSemaphoreGive()`：**必须由拥有互斥量的任务调用**来释放它。拥有权被释放，值变为 1。如果之前发生了优先级继承，拥有者任务的优先级会恢复。



## 核心特点：**优先级继承**

*   **案例**：假设低优先级任务A持有互斥量（钥匙）。高优先级任务B需要该互斥量，只能阻塞等待。

    此时，如果中优先级任务C（优先级高于A但低于B）就绪运行，它会抢占A。

    结果就是：高优先级的B被中优先级的C间接阻塞了，而持有钥匙的A无法运行（被C抢占），导致B长时间无法运行——这就是优先级反转，破坏了实时性。

*   **解决机制：** FreeRTOS的互斥量实现了**优先级继承**。当高优先级任务B因等待A持有的互斥量而阻塞时，系统会**临时提升任务A的优先级**到与B相同（或略高）。这样：

    - A能尽快被调度执行（因为它现在优先级很高）。
    - A尽快完成临界区操作。
    - A释放互斥量后，其优先级恢复原状。
    - B立刻获取互斥量并执行。

*   这**显著减少了**高优先级任务被阻塞的时间，缓解了优先级反转问题。**这是互斥量与普通二值信号量最关键的区别！** 二值信号量没有此机制。



## 主要用途

*   **保护共享资源：** 确保在任何时刻，最多只有一个任务访问临界区（共享资源）。这是互斥量的核心目的。
*   **防止优先级反转：** 通过优先级继承机制，减少高优先级任务因等待低优先级任务持有的互斥量而被无限期阻塞的风险。