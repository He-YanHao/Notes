# 递归互斥量 (Recursive Mutex)

## 官方介绍

用户可对一把递归互斥锁重复加锁。只有用户 为每个成功的 xSemaphoreTakeRecursive() 请求调用 xSemaphoreGiveRecursive() 后，互斥锁才会重新变为可用。例如，如果一个任务成功“加锁”相同的互斥锁 5 次， 那么任何其他任务都无法使用此互斥锁，直到任务也把这个互斥锁“解锁”5 次。

这种类型的信号量使用优先级继承机制，因此“加锁”一个信号量的任务必须在不需要此信号量时， 立即将信号量“解锁”。

不能从中断服务程序中使用类型是互斥锁的信号量。

不能从中断中使用互斥锁的原因是：

-   互斥锁使用的优先级继承机制要求 从任务中（而不是从中断中）拿走和放入互斥锁。
-   中断无法保持阻塞来等待一个被互斥锁保护的资源 变得可用。



## 特点

是互斥量的一种变体，允许**同一个任务多次（递归地）获取**它持有的互斥量。任务必须释放它**同样次数**才能让其他任务获取。



## 行为

*   创建方式类似互斥量。
*   同一个任务可以多次调用 `xSemaphoreTake()` 成功获取同一个递归互斥量（内部计数递增）。
*   任务必须调用 `xSemaphoreGive()` **相同次数**才能将内部计数减到 0 并真正释放互斥量。
*   也支持优先级继承。



## 主要用途

*   保护可能被同一个任务从不同层级（如主函数调用了一个子函数，该子函数又调用了另一个子函数）访问的共享资源，而这些层级都需要访问同一个资源。
*   避免同一个任务在已经持有锁的情况下尝试再次获取同一个锁时发生死锁。