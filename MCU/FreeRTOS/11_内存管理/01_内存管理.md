# FreeRTOS内存管理

## 基础介绍

FreeRTOS 的内存管理是其核心功能之一，直接关系到系统的实时性、可靠性和资源利用率。它采用了一套独特且灵活的设计，不直接使用标准库（如 `malloc()` 和 `free()`），而是由开发者提供或选择一种内置的内存分配方案。



## 关键概念

### **堆 Heap**

*   FreeRTOS 管理的动态内存区域称为 `heap` (堆)。
*   这个堆实际上就是一个（或几个，取决于方案）大的、连续的字节数组，由 FreeRTOS 的内存管理方案来划分和管理。
*   堆的总大小在 `FreeRTOSConfig.h` 中通过 `configTOTAL_HEAP_SIZE` 宏定义。**这是你需要根据应用程序需求仔细调整的关键配置！**

**内存分配函数 (`pvPortMalloc()`):**

*   这是 FreeRTOS 提供的用于动态分配内存的函数，功能类似于标准库的 `malloc()`。
*   它接受一个参数：请求分配的字节数 `size`。
*   它返回一个指向分配到的内存块的 `void` 指针。如果分配失败（内存不足），则返回 `NULL`。
*   **关键点：** `pvPortMalloc()` 的实现取决于你选择（或提供）的 `heap_x.c` 文件。

**内存释放函数 (`vPortFree()`):**

*   这是 FreeRTOS 提供的用于释放之前由 `pvPortMalloc()` 分配的内存块的函数，功能类似于标准库的 `free()`。
*   它接受一个参数：指向要释放的内存块的指针 `pv`。
*   **关键点：** 并非所有 FreeRTOS 内置的内存管理方案都支持 `vPortFree()`！`vPortFree()` 的实现同样取决于 `heap_x.c`。



## 内存管理方案 (`heap_x.c`)

FreeRTOS 源码中提供了 5 种（有时是 4 种，取决于版本）开箱即用的内存管理实现，位于 `FreeRTOS/Source/portable/MemMang` 目录下。

简要介绍

| 内存方案 | 特点                             | 适用场景                                       |
| -------- | -------------------------------- | ---------------------------------------------- |
| heap_1   | 只分配不释放，无碎片             | 任务和内核对象在系统运行前已创建完毕的简单应用 |
| heap_2   | 使用首次适应算法，支持分配和释放 | 内存分配模式相对简单、内存使用周期较短的场景   |
| heap_3   | 封装标准库malloc/free            | 需要与标准C代码集成的快速原型开发              |
| heap_4   | 使用最佳匹配算法，合并相邻空闲块 | 大多数嵌入式应用的推荐选择，平衡了性能和碎片   |
| heap_5   | 支持多个不连续的内存区域         | 需要管理多个内存区域或非连续内存时的首选       |

需要**选择其中一个源文件**编译到项目中。每种方案在复杂性、速度、碎片控制、确定性等方面有不同的权衡：

1.  **`heap_1.c` - 最简单的方案 (仅分配，不支持释放)**
    *   **原理：** 将一个大数组（堆）从头开始顺序分配。每次 `pvPortMalloc()` 调用都简单地返回堆中下一个空闲字节的指针。
    *   **优点:**
        *   实现极其简单。
        *   分配时间是确定性的（常数时间）。
        *   没有内存碎片问题（因为不释放）。
    *   **缺点:**
        *   **不支持 `vPortFree()`！** 一旦分配，内存就不能被回收。这在很多需要动态创建/删除任务、队列等的应用中是不可接受的。
    *   **适用场景：** 应用程序在启动时一次性分配好所有所需内存，之后永不释放。或者对安全性要求极高，不允许运行时释放内存的场景。

2.  **`heap_2.c` - 支持分配与释放 (已过时，不推荐使用)**
    *   **原理：** 使用**最佳匹配 (Best Fit)** 算法。维护一个空闲内存块链表。分配时，遍历链表找到能满足请求大小的**最小空闲块**进行分配。释放时，将释放的块重新插入空闲链表，并尝试与相邻的空闲块**向前合并**。
    *   **优点:**
        *   支持分配和释放。
        *   相对简单。
    *   **缺点:**
        *   **容易产生碎片：** 只进行向前合并（与下一个空闲块合并），不能向后合并（与前一个空闲块合并），导致内存碎片问题比 `heap_4` 严重。
        *   **分配时间不确定：** 需要遍历链表寻找最佳匹配块，最坏情况时间与空闲块数量成正比。
        *   **容易导致碎片化：** 频繁分配释放大量小对象会留下很多无法利用的小间隙。
        *   **过时：** FreeRTOS 官方文档已明确说明 `heap_2` 存在缺陷，**强烈建议使用 `heap_4` 替代**。
    *   **适用场景：** 基本不再推荐使用新项目。了解其原理有助于理解更先进的方案。

3.  **`heap_3.c` - 封装标准库 `malloc/free`**
    *   **原理：** 简单地使用编译器提供的标准库 `malloc()` 和 `free()` 函数。通过 `malloc()` 获取堆空间（替代 `configTOTAL_HEAP_SIZE` 定义的数组），然后调用 `pvPortMalloc()`/`vPortFree()` 时直接转发给 `malloc()`/`free()`。
    *   **优点:**
        *   实现最简单（几乎不用自己写代码）。
        *   可以利用编译器库可能提供的某些高级特性（如线程安全）。
    *   **缺点:**
        *   **破坏实时性/确定性：** 标准库的 `malloc()`/`free()` 通常执行时间不确定。
        *   **可能增大代码体积：** 链接了整个标准库的内存管理代码。
        *   **碎片问题：** 继承了标准库实现的碎片问题。
        *   **移植性问题：** 依赖于特定编译器的库实现。
    *   **适用场景：** 对实时性要求不高、且平台的标准库 `malloc/free` 足够可靠和高效的非关键应用；快速原型验证。

4.  **`heap_4.c` - 推荐方案 (分配/释放 + 相邻块合并)**
    *   **原理：** 使用 **首次匹配 (First Fit)** 算法。维护一个按内存地址排序的空闲内存块链表。分配时，从链表头开始遍历，找到**第一个**能满足请求大小的空闲块进行分配。释放时，将释放的块插入空闲链表（保持地址有序），并立即**向前和向后检查相邻块**，如果相邻块也是空闲的，则**将它们合并成一个更大的空闲块**。
    *   **优点:**
        *   **支持分配和释放。**
        *   **显著减少碎片：** 双向合并能有效地将小空闲块合并成大块，大大缓解碎片问题。
        *   **相对高效：** 首次匹配通常比最佳匹配快（虽然最坏情况也要遍历链表，但实践中表现良好）。
        *   **可预测性较好：** 分配和释放的时间虽然不绝对恒定，但通常在一个可接受的范围内。
        *   **广泛使用和验证：** 是 FreeRTOS 社区最常用和推荐的内置方案。
    *   **缺点:**
        *   实现比 `heap_1` 和 `heap_3` 复杂。
        *   分配/释放时间不是严格确定的（取决于链表状态）。
    *   **适用场景：** **绝大多数需要动态内存分配和释放的 FreeRTOS 项目。** 是平衡了功能、性能和碎片控制的**最佳通用选择**。

5.  **`heap_5.c` - 高级方案 (支持非连续内存区域)**
    *   **原理：** 在 `heap_4` 算法的基础上，增加了一个关键功能：**支持将多个物理上不连续的内存区域组合成一个逻辑上的堆**。你需要通过 `vPortDefineHeapRegions()` 函数显式地初始化这些区域（描述每个区域的起始地址和大小）。
    *   **优点:**
        *   继承 `heap_4` 的所有优点（分配/释放、合并减少碎片）。
        *   **解决了物理内存碎片问题：** 可以充分利用 MCU 上分散的 RAM 块（例如内部 SRAM + 外部 SDRAM 各一部分，或者不同地址段的 SRAM）。
    *   **缺点:**
        *   使用和配置稍复杂（需要定义内存区域）。
        *   分配算法在跨越不同区域时可能略慢于 `heap_4`（但通常影响不大）。
    *   **适用场景：** 当系统的可用 RAM 物理上分布在多个不连续的地址区域时（这在复杂的 MCU 或 SoC 上很常见）。例如，同时使用芯片内部的 SRAM 和外扩的 PSRAM/SDRAM。



## 选择哪种方案？

*   **`heap_1`:** 仅适用于**永不释放内存**的简单应用或安全苛求应用。
*   **`heap_2`:** **不推荐使用**。有已知缺陷，优先选 `heap_4`。
*   **`heap_3`:** 仅适用于**对实时性要求极低**、且信任标准库 `malloc/free` 的非关键应用或快速原型。
*   **`heap_4`:** **强烈推荐作为默认选择**。适用于绝大多数需要动态创建/删除内核对象（任务、队列、信号量、定时器等）和应用程序数据结构的项目。它提供了良好的碎片控制和可接受的性能。
*   **`heap_5`:** 当你的目标硬件有**多块物理地址不连续的 RAM** 需要合并使用时选用。



## 重要配置和注意事项

1.  **`configTOTAL_HEAP_SIZE`:** 在 `FreeRTOSConfig.h` 中定义。这是你分配给 FreeRTOS 堆的**总字节数**。务必根据你的应用需求（创建的任务、队列等对象的大小和数量）精确计算并留有余量。太小会导致分配失败（返回 `NULL`），太大则浪费宝贵的 RAM。可以使用 `xPortGetFreeHeapSize()` 或 `xPortGetMinimumEverFreeHeapSize()` 函数在运行时监控堆使用情况，辅助调整此值。
2.  **内存对齐 (Alignment):** `pvPortMalloc()` 返回的内存块保证满足架构要求的内存对齐（通常是 8 字节对齐）。这在访问某些数据类型（如 `double`, 结构体）或 DMA 传输时很重要。如果需要更严格的对齐（例如 16 字节），可能需要自定义分配方案或调整底层实现。
3.  **栈溢出检测：** FreeRTOS 提供了任务栈溢出检测机制 (`configCHECK_FOR_STACK_OVERFLOW`)。但这检测的是**任务栈**是否溢出。`pvPortMalloc()` 分配失败（返回 `NULL`）是**堆**空间不足的信号，两者不同！应用程序必须检查 `pvPortMalloc()` 的返回值是否为 `NULL` 并进行错误处理。
4.  **临界区保护：** 所有内置的 `heap_x.c` 方案在访问堆数据结构（如空闲链表）时，都会使用 FreeRTOS 的调度器锁或中断屏蔽机制进入临界区，以保证线程安全（在中断服务例程 ISR 中调用分配/释放函数是安全的，但需使用带 `FromISR` 后缀的版本）。
5.  **自定义方案：** 如果内置方案都不能完全满足你的需求（例如需要严格的时间确定性、特定的碎片控制策略、或集成特殊硬件的内存池），你可以完全自己实现 `pvPortMalloc()` 和 `vPortFree()` 函数（通常基于 `heap_4` 或 `heap_5` 修改）。你需要提供一个符合 FreeRTOS 内存管理接口的实现。



## 栈回收

在 FreeRTOS 中，当一个任务删除**自身**时（通过调用 `vTaskDelete(NULL)`），**其任务栈会被回收（释放）**，但这个过程**不是立即发生**的，而是由**空闲任务（Idle Task）** 负责完成的。

以下是详细的解释：

1.  **删除操作的机制：**
    *   当一个任务（任务 A）调用 `vTaskDelete(NULL)` 删除自身时，它实际上是将自己标记为“待删除”。
    *   任务 A 会立即退出执行状态（它不会再被调度器选中运行）。
    *   **但是，任务 A 的代码此时仍然在执行删除自身的函数调用中！这意味着任务 A 的栈在调用 `vTaskDelete(NULL)` 期间仍然在使用中。**
    *   立即释放一个正在使用的栈会导致灾难性的后果（内存被释放但内核还在用它）。

2.  **空闲任务的职责：**
    *   FreeRTOS 内核总是有一个最低优先级的“空闲任务”（Idle Task），它在没有其他任务运行时执行。
    *   空闲任务有一个非常重要的职责：**清理（回收）那些已被删除任务的资源**。
    *   当一个任务被删除（无论是被其他任务删除还是被自身删除），内核会将被删除任务的 **任务控制块（Task Control Block - TCB）** 添加到一个“待删除任务”列表（或类似结构）中。

3.  **栈的回收时机：**
    *   空闲任务在其运行循环中，会检查这个“待删除任务”列表。
    *   **当空闲任务发现列表中有任务需要清理时，它就会：**
        *   释放该任务的 **任务控制块（TCB）** 所占用的内存。
        *   释放该任务的 **栈空间** 所占用的内存。
    *   因为任务 A 删除自身后，其栈已不再被任何执行流使用（任务 A 已终止），所以空闲任务可以安全地释放这块内存。

4.  **关键点：**
    *   **会回收：** 任务删除自身后，其栈内存**最终会被回收**。
    *   **延迟回收：** 回收操作**不是立即**发生在 `vTaskDelete(NULL)` 调用的那一刻，而是**稍后由空闲任务执行**。
    *   **依赖空闲任务：** 这意味着你的应用程序**必须**给空闲任务运行的机会（即系统中有空闲时间），栈内存才能被回收。如果高优先级任务一直占据 CPU，导致空闲任务无法运行，那么被删除任务的资源（包括栈）就会一直无法释放，造成内存泄漏。
    *   **动态分配 vs 静态分配：** 上述回收过程适用于使用 `xTaskCreate()` 动态创建的任务（TCB 和栈内存由 FreeRTOS 从堆中分配）。如果任务是使用 `xTaskCreateStatic()` 静态创建的（TCB 和栈内存由用户预先分配），那么内核**不会**尝试释放这些内存（它们由用户管理）。用户需要自己决定何时重用或释放这些静态分配的内存区域。



## 总结

在 FreeRTOS 中，任务删除自身后，其栈内存**会被回收**。回收操作由**空闲任务**在稍后的某个时间点执行，前提是空闲任务有机会运行（系统存在空闲时间）。这是 FreeRTOS 管理动态分配资源（任务栈和 TCB）的标准机制。对于静态分配的任务，内存回收由用户负责。