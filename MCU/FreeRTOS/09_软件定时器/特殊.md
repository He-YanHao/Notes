

## å®šæ—¶å™¨ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```c
// å®šæ—¶å™¨æ§åˆ¶å—ç»“æ„ï¼ˆç®€åŒ–ï¼‰
typedef struct tmrTimerControl {
    const char *pcTimerName;          // å®šæ—¶å™¨åç§°
    ListItem_t xTimerListItem;        // å®šæ—¶å™¨é“¾è¡¨é¡¹
    TickType_t xTimerPeriodInTicks;   // å®šæ—¶å‘¨æœŸï¼ˆèŠ‚æ‹æ•°ï¼‰
    UBaseType_t uxAutoReload;         // è‡ªåŠ¨é‡è½½æ ‡å¿—
    TimerCallbackFunction_t pxCallbackFunction; // å›è°ƒå‡½æ•°
    void *pvTimerID;                  // å®šæ—¶å™¨ID
} xTIMER;
```

### ç³»ç»Ÿç»„æˆ

1. **å®šæ—¶å™¨æœåŠ¡ä»»åŠ¡** - ä¸“é—¨å¤„ç†å®šæ—¶å™¨çš„ä»»åŠ¡
2. **å®šæ—¶å™¨å‘½ä»¤é˜Ÿåˆ—** - ç”¨äºå‘æœåŠ¡ä»»åŠ¡å‘é€å‘½ä»¤
3. **å®šæ—¶å™¨é“¾è¡¨** - æŒ‰åˆ°æœŸæ—¶é—´æ’åºçš„å®šæ—¶å™¨åˆ—è¡¨

## âš™ï¸ å·¥ä½œåŸç†

### 1. å®šæ—¶å™¨æœåŠ¡ä»»åŠ¡

```c
// å®šæ—¶å™¨æœåŠ¡ä»»åŠ¡çš„ä¸»å¾ªç¯
void prvTimerTask( void *pvParameters )
{
    TickType_t xNextExpireTime;
    BaseType_t xListWasEmpty;
    
    for( ;; ) {
        // è·å–ä¸‹ä¸€ä¸ªå®šæ—¶å™¨çš„åˆ°æœŸæ—¶é—´
        xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
        
        // å¤„ç†å®šæ—¶å™¨åˆ°æœŸäº‹ä»¶
        prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
        
        // å¤„ç†å®šæ—¶å™¨å‘½ä»¤é˜Ÿåˆ—
        prvProcessReceivedCommands();
    }
}
```

### 2. å®šæ—¶å™¨çŠ¶æ€ç®¡ç†

```mermaid
stateDiagram-v2
    [*] --> ä¼‘çœ æ€ : xTimerCreate()
    ä¼‘çœ æ€ --> è¿è¡Œæ€ : xTimerStart()
    è¿è¡Œæ€ --> ä¼‘çœ æ€ : xTimerStop()
    è¿è¡Œæ€ --> åˆ°æœŸæ€ : æ—¶é—´åˆ°è¾¾
    åˆ°æœŸæ€ --> è¿è¡Œæ€ : uxAutoReload = pdTRUE
    åˆ°æœŸæ€ --> ä¼‘çœ æ€ : uxAutoReload = pdFALSE
    è¿è¡Œæ€ --> è¿è¡Œæ€ : xTimerReset()
```

## ğŸ”§ æ ¸å¿ƒ API å‡½æ•°

### 1. åˆ›å»ºå®šæ—¶å™¨

```c
TimerHandle_t xTimerCreate( const char * const pcTimerName,
                           const TickType_t xTimerPeriodInTicks,
                           const UBaseType_t uxAutoReload,
                           void * const pvTimerID,
                           TimerCallbackFunction_t pxCallbackFunction );
```

**å‚æ•°è¯´æ˜ï¼š**

- `pcTimerName` - å®šæ—¶å™¨åç§°ï¼ˆè°ƒè¯•ç”¨ï¼‰
- `xTimerPeriodInTicks` - å®šæ—¶å‘¨æœŸï¼ˆç³»ç»ŸèŠ‚æ‹æ•°ï¼‰
- `uxAutoReload` - è‡ªåŠ¨é‡è½½ï¼ˆpdTRUE-å‘¨æœŸï¼ŒpdFALSE-å•æ¬¡ï¼‰
- `pvTimerID` - å®šæ—¶å™¨æ ‡è¯†ç¬¦
- `pxCallbackFunction` - å›è°ƒå‡½æ•°

### 2. å¯åŠ¨å®šæ—¶å™¨

```c
// åœ¨ä»»åŠ¡ä¸­å¯åŠ¨
BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );

// åœ¨ä¸­æ–­ä¸­å¯åŠ¨
BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, 
                              BaseType_t *pxHigherPriorityTaskWoken );
```

### 3. å…¶ä»–æ“ä½œå‡½æ•°

```c
// åœæ­¢å®šæ—¶å™¨
BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );

// é‡ç½®å®šæ—¶å™¨ï¼ˆé‡æ–°å¼€å§‹è®¡æ—¶ï¼‰
BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );

// æ”¹å˜å®šæ—¶å‘¨æœŸ
BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, 
                              TickType_t xNewPeriod, 
                              TickType_t xTicksToWait );
```

## ğŸ“‹ é…ç½®è¦æ±‚

åœ¨ `FreeRTOSConfig.h` ä¸­å¿…é¡»é…ç½®ï¼š

```c
#define configUSE_TIMERS                 1   // å¯ç”¨å®šæ—¶å™¨åŠŸèƒ½
#define configTIMER_TASK_PRIORITY        ( configMAX_PRIORITIES - 1 )  // æœåŠ¡ä»»åŠ¡ä¼˜å…ˆçº§
#define configTIMER_QUEUE_LENGTH         10  // å®šæ—¶å™¨å‘½ä»¤é˜Ÿåˆ—é•¿åº¦
#define configTIMER_TASK_STACK_DEPTH     ( configMINIMAL_STACK_SIZE * 2 )  // ä»»åŠ¡å †æ ˆ
```

## ğŸ’» ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬å®šæ—¶å™¨ä½¿ç”¨

```c
// å®šæ—¶å™¨å›è°ƒå‡½æ•°
void vTimerCallback( TimerHandle_t xTimer )
{
    static uint32_t ulExecutionCount = 0;
    ulExecutionCount++;
    
    // è·å–å®šæ—¶å™¨ID
    uint32_t *pulTimerID = ( uint32_t * ) pvTimerGetTimerID( xTimer );
    
    printf("Timer %ld callback executed %lu times\n", *pulTimerID, ulExecutionCount);
}

// åˆ›å»ºå’Œå¯åŠ¨å®šæ—¶å™¨
void setup_timers(void)
{
    TimerHandle_t xAutoReloadTimer, xOneShotTimer;
    uint32_t ulAutoReloadTimerID = 1, ulOneShotTimerID = 2;
    
    // åˆ›å»ºè‡ªåŠ¨é‡è½½å®šæ—¶å™¨ï¼ˆå‘¨æœŸ500msï¼‰
    xAutoReloadTimer = xTimerCreate(
        "AutoReloadTimer",
        pdMS_TO_TICKS(500),    // 500ms
        pdTRUE,                // è‡ªåŠ¨é‡è½½
        (void *)&ulAutoReloadTimerID,
        vTimerCallback
    );
    
    // åˆ›å»ºå•æ¬¡å®šæ—¶å™¨
    xOneShotTimer = xTimerCreate(
        "OneShotTimer",
        pdMS_TO_TICKS(1000),   // 1000ms
        pdFALSE,               // å•æ¬¡
        (void *)&ulOneShotTimerID,
        vTimerCallback
    );
    
    // å¯åŠ¨å®šæ—¶å™¨
    if (xAutoReloadTimer != NULL) {
        xTimerStart(xAutoReloadTimer, 0);
    }
    if (xOneShotTimer != NULL) {
        xTimerStart(xOneShotTimer, 0);
    }
}
```

## âš ï¸ é‡è¦æ³¨æ„äº‹é¡¹

### 1. å›è°ƒå‡½æ•°é™åˆ¶

```c
void vTimerCallback( TimerHandle_t xTimer )
{
    // âœ… å…è®¸çš„æ“ä½œï¼š
    // - å‘é€ä¿¡å·é‡/æ¶ˆæ¯é˜Ÿåˆ—
    // - ä¿®æ”¹å…¨å±€å˜é‡
    // - è®¾ç½®äº‹ä»¶æ ‡å¿—
    
    // âŒ ç¦æ­¢çš„æ“ä½œï¼š
    // - vTaskDelay() ç­‰é˜»å¡è°ƒç”¨
    // - å¯èƒ½å¼•èµ·ä»»åŠ¡åˆ‡æ¢çš„API
    // - é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œ
}
```

### 2. æ€§èƒ½ç‰¹æ€§

| ç‰¹æ€§         | è¯´æ˜                                         |
| ------------ | -------------------------------------------- |
| **ç²¾åº¦**     | ä¾èµ–äºç³»ç»ŸèŠ‚æ‹é¢‘ç‡ï¼Œé€šå¸¸ä¸º1msçš„æ•´æ•°å€        |
| **å¼€é”€**     | éœ€è¦é¢å¤–çš„RAMå’ŒCPUèµ„æºï¼ˆæœåŠ¡ä»»åŠ¡ï¼‰           |
| **å®æ—¶æ€§**   | å›è°ƒå‡½æ•°åœ¨å®šæ—¶å™¨æœåŠ¡ä»»åŠ¡ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œï¼Œéå®æ—¶ |
| **æ•°é‡é™åˆ¶** | ç†è®ºä¸Šæ— é™åˆ¶ï¼Œå®é™…å—å†…å­˜é™åˆ¶                 |

### 3. æœ€ä½³å®è·µ

```c
// åœ¨ä¸­æ–­æœåŠ¡ç¨‹åºä¸­ä½¿ç”¨å®šæ—¶å™¨
void vAnInterruptServiceRoutine( void )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // ä»ISRä¸­å¯åŠ¨/åœæ­¢/é‡ç½®å®šæ—¶å™¨
    xTimerStartFromISR( xTimer, &xHigherPriorityTaskWoken );
    
    // å¦‚æœéœ€è¦ï¼Œè¿›è¡Œä»»åŠ¡åˆ‡æ¢
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

FreeRTOS å®šæ—¶å™¨æä¾›äº†ä¸€ç§çµæ´»çš„æ—¶é—´ç®¡ç†æœºåˆ¶ï¼Œç‰¹åˆ«é€‚åˆéœ€è¦å‘¨æœŸæ€§æ‰§è¡Œæˆ–å»¶è¿Ÿæ‰§è¡Œçš„åº”ç”¨åœºæ™¯ï¼Œä½†éœ€è¦æ³¨æ„å…¶æ‰§è¡Œä¸Šä¸‹æ–‡å’Œèµ„æºæ¶ˆè€—ã€‚

