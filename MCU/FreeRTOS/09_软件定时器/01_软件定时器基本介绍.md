# 软件定时器基本介绍

## 核心概念

FreeRTOS 的软件定时器是一种**由内核调度器管理的、基于系统节拍时钟（tick）** 的计时机制。可以在未来的某个时间点（或周期性间隔）执行一个预先定义好的回调函数（Timer Callback Function）。



## 软件实现

*   与硬件定时器（依赖 MCU 的物理计时器外设）不同，软件定时器完全由 FreeRTOS 内核在软件中实现。
*   它利用系统节拍中断（`configTICK_RATE_HZ` 定义）作为其时间基准。这意味着定时器的分辨率（最小时间间隔）等于一个系统节拍的时长（例如，如果 `configTICK_RATE_HZ = 1000`，则分辨率是 1ms）。
*   精度受限于系统节拍中断的抖动和任务调度延迟。对于需要极高精度的操作（如精确 PWM 生成），硬件定时器仍是首选。



## 守护任务（Daemon Task / Timer Service Task）

*   软件定时器的管理（创建、启动、停止、重置、处理到期）是由一个专门的 FreeRTOS 任务完成的，称为**定时器服务任务**或**守护任务**。
*   当在 `FreeRTOSConfig.h` 中设置 `configUSE_TIMERS = 1` 时，内核会在启动调度器 (`vTaskStartScheduler()`) 时自动创建这个守护任务。
*   守护任务的优先级由 `configTIMER_TASK_PRIORITY` 定义。**这个优先级设置非常重要：**
    *   如果太低，守护任务可能无法及时处理到期的定时器回调，导致回调执行延迟。
    *   如果太高，它可能会抢占很多其他重要任务。
    *   回调函数在守护任务的上下文中执行。

3.  **命令队列：**
    *   当调用软件定时器 API（如 `xTimerStart()`, `xTimerStop()`）时，这些 API 函数实际上是将一个“命令”（例如“启动定时器X”）发送到一个队列中。
    *   守护任务不断地从这个队列中接收命令并执行相应的操作（启动、停止、处理到期等）。
    *   这种设计使得操作定时器是**线程安全**的，可以在任务中安全地操作定时器，甚至可以在中断服务程序（ISR）中使用带 `FromISR` 后缀的特殊 API（如 `xTimerStartFromISR()`）来操作定时器。

4.  **定时器类型：**
    *   **单次定时器：** 启动后，只会在设定的时间到期时执行一次回调函数，然后自动进入休眠状态。需要显式重新启动才能再次触发。
    *   **自动重载定时器：** 启动后，会在设定的周期时间到期时执行回调函数，**并自动重置定时器**，准备下一个周期的计时。它会持续周期性地触发，直到被显式停止。

5.  **回调函数：**
    *   这是定时器到期时实际要执行的代码。
    *   回调函数必须具有特定的原型：`void ATimerCallback(TimerHandle_t xTimer);`
    *   **关键约束：** 回调函数在**守护任务的上下文**中执行。因此：
        *   它**不能**调用任何会导致阻塞的 API（如 `vTaskDelay()`, `xQueueReceive()` 带阻塞时间等）。
        *   它应该尽可能**短小精悍**，避免长时间运行。如果需要在定时器事件中执行复杂或耗时的操作，最好的做法是在回调函数中简单地发送一个事件、设置一个信号量或发布一个消息给一个专门处理这些事件的任务，由该任务去执行耗时操作。

## 定时器类型

定时器有两种类型，一次性定时器和自动重载定时器。

一次性定时器启动后只会执行一次回调函数。它可以手动重新启动，但不会自动重新启动。

与一次性定时器相反， 自动重载定时器一旦启动，将在每次执行调用回调函数后，自动重新启动， 从而周期性地执行回调。



## 工作原理




