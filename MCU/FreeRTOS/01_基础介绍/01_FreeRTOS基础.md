# FreeRTOS基础

## 基本介绍

实时操作系统（RTOS-Real Time Operating System）中实时（Real Time）指的是任务（Task）或者说实现一个功能的线程（Thread）必须在给定的时间(Deadline)内完成。

FreeRTOS 这个名字，可以分为两部分：“Free”和“RTOS”

- “Free”就是免费的、 自由的、不受约束的意思。

- “RTOS”全称是 Real Time Operating System，中文名就是实时操作系统。

  > RTOS 并不是值某一特定的操作系统，而是指一类操作系统，例如，µC/OS， FreeRTOS，RTX，RT-Thread 等这些都是 RTOS 类的操作系统。

因此，FreeROTS 是一款免费的实时操作系统。

## 系统分类

操作系统从整体上分为两大类:**通用操作系统**和**实时操作系统**。

一个计算机系统可以大致分为三个部分：硬件（Hardware），操作系统（operating system），应用程序（application programs）。

1. 硬件包含了芯片，存储空间，输入输出等设备为整个系统提供了基础的计算资源。
2. 操作系统是一个控制程序，作为硬件和应用程序之间的桥梁，主要是和硬件打交道，负责协调分配计算资源和内存资源给不同的应用程序使用，并防止系统出现故障。面对来自不同应用程序的大量且互相竞争的资源请求，操作系统通过一个调度算法和内存管理算法尽可能把资源公平且有效率地分配给不同的程序。
3. 应用程序则通过调用操作系统提供的API接口获得相应资源完成指定的任务。

### 裸机系统

裸机系统通常分成轮询系统和前后台系统

#### 轮询系统

轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断循环，顺序地做各种事情。

#### 前后台系统

相比轮询系统，前后台系统是在轮询系统的基础上加入了中断。

外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台，main 函数里面的无限循环我们称为后台。

**前台：**

中断服务程序接收异步中断，来通知后台，后台收到中断请求后进行处理。

```
void XXX_ISR(void)
{
  Clear interrupt;
  Read data;
}
```

**后台：**

应用程序通常是一个无限的循环，在循环中，通过调用相应的处理函数，完成相应的操作，这部分可以看做为后台行为。

```
void main(void)
{
  init();
  while(1) 
  {
  Task1();
  Task2();
  Task3();
  Task4();
  ····
  }
}
```
### 多任务系统

一个处理器核心在某一时刻只能运行一个任务，如在各个任务之间迅速切换，这样看起来就像多个任务在同时运行。操作系统中任务调度器的责任就是决定在某一时刻要执行哪个任务。

在多任务系统中，每个任务都是独立的，任务跟中断一样，也具有优先级，优先级高的任务会被优先执行。

相比前后台系统，多任务系统的**事件响应也是在中断中完成**的，但是**事件的处理是在任务中完成**的。

在多任务系统中，根据程序的功能，我们把这个程序主体分割成一个个**独立的**，**无限循环**且**不能返回**的小程序，这个小程序我们称之为任务。每个任务都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。

```c
int flag1 = 0;//标志位1
int flag2 = 0;//标志位2
int flag3 = 0;//标志位3

int main(void)//主函数
{
    HardWareInit();//硬件相关初始化
	RTOSInit();//OS初始化
	RTOSStart();//OS启动，开始多任务调度，不再返回。
}

void ISR1(void)//中断标志位1
{
	flag1 = 1;//置位标志位
}
void ISR2(void)//中断标志位2
{
	flag2 = 2;//置位标志位
}
void ISR3(void)//中断标志位3
{
	flag3 = 1;//置位标志位
}

void DoSomething1(void)//任务1
{
	while(1)//无限循环，且永不返回。
	{
		if (flag1)//任务实体
		{
		......
		}
	}
}
void DoSomething2(void)//任务2
{
	while(1)//无限循环，且永不返回。
	{
		if (flag2)//任务实体
		{
		......
		}
	}
}
void DoSomething3(void)//任务3
{
	while(1)//无限循环，且永不返回。
	{
		if (flag3)//任务实体
		{
		......
        }
	}
}
```

## 调度策略

FreeRTOS 默认使用**固定优先级**的**抢占式调度策略**，对**同等优先级**的任务执行**时间片轮询**调度：

- 抢占式调度：FreeRTOS采用抢占式调度方式，允许更高优先级的任务在任何时刻抢占正在执行的低优先级任务。这确保了高优先级任务能够及时响应，并提高了系统的实时性。

- 时间片轮询：在相同优先级的任务之间，FreeRTOS采用时间片轮转策略。每个任务执行一个时间片，如果有其他同优先级的任务等待执行，则切换到下一个任务。这有助于公平地分配CPU时间。

但是并不是说高优先级的任务会一直执行，导致低优先级的任务无法得到执行。如果高优先级任务**等待某个资源（延时或等待信号量等）**而无法执行，调度器会选择执行其他就绪的高优先级的任务。

## 任务状态

FreeRTOS中任务共存在4种状态：

- 运行态：当任务实际执行时，它被称为处于运行状态。如果运行 RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。注意在STM32中，同一时间仅一个任务处于运行态。
- 就绪态：准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态）， 但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。
-  就绪列表：pxReadyTasksLists[x]，其中x代表任务优先级数值。  
- 阻塞态：如果任务当前正在等待延时或外部事件，则该任务被认为处于阻塞状态。
  -  阻塞列表：pxDelayedTaskList。  
- 挂起态：类似暂停，调用函数 vTaskSuspend() 进入挂起态，需要调用解挂函数vTaskResume()才可以进入就绪态。
  - 挂起列表：xSuspendedTaskList。

只有就绪态可转变成运行态，其他状态的任务想运行，必须先转变成就绪态。 



## 上下文

当一个任务执行时，它会利用处理器/微控制器寄存器，并像其他程序一样访问 RAM  和 ROM。这些资源（处理器寄存器，堆栈等）一起组成了任务执行上下文。 

保存被挂起的任务的上下文和恢复被恢复的任务的上下文的过程被称为上下文切换。 



## 空闲任务

RTOS 调度器启动时，自动创建空闲任务，以确保始终存在一个能够运行的任务。

空闲以最低优先级创建，以确保如果有更高的优先级应用程序任务处于准备就绪状态， 空闲任务则不使用任何 CPU 时间。

空闲任务负责释放被删除的任务的内存。