

### 三种主要的启动模式

STM32通过BOOT0和BOOT1引脚的电平组合，决定在芯片上电或复位时，将哪块存储器映射到0x00000000：

| BOOT1 | BOOT0 | 启动模式       | 映射到0x00000000的存储器             |
| :---- | :---- | :------------- | :----------------------------------- |
| X     | 0     | **主Flash**    | **内部Flash** (从0x08000000映射过来) |
| 0     | 1     | **系统存储器** | 系统Bootloader (用于串口/USB下载)    |
| 1     | 1     | **内置SRAM**   | 内部SRAM (从0x20000000映射过来)      |

**最常用的模式是BOOT0=0，也就是从主Flash启动。**

### 详细解释从Flash启动的过程（为什么是0x08000000）

1.  **上电/复位**：芯片上电或复位，BOOT引脚被采样。
2.  **硬件重映射**：如果BOOT0=0，硬件自动将**内部Flash的起始地址(0x08000000)** 映射到**0x00000000**。
3.  **内核取向量**：
    *   Cortex-M内核总是从**0x00000000**地址读取**主堆栈指针(MSP)** 的初始值。
    *   然后从**0x00000004**地址读取**复位向量**（即程序入口地址）。
4.  **跳转执行**：内核根据读到的复位向量，跳转到对应的地址开始执行程序。

**关键点来了**：由于重映射，当内核去读0x00000000和0x00000004时，它实际上读取的是0x08000000和0x08000004位置的内容。也就是说，你的程序虽然烧录在0x08000000开头的Flash里，但在启动瞬间，它"伪装"成了从0x00000000开始。

### 一个具体的例子：中断向量表

你的程序开头有一个叫**中断向量表**的数据结构。它的前两个条目就是MSP初始值和复位向量。

```c
// 这个表通常由启动文件定义，并链接到Flash的起始位置 (0x08000000)
const uint32_t InterruptVectorTable[] __attribute__((section(".isr_vector"))) = {
    0x20010000,  // 主堆栈指针的初始值 (指向SRAM末尾)
    (uint32_t)&Reset_Handler, // 复位服务例程的地址，假设是0x08000101
    (uint32_t)&NMI_Handler,
    // ... 其他中断向量
};
```

*   **烧录后**：这个表物理上存放在地址`0x08000000`, `0x08000004`, `0x08000008`...
*   **启动时**：因为重映射，内核从`0x00000000`读到的是`0x08000000`的值（MSP初始值），从`0x00000004`读到的是`0x08000004`的值（复位向量地址）。
*   **跳转**：复位向量的值假设是`0x08000101`，内核就直接跳转到这个**实际的Flash地址**去执行`Reset_Handler`函数。

**一旦程序开始运行，重映射对软件来说是透明的。** 你的所有代码、数据地址都是基于0x08000000这个基址进行链接和定位的。编译器、链接器和调试器都知道代码的真正家园是0x08000000。

### 为什么设计得这么复杂？

这种设计提供了极大的灵活性：

1.  **统一的入口点**：无论代码实际放在哪里（内部Flash、外部Flash、SRAM），Cortex-M内核都从固定的地址(0x00000000)开始执行，简化了内核设计。
2.  **多启动选择**：通过简单的引脚配置，可以让芯片从不同的存储器启动，用于系统编程（Bootloader模式）或调试（SRAM模式）。
3.  **优化性能**：运行后直接使用物理地址访问Flash，可以获得确定的访问时序。

### 总结

*   **0x00000000**是**启动地址**：是Cortex-M内核的固定入口，一个"虚拟的"起点。
*   **0x08000000**是**存储地址**：是内部Flash的**物理地址**，是你代码实际存放的"家园"。
*   **重映射**是连接两者的"桥梁"：在启动瞬间，硬件将物理地址映射到虚拟地址，让内核能够顺利找到并执行代码。

所以，你的程序计数器最终

#### 启动方式与别名

STM32有一个非常灵活的自举模式，通过BOOT0和BOOT1引脚配置。这影响了CPU上电后从哪个地址开始执行代码。

*   **从主闪存启动（常规模式）**：BOOT0=0。
    *   在这种情况下，芯片将**地址 `0x0800 0000` 映射到 `0x0000 0000`**。
    *   内核从 `0x0000 0000` 取出的第一条指令，实际上来自于物理地址 `0x0800 0000`。
    *   这可以简化中断向量表的设计，因为它在地址0处仍然是可访问的。

*   **从系统存储器启动（ISP模式）**：BOOT0=1， BOOT1=0。
    *   用于通过UART/USB等接口进行系统编程，即内置的Bootloader。

*   **从内置SRAM启动**：BOOT0=1， BOOT1=1。
    *   主要用于调试，程序代码被加载到RAM中执行。

在**从主闪存启动**模式下，你可以认为 `0x0000 0000` 是 `0x0800 0000` 的一个“别名”，它们指向同一块物理存储单元。

好的，我们来详细介绍一下STM32微控制器的三种启动模式。

STM32的启动方式非常灵活，它通过芯片上两个特定的引脚（**BOOT0** 和 **BOOT1**）在复位时的电平状态来决定程序从哪个存储区域开始执行。这三种模式主要解决了程序下载、调试和正常运行等不同场景下的需求。

---

### 核心概念：启动引脚（BOOT0 和 BOOT1）

在理解三种模式之前，必须先了解这两个引脚：

*   **BOOT0**： 这是最重要的启动选择引脚。它是一个专用引脚，通常在芯片外部通过电阻连接到高电平（VDD）或低电平（GND）。
*   **BOOT1**： 这个引脚在部分型号中是一个专用引脚，但在更多现代型号中，它与其他GPIO引脚（如PB2）复用。**这意味着你需要查阅你所使用的具体STM32型号的数据手册或引脚分配图来确定哪个引脚是BOOT1。**

通过配置这两个引脚在**复位时**的电平，就可以选择启动模式。**注意：** 芯片只在**复位信号上升沿**的那一刻采样这两个引脚的电平。复位完成后，你可以将BOOT1引脚重新配置为普通GPIO使用，而启动模式已经确定，不会改变。

---

### 三种启动模式详解

下面的表格清晰地总结了三种模式的配置和用途：

| 启动模式            | BOOT0 |   BOOT1   | 别名          | 程序起始地址                | 主要用途                           |
| :------------------ | :---: | :-------: | :------------ | :-------------------------- | :--------------------------------- |
| **1. 主闪存存储器** |   0   | X（任意） | Main Flash    | `0x0800 0000`               | **最常用模式**，程序正常运行时使用 |
| **2. 系统存储器**   |   1   |     0     | System Memory | `0x1FFF 0000`（F1系列示例） | **串口下载程序（ISP）**            |
| **3. 内置SRAM**     |   1   |     1     | Embedded SRAM | `0x2000 0000`               | **调试和测试代码**                 |

---

#### 1. 主闪存存储器模式

*   **配置**： **BOOT0 = 0**， BOOT1任意（通常也接GND）。
*   **执行地址**： 从 `0x0800 0000` 开始执行程序。
*   **工作原理**： 这是STM32的**常规启动模式**。芯片上电复位后，直接从内部的Flash存储器（即你通过ST-Link、J-Link等下载器烧录程序的地方）开始执行代码。Cortex-M内核的初始SP（栈指针）和PC（程序计数器）值都从这个地址开始读取。
*   **应用场景**：
    *   **产品正常运行**：99%的情况下，产品出厂时都应设置为此模式。
    *   **通过调试器（如ST-Link）下载程序**：使用Keil、IAR、STM32CubeIDE等IDE开发时，程序默认下载到Flash，并在此模式下运行。

#### 2. 系统存储器模式

*   **配置**： **BOOT0 = 1**， **BOOT1 = 0**。
*   **执行地址**： 从一段特定的ROM地址开始执行（例如，STM32F1系列是 `0x1FFF F000`），这个地址因系列而异。
*   **工作原理**： 这个区域存储了ST预烧录在芯片内部的**Bootloader程序**。这个Bootloader是芯片出厂时就固化的，用户无法修改。它提供了通过特定接口（如USART1、USB DFU等）来给主闪存（Flash）下载程序的能力，这个过程也称为**ISP**。
*   **应用场景**：
    *   **串口下载程序**：当你的板子上没有预留调试器接口（如SWD）时，可以通过USB转TTL模块连接到MCU的串口，使用此模式来下载程序。常用工具有 **FlyMcu**、 **STM32FlashLoader** 或 **STM32CubeProgrammer**。
    *   **USB DFU升级**：部分系列（如F0， F4）的Bootloader支持通过USB接口进行设备固件升级。
    *   **救砖**：如果误操作将Flash的读保护等级提高或程序出错导致无法通过SWD调试，此模式通常是恢复的手段之一。

#### 3. 内置SRAM模式

*   **配置**： **BOOT0 = 1**， **BOOT1 = 1**。
*   **执行地址**： 从 `0x2000 0000`（SRAM的起始地址）开始执行。
*   **工作原理**： 芯片将SRAM映射为启动存储器。但是，SRAM是易失性存储器，断电后数据会丢失。因此，你无法直接将程序“烧录”到SRAM中并永久保存。
*   **应用场景**：
    *   **代码调试**：当你需要快速测试一段代码，不想反复擦写Flash（Flash有寿命限制，约1万次）时，可以先用调试器将程序**加载**到SRAM中，然后在此模式下运行。
    *   **性能测试**：在SRAM中运行代码通常比在Flash中运行更快，可以用于测试代码的极限性能。
    *   **特殊需求**：例如，需要实现IAP（在应用中编程）时，新的固件程序可能会先被下载到SRAM中，再由旧的固件程序将其写入Flash。

---

### 重要注意事项

1.  **地址重映射**： 为了让内核能够以统一的方式启动，无论选择哪种模式，Cortex-M内核看到的**初始地址`0x0000 0000`都会被映射到对应的启动存储区**。
    *   主闪存模式：`0x0000 0000` 映射到 `0x0800 0000`
    *   系统存储器模式：`0x0000 0000` 映射到 `0x1FFF 0000`（F1示例）
    *   内置SRAM模式：`0x0000 0000` 映射到 `0x2000 0000`
    这种机制简化了内核的设计。

2.  **下载程序后需切换模式**： 如果你使用系统存储器模式（串口下载）成功将程序下载到Flash后，**必须将BOOT0引脚重新接回低电平（0），并再次复位**，芯片才会执行你刚下载的新程序。

3.  **查阅数据手册**： 不同系列的STM32（如F0, F1, F4, H7等），其系统存储器Bootloader所支持的接口（UART, USB, CAN, I2C等）和地址可能会有所不同。务必查阅对应型号的**应用笔记AN2606**来获取最准确的Bootloader信息。

### 总结

| 模式           | 核心思想                  | 一句话应用                               |
| :------------- | :------------------------ | :--------------------------------------- |
| **主闪存**     | **常规运行**              | 程序烧好，上电就跑，产品常态。           |
| **系统存储器** | **系统自救/无调试器下载** | 没有下载器？用串口/USB来灌程序。         |
| **内置SRAM**   | **临时调试**              | 代码放内存里跑，快，掉电就丢，用于调试。 |

希望这个详细的解释能帮助你彻底理解STM32的三种启动方式。