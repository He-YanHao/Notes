# 中断上下文

## 技术定义

**中断上下文** 是指CPU在响应一个中断时，所处于的特殊执行环境。它包括了中断发生时，被中断任务（主程序或另一个低优先级中断）的现场（如程序计数器、寄存器值等），以及中断服务程序本身正在运行的代码和堆栈环境。



## 中断上下文 vs 进程上下文（任务上下文）

这是理解它的关键对比。在很多操作系统中（包括RTOS），都有“上下文”的概念。

| 特性           | **中断上下文**                                   | **进程/任务上下文**              |
| :------------- | :----------------------------------------------- | :------------------------------- |
| **触发方式**   | 由硬件中断（定时器、GPIO、串口等）异步触发       | 由操作系统调度器或任务主动调用   |
| **代表谁执行** | 代表“硬件”执行，与任何具体任务无关               | 代表一个具体的“任务”或“进程”执行 |
| **堆栈**       | 通常使用专用的**中断堆栈**或当前任务的堆栈       | 使用**任务自己的私有堆栈**       |
| **调度/阻塞**  | **绝对不能**睡眠、阻塞、或调用可能引起调度的函数 | **可以**睡眠、阻塞、主动让出CPU  |
| **优先级**     | 拥有最高的优先级，会抢占任何任务上下文           | 优先级由操作系统调度策略决定     |
| **可重入性**   | 需要小心处理，可能被更高优先级中断嵌套           | 通常由操作系统管理并发           |



## 中断上下文的限制（为什么重要？）

在中断上下文中（也就是在你的中断服务函数ISR里），会受到严格的限制，最主要的原因就是**它不在任何任务的上下文中，调度器无法对其进行管理**。

**在中断上下文中绝对不能做的事情：**

1.  **睡眠或延迟**：例如`sleep()`, `delay()`。这会直接导致系统死机，因为调度器无法唤醒一个不存在的“中断任务”。
2.  **获取可能导致睡眠的锁**：如互斥锁。如果锁已被占用，尝试获取它可能会导致任务睡眠，这在中断中是禁止的。
3.  **调用可能阻塞的函数**：很多执行I/O操作的函数（如从文件读取、从网络接收）都可能阻塞。
4.  **与用户空间交互**：这属于Linux驱动开发的概念，但在单片机中类比为，你不能直接执行复杂的、依赖任务状态的操作。
5.  **执行耗时过长的操作**：这会使得其他低优先级中断和任务长时间得不到响应，破坏系统的实时性。



## 正确的做法：中断处理原则（上半部 & 下半部）

这个理念在复杂的系统和RTOS中非常重要：

*   **上半部**：也就是**中断服务程序ISR**本身。
    *   **职责**：在中断上下文中执行。只做**最紧急、最少量的工作**，如清除中断标志、读取数据到缓存、发送一个信号量。
    *   **特点**：**快进快出**。

*   **下半部**：在任务上下文中执行。
    *   **职责**：处理上半部抛出来的、不那么紧急但耗时的工作。如解析数据、进行复杂计算、唤醒其他任务。
    *   **实现方式**：在RTOS中，通常是通过**释放一个信号量、消息队列或事件标志**，来唤醒一个等待该事件的**专用任务**。这个专用任务再去执行复杂的逻辑。

