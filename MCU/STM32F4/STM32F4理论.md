# STM32F407

## Keil5新建工程

新建文件夹，用来存放项目，在该文件夹下创建以下六个文件夹：

- drivers    存放单片机自带硬件驱动函数。
- hardware    存放外设驱动函数。
- projects    存放项目。
- startup    存放启动函数和arm内核。
- system   存放依靠单片机软件模拟函数。
- user    存放用户主函数。

在keil5里新建 `drivers` `hardware` `startup` `system` `user`等函数并添加文件夹下全部函数。

- 勾选 `Target/USB MicroLIB`
- 勾选`Output/Create HEX File`
- 在`C/C++/Define`添加全局变量`USE_STDPERIPH_DRIVER,STM32F40_41xxx,` 和在`Misc Controls ` 里添加`--no-multibyte-chars`不处理多余字节。
- 添加头文件目录。
- 在Debug/Use里更改仿真器，勾选`setting/Fiash Download/Rest and Run`使其下载后自动启动。

## STM32F4系列的一些概念

包含两个调试端口：

- JTAG 调试端口 (JTAG-DP) 提供基于联合测试工作组 (JTAG) 协议的 5 引脚标准接口。

- SWD 调试端口 (SWD-DP) 提供基于串行线调试 (SWD) 协议的 2 引脚（时钟和数据）接口。

IAP（在应用中编程）：IAP 是指可以在用户程序运行期间对微控制器的 Flash 进行重新 编程。

ICP（在线编程）：ICP 是指可以在器件安装于用户应用电路板上时使用 JTAG 协议、  SWD 协议或自举程序对微控制器的 Flash 进行编程。

I-Code：此总线用于将 CPU 内核的指令总线连接到 Flash 指令接口。通过此总线可执行预取操作。

D-Code：此总线用于将 CPU 的 D-Code 总线（数据加载和调试访问）连接到 Flash 数据接口。

OBL：选项字节加载器。

AHB：高级高性能总线。

## 储存器架构 ## 

主系统由 32 位多层 AHB 总线矩阵构成，可实现以下部分的互连：

- 八条主控总线：
  - Cortex™-M4F 内核 I 总线：将指令总线连接到总线矩阵，内核通过此总线获取指令。
  - Cortex™-M4F 内核 D 总线：此总线用于将 Cortex™-M4F 数据总线和 64 KB CCM 数据 RAM 连接到总线矩阵。内核通过  此总线进行立即数加载和调试访问。此总线访问的对象是包含代码或数据的存储器（内部 Flash 或通过 FSMC 的外部存储器）。
- Cortex™-M4F 内核 S 总线：此总线用于将 Cortex™-M4F 内核的系统总线连接到总线矩阵。此总线用于访问位于外设  或 SRAM 中的数据。也可通过此总线获取指令（效率低于 ICode）。此总线访问的对象是  112 KB、64 KB 和 16 KB 的内部 SRAM、包括 APB 外设在内的 AHB1 外设、AHB2 外设以  及通过 FSMC 的外部存储器。
  - DMA1 存储器总线
  - DMA2 存储器总线
  - DMA2 外设总线
  - 以太网 DMA 总线
  - USB OTG HS DMA 总线
- 七条被控总线：
  - 内部 Flash ICode 总线
  - 内部 Flash DCode 总线
  - 主要内部 SRAM1 (112 KB)
  - 辅助内部 SRAM2 (16 KB)
    - 辅助内部SRAM3(64KB)(仅适用于STM32F42xxx和STM32F43xxx器件)（特殊：不属于七条被控总线，只能CPU访问）。
  - AHB1 外设（包括 AHB-APB 总线桥和 APB 外设）
  - AHB2 外设
  - FSMC

### 位段

Cortex™-M4F 存储器映射包括两个位段区域。这些区域将存储器别名区域中的每个字映射到存储器位段区域中的相应位。在别名区域写入字时，相当于对位段区域的目标位执行读-改-写操作。 

在 STM32F4xx 器件中，外设寄存器和 SRAM 均映射到一个位段区域，这样可实现单个位段的读写操作。这些操作仅适用于 Cortex™-M4F 访问，对于其它总线主接口（如 DMA）无效。 

可通过一个映射公式说明别名区域中的每个字与位段区域中各个位之间的对应关系。

映射公式为： bit_word_addr = bit_band_base + (byte_offset x 32) + (bit_number × 4)

- bit_word_addr 代表别名区域中将映射到目标位的字的地址

- bit_band_base 是位带区域的基地址。

  - 对于SRAM区，这个地址是 `0x 2200 0000`。

  - 对于外设位带操作，这个地址是 `0x 4200 0000`。

- byte_offset 代表目标位所在位段区域中的字节编号

- bit_number 代表目标位的位位置 (0-7)

> 下例说明如何将 SRAM 地址 0x20000300 处字节的位 2 映射到别名区域： 
>
> 0x22006008 = 0x22000000 + (0x300\*32) + (2\*4) 	//此处为0x表示十六进制，而非相乘。
>
> 对地址 0x22006008 执行写操作相当于在 SRAM 地址 0x20000300 处字节的位 2 执行读-修  改-写操作。 
>
> 对地址 0x22006008 执行读操作将返回 SRAM 地址 0x20000300 处字节的位 2 的值（0x01  表示位置位，0x00 表示位复位）。

## 嵌入式Flash接口



## CRC计算单元



## PWR电源控制



## RCC时钟



## GPIO和AFIO

与STM32F1XX不同的是，STM32F4XX不能直接配置工作模式，需要结合 `GPIO_Mode` `GPIO_OType` `GPIO_PuPd` 配置出GPIO的具体模式。

```c
typedef struct
{
  uint32_t GPIO_Pin;
  GPIOMode_TypeDef GPIO_Mode;
  GPIOSpeed_TypeDef GPIO_Speed;
  GPIOOType_TypeDef GPIO_OType;
  GPIOPuPd_TypeDef GPIO_PuPd;
}GPIO_InitTypeDef;
```

- GPIO_Mode
  - GPIO_Mode_IN			 //输入
  - GPIO_Mode_OUT		 //输出
  - GPIO_Mode_AF			//复用模式
  - GPIO_Mode_AN	       //模拟输入

- GPIO_OType
  - GPIO_OType_PP		   //推挽输出
  - GPIO_OType_OD		  //开漏输出

- GPIO_Speed

  - GPIO_Low_Speed          //低速（Low speed）：适用于功耗敏感的应用或者那些不需要高速切换的场合。
  - GPIO_Medium_Speed   //中速（Medium speed）：提供了一种平衡的速度和功耗的选项，适合大多数应用。
  - GPIO_Fast_Speed          //高速（High speed）：用于需要较快数据传输或较高频率切换的应用。
  - GPIO_High_Speed         //极高速（Very high speed）：提供最快的GPIO切换速度，适用于高速通信或快速信号处理。

- GPIO_PuPd

  - GPIO_PuPd_NOPULL	//无上下拉
  - GPIO_PuPd_UP			  //上拉
  - GPIO_PuPd_DOWN	   //下拉

可以将GPIO口配置成：

- **输入浮空**：可读取电平，若引脚悬空，则电平不稳定。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_IN;//输入
  GPIOOType_TypeDef.GPIO_OType;//省略
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  这个模式因为不稳定往往很少使用。

- **输入上拉**：可读取引脚电平，内部接上拉电阻，悬空默认高电平。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_IN;//输入
  GPIOOType_TypeDef.GPIO_OType;//省略
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_UP;//上拉
  ```

  一般当按键按下时为低电平时使用该模式，也可以反着用。

- **输入下拉**：可读取引脚电平，内部接下拉电阻，悬空默认低电平。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_IN;//输入
  GPIOOType_TypeDef.GPIO_OType;//省略
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_DOWN;//下拉
  ```

  一般当按键按下时为高电平时使用该模式，也可以反着用。

- **模拟功能**：GPIO无效，接入内部ADC。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_AN;//模拟输入
  GPIOOType_TypeDef.GPIO_OType;//省略
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  使用ADC外设时需要配置为该模式，仅在该情况下使用。

- 具有上拉或下拉功能的**开漏输出**：可输出引脚电平，高电平为高阻态，低电平接VCC。驱动能力较小。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_OUT;//输出
  GPIOOType_TypeDef.GPIO_OType = GPIO_OType_OD;//开漏输出
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  **开漏输出与推挽输出的区别：**

  **当单片机的GPIO口被配置为输出时，由接VCC和GND的两个MOS管决定。**

  **当VCC_MOS打开，GND_MOS关闭时，电流从VCC_MOS流向GPIO连接的外设，此时输出高电平。**

  **当VCC_MOS关闭，GND_MOS打开时，电流从GPIO连接的外设流向GND_MOS，此时输出低电平。**

  **这种输出方式被称为推挽输出。**

  **当VCC_MOS关闭，GND_MOS关闭，并外接一个上拉电阻时，上拉电阻驱动GPIO连接的外设，此时输出高电平。**

  **当VCC_MOS关闭，GND_MOS打开，并外接一个上拉电阻时，上拉电阻驱动的电流流向GND_MOS，此时输出低电平。**

  **这种输出方式被称为开漏输出。**

  **开漏输出可以改变上拉电阻的值改变驱动电压。同时在推挽模式下若输出高电平的GPIO和输出低电平的GPIO连接，就会发生短路，若是开漏输出，则任意一个GPIO输出低电平，上拉电阻的电压就会被GND_MOS拉低。**

- 具有上拉或下拉功能的**推挽输出**：可输出引脚电平，高电平为VDD，低电平接VCC。驱动能力较大。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_OUT;//输出
  GPIOOType_TypeDef.GPIO_OType = GPIO_OType_PP;//推挽输出
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  同上。

- 具有上拉或下拉功能的**复用功能推挽**：有片上外设控制，高电平为高阻态，低电平接VCC。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_AF;//复用模式
  GPIOOType_TypeDef.GPIO_OType = GPIO_OType_PP;//推挽输出
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  在使用I2C SPI 等外设时，GPIO口会被外设所控制，这是配置为复用功能，至于是复用推挽还是复用开漏由连接的外设决定。

- 具有上拉或下拉功能的**复用功能开漏**：有片上外设控制，高电平为VDD，低电平接VCC。

  ```
  GPIOMode_TypeDef.GPIO_Mode = GPIO_Mode_AF;//复用模式
  GPIOOType_TypeDef.GPIO_OType = GPIO_OType_OD;//开漏输出
  GPIOPuPd_TypeDef.GPIO_PuPd = GPIO_PuPd_NOPULL;//无上下拉
  ```

  同上。

**GPIO口配置流程：**

1. 配置GPIO工作模式：通过控制寄存器（**GPIOx_MODER**）配置为输入功能，输出功能，复用功能还是模拟功能。
2. 通过 GPIO 上/下拉寄存器（**GPIOx_PUPDR**）配置GPIO的上下拉模式或者浮空。
   - 一般输出模式我们都配置为浮空模式，输入模式我们才需要考虑上拉还是下拉，根据默认电平状态进行判断。
3. 配置GPIO的输出模式，配置端口输出模式寄存器GPIOx_MODER。
4. 配置GPIO速度。

每个通用 I/O 端口寄存器包括：

- GPIOx_MODER  配置GPIO_Mode。
- GPIOx_OTYPER  配置GPIO_OType。
- GPIOx_OSPEEDR  配置GPIO_Speed。
- GPIOx_PUPDR  配置GPIO_PuPd。
- GPIOx_IDR  GPIO输入数据寄存器，只读。
- GPIOx_ODR  GPIO输出数据寄存器，可读可写。
- GPIOx_BSRR  GPIO复位寄存器，可读可写，写1复位，读取返回0X0000。
- GPIOx_LCKR  GPIO端口配置锁定寄存器。
- GPIOx_AFRH  GPIO复用功能低位寄存器。
- GPIOx_AFRL  GPIO复用功能高位寄存器。

## SYSCFG系统配置控制器



## DMA控制器

DMA可以在不经过CPU的情况下快速移动数据。

**时钟：**

STM32F4xx系列的DMA位于AHB1总线下。

**通道：**

STM32F4xx系列包含两个 DMA 控制器，总共有 16 个数据流（每个控制器 8 个），每一个 DMA 控制器都用于管理一个或多个外设的存储器访问请求。每个数据流总共可以有多达 8 个通道（或称请求）。每个通道都有一个仲裁器，用于处理 DMA 请求间的优先级（当软件优先级相同时，有硬件决定优先级，如：请求 0 的优先级高于请求 1）。

- DAM控制器 2 个。
  - 数据流 8 个/DMA控制器。
    - 通道（或称请求） 8 个/数据流。
      - 仲裁器 1 个/通道。

**地址：**

仅支持 32 位访问的 AHB 从编程接口（？地址只能是32位？）

**方向：**

STM32F4xx系列的DMA支持外设到存储器传输、存储器到外设传输和存储器到存储器传输三种传输模式。（仅限 DMA2 控制器支持通过软件触发存储器到存储器的传输）

其中外设和储存器分别是：

- 外设一般指外设的数据寄存器，比如ADC、SPI、I2C、DCMI等等外设的数据寄存器。
- 存储器一般是指片内SRAM、外部存储器、片内Flash等等。

三种传输模式的选择分别是：

- 外设到存储器传输：快速接收。
- 存储器到外设传输：快速发送。
- 存储器到存储器：快速拷贝数据。

**数据数量范围：**

要传输的数据项的数目是 1 到 65535。

**数据宽度：**

源和目标的数据宽度不相等时，DMA 自动  封装/解封必要的传输数据来优化带宽。这个特性仅在 FIFO 模式下可用。

**模式：**



**优先级：**



**FIFO模式：**







```c
/* 清除DMA数据流传输完成标志位 */
DMA_ClearFlag(DMA2_Stream0,DMA_FLAG_TCIF0);
/* 使能DMA数据流，开始DMA数据传输 */
DMA_Cmd(DMA2_Stream0, ENABLE);
while (DMA_GetCmdStatus(DMA2_Stream0) != ENABLE)
```





















## 中断



## ADC模拟数字转化

ADC可以将外部的模拟信号转化成数字信号。包含下面几个重要参数：

- **分辨率：**表示ADC转换器的输出精度，通常以位数（bit）表示，比如8位、10位、12位等，位数越高，精度越高。
- **采样率：**表示ADC对模拟输入信号进行采样的速率，通常以每秒采样次数（samples per second，SPS）表示，也称为转换速率，表示ADC能够进行多少次模拟到数字的转换。

- **采样范围：**指ADC可以采集到的模拟输入信号的电压范围，范围见下：V(REF-) ≤ ADC ≤ V(REF+)。其中V(REF- )为负参考电压等于 V(SSA )等于地0V，V(REF+ )为正参考电压等于V(DDA),而V(DDA)立创梁山派天空星上接入的是3.3V 。

STM32F4采用的是逐次逼近型的12位ADC，它有 19 个多路复用通道可以转换。19个通道来自 16 个外部通道、2个内部通道和一个电池电压（VBAT）通道的模拟信号。其中16个外部通道是通过GPIO复用得来，2个内部通道分别是内部温度传感器和内部参考电压。而电池电压VBAT是需要将电压接入芯片的VBAT引脚才可采集。16个外部通道，都对应单片机的某个引脚，这个引脚不是固定的，可以是一个通道一个引脚，也可以是一个通道两个引脚。

各种通道的 A/D 转换可以配置**成单次、连续、扫描或间断转换**模式。

- **单次转换模式：**每次进行一次ADC转换后，ADC会自动停止，并将结果存储在ADC数据寄存器中。
- **连续转换模式：**当ADC完成一次转换后，它会自动启动另一次转换，持续的进行转换，直到外部触发或者软件触发的方式停止连续转换。
- **扫描模式：**用于对多个输入通道进行依次转换。在扫描模式下，ADC会根据配置的通道采集顺序，对多个通道进行依次采样并转换。
- **间断模式：**用于对注入通道和常规通道之间进行切换。在间断模式下，ADC会优先转换注入通道，当注入转换完成后，自动切换到常规通道进行转换。

ADC 转换的结果最终可以按照左对齐或右对齐的方式存储在16位数据寄存器中。

本案例使用ADC0进行操作，需要开启ADC0的时钟。 不过需要注意的是STM32F4的用户手册写出，ADC的最大时钟频率为40MHz。V因此我们使用ADC时，需要将挂载ADC的时钟总线频率分频到40MHz以下。

STM32F407VET6一共有16个外部ADC通道，我们将光敏电阻模块的AO引脚连接在PA5引脚上，查找数据手册的引脚定义可知，PA5的附加功能有ADC1的通道5，ADC2的通道5。

STM32F4采用的是逐次逼近型的12位ADC，逐次逼近型ADC是一种常见的ADC工作原理，它的思想是通过比较模拟信号与参考电压之间的大小关系来逐步逼近输入信号的数字表示。在逐次逼近型ADC中，输入信号和参考电压被加入一个差分放大器中，产生一个差分电压。然后，这个差分电压被输入到一个逐步逼近的数字量化器中，该量化器以逐步递减的方式将其与一系列参考电压进行比较。具体来说，在每个逼近阶段，量化器将输入信号与一个中间电压点进行比较，将该电压点上方或下方的参考电压作为下一个逼近阶段的参考电压。这个过程一直持续到量化器逼近到最终的数字输出值为止。



## DAC数字模拟转换



## DCMI数字摄像头接口



## TIM定时器

STM32F407VET6一共有14个定时器，包括2个高级控制定时器、8个通用定时器、2个基本定时器和2个看门狗定时器。

14个定时器的时钟来源主要分为两部分，第一部分来源于APB1，第二部分来源于APB2。

- APB1：APB1最大42MHz。对于APB1时钟来说，APB1是AHB总线的4分频率也就是 168MHz / 4 = 42MHz ，定时器时钟拥有一个x2的倍频会将当前总线APB1频率x2，将x2后的时钟频率作为挂载在APB1总线上定时器的时钟频率。
- APB2：APB2最大84MHz。



**定时器周期 = 时钟源频率(CK_PSC) / 预分频器寄存器(TIMx_PSC)/ 自动重载寄存器(TIMx_ARR)；**



使用定时器功能步骤：

1. 开启定时器时钟
2. 配置定时器参数
3. 配置中断优先级
4. 使能中断事件和定时器
5. 编写中断服务函数



### 高级定时器

STM32F4XX具有的高级定时器资源是 TIMER1 和 TIMER8 。

高级定时器包含 16 位递增、递减、递增/递减**自动重载计数器** 和 16 位**可编程预分频器**，能介于 1 到 65536 之间分频。



> 其具有以下功能或特点：
>
> - 含有 4 个独立通道，可用于： 
>   - 输入捕获
>   - 输出比较
>   - PWM 生成（边沿和中心对齐模式）
>   - 单脉冲模式输出
> - 带可编程死区的互补输出。
> - 使用外部信号控制定时器且可实现多个定时器互连的同步电路。
> - 重复计数器，用于仅在给定数目的计数器周期后更新定时器寄存器。
> - 用于将定时器的输出信号置于复位状态或已知状态的断路输入。
> - 发生如下事件时生成中断/DMA 请求：
>   - 更新：计数器上溢/下溢、计数器初始化（通过软件或内部/外部触发）
>   - 触发事件（计数器启动、停止、初始化或通过内部/外部触发计数）
>   - 输入捕获 
>   - 输出比较
>   - 断路输入
> - 支持定位用增量（正交）编码器和霍尔传感器电路。
> - 外部时钟触发输入或逐周期电流管理。

#### 定时

**时基单元包括：**

- 计数器寄存器 (TIMx_CNT)
- 预分频器寄存器 (TIMx_PSC)
- 自动重载寄存器 (TIMx_ARR)
- 重复计数器寄存器 (TIMx_RCR)

**定时器定时原理：**

通过**时钟源 (1)** 提供的时钟信号计数，每**预分频器寄存器值 (2)** 计数一次，**计数器寄存器值 (3)** 到达**自动重载寄存器 (4)** 则**重复计数器寄存器 (5)** 减一，若重复计数器寄存器为零则触发中断。

**时钟源 (1) ：**

计数器时钟可由下列时钟源提供：

- 内部时钟 (CK_INT) 。
- 外部时钟模式1：外部输入引脚。
- 外部时钟模式2：外部触发输入 ETR。
- 外部触发输入 (ITRx)：使用一个定时器作为另一定时器的预分频器。

**预分频器寄存器值 (2) ：**

在计数时，会先进行预分频器介于 1 到 65536 之间分频。变为每分频单位计数一次。

预分频器寄存器 (TIMx_PSC)具有缓存机制，所以可以实时更改，新的预分频比将在下一更新事件发生时被采用。

**计数器寄存器值 (3) ：**

高级定时器通过 16 位自动重载计数器计数，具有三种计数方式：

- 递增模式：计数器寄存器从 0 开始计数，到达标志位则触发中断事件；
- 递减模式：计数器寄存器从标志位开始计数，到达 0 则触发中断事件；
- 中心对齐模式(递增/递减计数)：计数器寄存器从 0 开始计数，到达标志位则触发上溢事件；然后计数器寄存器从标志位开始计数，到达 0 则触发下溢事件；

**自动重载寄存器 (4) ：**

作为计数器的终点(递增模式)或起点(递减模式)。

**重复计数器寄存器 (5) ：**





在输入捕获模式下，当相应的 ICx 信号检测到跳变沿后，将使用捕获/比较寄存器 (TIMx_CCRx)  来锁存计数器的值。发生捕获事件时，会将相应的 CCXIF 标志（TIMx_SR 寄存器）置 1，  并可发送中断或 DMA 请求（如果已使能）。如果发生捕获事件时 CCxIF 标志已处于高位，  则会将重复捕获标志 CCxOF（TIMx_SR 寄存器）置 1。可通过软件向 CCxIF 写入 0 来给  CCxIF 清零，或读取存储在 TIMx_CCRx 寄存器中的已捕获数据。向 CCxOF 写入“0”后  会将其清零。 以下示例说明了如何在 TI1 输入出现上升沿时将计数器的值捕获到 TIMx_CCR1 中。具体操  作步骤如下： ● 选择有效输入：TIMx_CCR1 必须连接到 TI1 输入，因此向 TIMx_CCMR1 寄存器中的 CC1S  位写入 01。只要 CC1S 不等于 00，就会将通道配置为输入模式，并且 TIMx_CCR1 寄  存器将处于只读状态。 ● 根据连接到定时器的信号，对所需的输入滤波时间进行编程（如果输入为 TIx 输入，则  对 TIMx_CCMRx 寄存器中的 ICxF 位进行编程）。假设信号边沿变化时，输入信号最  多在 5 个内部时钟周期内发生抖动。因此，我们必须将滤波时间设置为大于 5 个内部时  钟周期。在检测到 8 个具有新电平的连续采样（以 fDTS 频率采样）后，可以确认 TI1  上的跳变沿。然后向 TIMx_CCMR1 寄存器中的 IC1F 位写入 0011。 ● 通过在 TIMx_CCER 寄存器中将 CC1P 位和 CC1NP 位写入 0，选择 TI1 上的有效转换  边沿（本例中为上升沿）。 ● 对输入预分频器进行编程。在本例中，我们希望每次有效转换时都执行捕获操作，因此 需要禁止预分频器（向 TIMx_CCMR1 寄存器中的 IC1PS 位写入“00”）。 ● 通过将 TIMx_CCER 寄存器中的 CC1E 位置 1，允许将计数器的值捕获到捕获寄存器中。 ● 如果需要，可通过将 TIMx_DIER 寄存器中的 CC1IE 位置 1 来使能相关中断请求，并且/  或者通过将该寄存器中的 CC1DE 位置 1 来使能 DMA 请求。

#### 输入捕获

输入捕获可以对输入的信号的上升沿，下降沿或者双边沿进行捕获，通常用于测量输入信号的脉宽、测量 PWM 输入信号的频率及占空比。

输入捕获的工作原理：在输入捕获模式下，检测 TIMx_CHx 上的边沿信号发生跳变（比如上升沿/下降沿）的时候，将当前定时器的值（TIMx_CNT）存放到对应的通道的捕获/比较寄存（TIMx_CCRx）里面，完成一次捕获。同时还可以配置捕获时是否触发中断/DMA 等。



#### PWM

PWM功能是在定时器的基础上实现的，但不是所有的定时器都支持PWM输出功能。

从用户手册上可以了解到，高级定时器拥有4个PWM通道，通用定时器L0拥有4个PWM通道，通用定时器拥有PWM通道而基本定时器没有PWM通道。每一个PWM通道都对应单片机的一个管脚，这个引脚不是唯一固定的，可能有一个或者两个管脚都对应同一个通道，我们在使用的时候可以任选其一进行配置。

此模式是输入捕获模式的一个特例。其实现步骤与输入捕获模式基本相同，仅存在以下不同 之处：

两个 ICx 信号被映射至同一个 TIx 输入。

这两个 ICx 信号在边沿处有效，但极性相反。

选择两个 TIxFP 信号之一作为触发输入，并将从模式控制器配置为复位模式。

 例如，可通过以下步骤对应用于 TI1 的 PWM 的周期（位于 TIMx_CCR1 寄存器中）和占空  比（位于 TIMx_CCR2 寄存器中）进行测量（取决于 CK_INT 频率和预分频器的值）：

选择 TIMx_CCR1 的有效输入：向 TIMx_CCMR1 寄存器中的 CC1S 位写入 01（选择 TI1）。

选择 TI1FP1 的有效极性（用于在 TIMx_CCR1 中捕获和计数器清零）：向 CC1P 位和  CC1NP 位写入“0”（上升沿有效）。

选择 TIMx_CCR2 的有效输入：向 TIMx_CCMR1 寄存器中的 CC2S 写入 10（选择 TI1）。

选择 TI1FP2 的有效极性（用于在 TIMx_CCR2 中捕获）：向 CC2P 位和 CC2NP 位写  入“1”（下降沿有效）。

选择有效触发输入：向 TIMx_SMCR 寄存器中的 TS 位写入 101（选择 TI1FP1）。

将从模式控制器配置为复位模式：向 TIMx_SMCR 寄存器中的 SMS 位写入 100。

使能捕获：向 TIMx_CCER 寄存器中的 CC1E 位和 CC2E 位写入“1”。



### 通用定时器

通用定时器TIM2、TIM3、TIM4和TIM5是4通道定时器，支持输入捕获和输出比较，可以产生PWM信号控制电机和电源管理。

通用定时器TIM9、TIM10、TIM11、TIM12、TIM13和TIM14是单通道定时器，支持输入捕获，输出比较，产生PWM信号控制电机和电源管理。



### 基本定时器

基本定时器（TIMER6和TIMER7）包含一个无符号的16位计数器。可以被用作通用定时器和为DAC（数字到模拟转换器）提供时钟。基本定时器可以配置产生DMA请求，TRGO触发连接到DAC。



## RTC实时时钟

RTC的时钟来源有三种，内部IRC32K低速时钟、外部低速时钟32.768KHz和外部高速时钟2~31MHz。

其中：

- 内部IRC32K低速时钟都有，无需额外添加。
- 外部低速时钟32.768KHz节能。
- 外部高速时钟2~31MHz准确且高速，但耗能较高。

## IWDG独立看门狗 ## 



## WWDG窗口看门狗



## CRYP加密处理器



## RNG随机数发生器



## HASH散列处理器



## RTC实时时钟

可以配置为以内部或外部时钟源作为时基。

它可以存储和跟踪年、月、日、周、小时、分钟和秒等时间信息。

具有闹钟功能，可以预设时间，触发中断。

同时也有定时器功能，可以定时触发中断。

包含备份寄存器，数量由型号决定。

RTC实时时钟的核心寄存器都在备份域里，所以使用前要先解除备份域的写保护。



```c
RtcTimeConfig(24,3,11,1,18,10,1, RTC_H12_AM);
//含义为2噢4年3月11日，周一，十八点十分，一秒。
//RTC_H12_AM为24小时制
//RTC_H12_PM为12小时制
```

## bxCAN控制器局部网



## I2C接口



## USART通用同步异步发射器



## SPI串行外设



### 天空星W25Q128

| 片选     | SPI_CS/PA04   | CS     | VCC  | 3.3V          | 电源正                      |
| -------- | ------------- | ------ | ---- | ------------- | --------------------------- |
| 数据收发 | SPI_MISO/PA06 | DO/IO1 | HOLD | 3.3V          | 低电平有效，无效化DI 和 CLK |
| 写保护   | 3.3V          | WP/IO2 | SCLK | SPI_CLK/PA05  | 时钟                        |
| 电源地   | GND           | GND    | SI   | SPI_MOSI/PA07 | 数据收发                    |

## SDIO接口

## MAC以太网 

## USB全速

## USB高速

## FSMC静态储存控制器

## 器件签名

## DBG调试支持

## 内存管理

malloc函数用来内存申请，free函数用于内存释放。

分块管理。
