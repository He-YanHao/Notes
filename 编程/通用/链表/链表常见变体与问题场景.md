# 链表常见变体与问题场景

## 环形链表 (Circular Linked List)

### 概念
环形链表是一种特殊的链表，其中最后一个节点的指针不为空，而是指向链表中的某个先前节点（包括头节点或自身），形成一个环。

### 类型
- **单向环形链表**：尾节点指向头节点或其他节点
- **双向环形链表**：尾节点的next指向头节点，头节点的prev指向尾节点

### 应用场景
1. 循环缓冲区（Round-robin调度）
2. 操作系统中的进程调度
3. 多人游戏中的玩家轮流机制
4. 实现斐波那契堆等高级数据结构

### 检测环形链表（Floyd判圈算法/龟兔赛跑算法）
```c
#include <stdbool.h>

struct ListNode {
    int val;                //定义链表里的数据部分
    struct ListNode *next;  //定义链表里的指针部分
};

bool hasCycle(struct ListNode *head) {       //参数为链表头
    if (head == NULL || head->next == NULL) {//头不为空 或 头的头指向的地方不为空 则继续
        return false;//返回假
    }
    
    struct ListNode *slow = head;			//定义慢指针
    struct ListNode *fast = head->next;     //定义快指针
    
    while (slow != fast) {                  //快不等于满
        if (fast == NULL || fast->next == NULL) {//快不空 或 快指向不空
            return false;//返回假
        }
        slow = slow->next;          //慢等于慢指向的
        fast = fast->next->next;    //快等于快指向指向的
    }

    return true;    //返回真
}
```

## 交叉链表 (Intersecting Linked Lists)

### 概念
两个链表在某个节点开始合并，共享后续的节点。

```
List A: a1 → a2 → a3
                     ↘
                      c1 → c2 → c3 → NULL
                     ↗
List B: b1 → b2 → b3
```

### 应用场景
1. 表示有共同后缀的单词（如"loading"和"being"）
2. 版本控制系统中的分支合并
3. 家族树中不同分支的共同祖先

### 找到交叉点
```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if (headA == NULL || headB == NULL) return NULL;
    
    struct ListNode *a = headA;
    struct ListNode *b = headB;
    
    // 当a到达链表A的末尾时，重定向到链表B的头节点
    // 当b到达链表B的末尾时，重定向到链表A的头节点
    // 如果两个链表相交，a和b会在交点相遇
    while (a != b) {
        a = a == NULL ? headB : a->next;
        b = b == NULL ? headA : b->next;
    }
    
    return a;
}
```

## 带环链表 (Linked List with Cycle)

### 概念
与环形链表不同，带环链表不是刻意设计的环形结构，而是由于编程错误或特定算法导致的意外成环。

### 应用场景/问题
1. 内存管理错误（如错误的指针操作）
2. 递归数据结构中的错误引用
3. 需要检测和修复的编程错误

### 检测并找到环的起点
```c
struct ListNode *detectCycle(struct ListNode *head) {
    if (head == NULL || head->next == NULL) return NULL;
    
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    bool hasCycle = false;
    
    // 检测是否有环
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            hasCycle = true;
            break;
        }
    }
    
    if (!hasCycle) return NULL;
    
    // 找到环的起点
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    
    return slow;
}
```

## 多级链表 (Multilevel Linked List)

### 概念
每个节点除了有指向下一个节点的指针外，还有一个指针可以指向另一个链表。

### 应用场景
1. 表示嵌套结构（如文件系统的目录结构）
2. 扁平化多层数据结构
3. 表示树形结构的另一种方式

### 扁平化多级链表
```c
struct Node {
    int val;
    struct Node *next;
    struct Node *child;
};

struct Node* flatten(struct Node* head) {
    if (head == NULL) return NULL;
    
    struct Node *current = head;
    while (current != NULL) {
        if (current->child != NULL) {
            struct Node *next = current->next;
            struct Node *child = flatten(current->child);
            
            current->next = child;
            current->child = NULL;
            
            // 找到子链表的末尾
            while (child->next != NULL) {
                child = child->next;
            }
            
            child->next = next;
        }
        current = current->next;
    }
    
    return head;
}
```

## 其他常见链表问题

### 反转链表
```c
struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode *prev = NULL;
    struct ListNode *current = head;
    
    while (current != NULL) {
        struct ListNode *next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}
```

### 合并两个有序链表
```c
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    if (l1 == NULL) return l2;
    if (l2 == NULL) return l1;
    
    if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```

## 总结

链表的各种变体和相关问题在编程面试和实际开发中都非常常见。理解这些特殊形式的链表及其应用场景，掌握检测和处理这些情况的算法，对于提高编程能力和解决复杂问题非常有帮助。每种变体都有其特定的应用场景和解决方案，熟练这些内容将大大增强你处理链表相关问题的能力。