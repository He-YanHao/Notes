# 内存区域

## 基础介绍

当我们编译一个C/C++程序时，可执行文件不仅包含机器指令，还包含如何组织内存的元信息。当程序被操作系统加载到内存中运行时，这些不同的内容被分配到内存的不同区域，主要包括：**代码段（Text Segment）、数据段（Data Segment）、BSS段（BSS Segment）、堆（Heap）和栈（Stack）**。

下图清晰地展示了这些段在进程地址空间中的典型布局：

内存从高到低依次是：

- 栈 (Stack)
- 堆 (Heap)
- BSS 段
- 数据段 (Data Segment)
- 代码段 (Text Segment)

所有语言在底层最终都映射到进程的代码段、数据段、堆和栈。

但高级语言通过**虚拟化（如JVM、解释器）** 或**高级语言特性（如Rust的所有权系统）**，将这些细节隐藏起来，为程序员提供了一个更安全、更易用的抽象层，代价则是不同程度的控制力和性能开销。Rust 在其中独树一帜，它没有牺牲控制力和性能，却通过复杂的编译期检查同样实现了内存安全。

## 代码段（Text Segment / Code Segment）

*   **存放内容**：主要存放程序的**机器指令**（即编译后的可执行代码）。这部分内存通常是只读的，以防止程序意外修改自身的指令。
*   **特点**：
    *   **只读（Read-only）**：程序运行时不能修改。
    *   **共享**：多个相同的进程（例如同时运行多个文本编辑器）可以共享同一份代码段副本，以节省内存。
    *   大小在程序运行前就已确定。



## 数据段（Data Segment / Initialized Data Segment）

*   **存放内容**：存放**在编译期已初始化且初始值不为0**的**全局变量**和**静态（static）变量**。
    *   例如：`int global_var = 100;` （初始化的全局变量）
    *   例如：`static int static_var = 50;` （初始化的静态变量）
*   **特点**：
    *   这些变量在程序开始运行前就被赋予了初始值。
    *   大小在编译期就已确定。



## BSS段（Block Started by Symbol）

*   **存放内容**：存放**未初始化**或**初始化为0**的**全局变量**和**静态（static）变量**。
    *   例如：`int global_uninit_var;` （未初始化的全局变量）
    *   例如：`static int static_zero_var = 0;` （显式初始化为0的静态变量）
*   **特点**：
    *   操作系统在程序**加载时**会将整个BSS段清零。这就是为什么未初始化的全局变量默认值是0。
    *   大小在编译期就已确定。
*   **为什么要有BSS段？**：优化可执行文件大小。如果有很多未初始化的变量，在磁盘上的可执行文件中只需要记录这些变量的大小和总和，而不需要为每个为0的变量分配实际的磁盘空间。只有在程序运行时，才会在内存中为它们分配空间并清零。



## 堆（Heap）

*   **存放内容**：用于**动态内存分配**。当程序使用 `malloc()`, `calloc()`, `new` (C++) 等函数申请内存时，内存就从堆中分配。
*   **特点**：
    *   **手动管理**：内存的分配和释放完全由程序员控制。使用后必须用 `free()` 或 `delete` 释放，否则会导致**内存泄漏**。
    *   **生存期**：分配的内存会一直存在，直到被显式释放或程序结束。它的生命周期超越了函数调用的范围。
    *   **大小可变**：堆的大小在程序运行时可以动态增长（通过系统调用如 `sbrk()` 或 `mmap()` 向操作系统申请更多内存），只受限于计算机的虚拟内存总量。
    *   **分配速度**：相对较慢，因为需要处理复杂的内存管理算法（寻找空闲块、合并空闲块等）。
    *   **碎片化**：频繁的分配和释放不同大小的内存块会造成**内存碎片**。



## 栈（Stack）

*   **存放内容**：用于管理**函数调用**和**局部变量**。
    *   每次调用一个函数时，会在栈上分配一块称为“栈帧（Stack Frame）”的内存，用于存放：
        *   函数的**参数**
        *   函数的**局部变量**
        *   函数的返回地址（调用完以后回到哪里）
        *   调用者的上下文信息（如寄存器值）
*   **特点**：
    *   **自动管理**：由编译器自动分配和释放。函数开始时分配栈帧，函数结束时自动回收，无需程序员干预。
    *   **后进先出（LIFO）**：栈的操作顺序（压栈Push和弹栈Pop）是后进先出的，这完美契合了函数调用的顺序（最后被调用的函数最先返回）。
    *   **生存期**：局部变量的生存期仅限于其所在的函数执行期间。函数返回后，其栈帧被回收，局部变量也就失效了。
    *   **大小固定**：栈的大小通常是预先设置好的（例如Linux上默认为8MB）。如果栈空间耗尽（例如无限递归、过大的局部数组），会导致 **“栈溢出（Stack Overflow）”** 错误，程序会崩溃。
    *   **分配速度**：非常快，通常只需要移动栈指针（SP寄存器）。



## 总结对比表

| 内存区域   | 存放内容                     | 管理方式                   | 生命周期     | 大小 | 特点                   |
| :--------- | :--------------------------- | :------------------------- | :----------- | :--- | :--------------------- |
| **代码段** | 程序指令（代码）             | 操作系统                   | 整个程序     | 固定 | 只读、共享             |
| **数据段** | 已初始化的全局/静态变量      | 操作系统                   | 整个程序     | 固定 | 程序加载时已有初值     |
| **BSS段**  | 未初始化或为0的全局/静态变量 | 操作系统                   | 整个程序     | 固定 | 程序加载时被清零       |
| **堆**     | 动态分配的数据               | 程序员手动 (`malloc/free`) | 手动控制     | 可变 | 大、慢、易碎片化       |
| **栈**     | 函数参数、局部变量           | 编译器自动                 | 函数调用期间 | 固定 | 快、自动管理、大小有限 |

## 一个简单的例子（C语言）

```c
#include <stdio.h>
#include <stdlib.h>

int global_init = 10;    // 数据段
int global_uninit;       // BSS段
static int static_var;   // BSS段

void func(int param) {   // param：栈
    int local_var = 20;  // 栈
    static int static_local = 30; // 数据段（静态局部变量）

    char* dynamic_buf = (char*)malloc(100); // dynamic_buf指针本身在栈，但它指向的100字节在堆
    // ... 使用 dynamic_buf
    free(dynamic_buf);   // 释放堆内存
}

int main() {
    func(5);
    return 0;
}
```


