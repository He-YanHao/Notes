## 魔鬼数字（Magic Number）

**魔鬼数字**是指在代码中直接出现的、没有明确含义的数字字面量。这些数字没有通过有意义的命名来解释其用途，使得代码难以理解和维护。

## 魔鬼数字的示例

### 不好的代码（使用魔鬼数字）：
```c
// 示例1：难以理解的含义
if (status == 1) {
    process_data();
}

// 示例2：多个魔鬼数字
double area = 3.14159 * radius * radius;
int timeout = 5000;
int max_retries = 3;

// 示例3：复杂的条件判断
if (error_code == 404 || error_code == 408 || error_code == 503) {
    retry_request();
}
```

### 改进后的代码：
```c
// 定义有意义的常量
#define PI 3.14159
#define HTTP_NOT_FOUND 404
#define HTTP_REQUEST_TIMEOUT 408
#define HTTP_SERVICE_UNAVAILABLE 503
#define DEFAULT_TIMEOUT_MS 5000
#define MAX_RETRY_COUNT 3

// 使用枚举定义状态
typedef enum {
    STATUS_ACTIVE = 1,
    STATUS_INACTIVE = 0
} system_status_t;

// 改进后的代码
if (status == STATUS_ACTIVE) {
    process_data();
}

double area = PI * radius * radius;
int timeout = DEFAULT_TIMEOUT_MS;

if (error_code == HTTP_NOT_FOUND || 
    error_code == HTTP_REQUEST_TIMEOUT || 
    error_code == HTTP_SERVICE_UNAVAILABLE) {
    retry_request(MAX_RETRY_COUNT);
}
```

## 魔鬼数字的危害

1. **可读性差**：其他开发者需要猜测数字的含义
2. **维护困难**：修改时需要找到所有使用该数字的地方
3. **容易出错**：可能误改或漏改某些数字
4. **一致性难保**：相同的含义可能使用了不同的数字

## 处理规则详解

### 1. 局部使用的魔鬼数字
```c
// 方式1：增加注释
void calculate_bonus(double salary) {
    double bonus = salary * 0.15;  // 奖金比例为15%
    // ...
}

// 方式2：定义局部const变量（推荐）
void calculate_bonus(double salary) {
    const double BONUS_RATIO = 0.15;
    double bonus = salary * BONUS_RATIO;
    // ...
}
```

### 2. 广泛使用的魔鬼数字
```c
// 必须定义全局常量或宏
#define MAX_BUFFER_SIZE 1024
#define DEFAULT_PORT 8080
#define SUCCESS 0
#define FAILURE -1

const int MAX_USER_COUNT = 1000;
const double TAX_RATE = 0.08;
```

### 3. 0的特殊情况
```c
// 0作为默认值可以直接使用（无歧义时）
int initialize_system() {
    int error_count = 0;  // 可以直接使用0
    // ...
    return 0;  // 成功返回0是惯例
}

// 但如果0有特定业务含义，仍需定义
#define INVALID_USER_ID 0
#define UNKNOWN_STATUS 0

if (user_id == INVALID_USER_ID) {
    // 比 user_id == 0 更清晰
}
```

## 实际应用场景

### 网络编程：
```c
// 不好的写法
if (socket_fd < 0) {
    return -1;
}
setsockopt(sockfd, 1, 2, &flag, sizeof(int));

// 好的写法
#include <sys/socket.h>

if (socket_fd == INVALID_SOCKET) {
    return SOCKET_ERROR;
}
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int));
```

### 文件操作：
```c
// 不好的写法
FILE* file = fopen("data.txt", "r");
if (file == NULL) {
    return -1;
}

// 好的写法
#define FILE_OPEN_MODE_READ "r"
#define FILE_OPEN_ERROR NULL
#define OPERATION_FAILED -1

FILE* file = fopen("data.txt", FILE_OPEN_MODE_READ);
if (file == FILE_OPEN_ERROR) {
    return OPERATION_FAILED;
}
```

## 例外情况

某些情况下可以直接使用数字：
```c
// 数学计算中的自然常数
for (int i = 0; i < 10; i++) {  // 循环10次，含义明确
    // ...
}

// 数组索引操作
array[0] = first_element;  // 索引0是明确的

// 简单的计数器
int count = 0;  // 从0开始计数是惯例
```

## 总结

**魔鬼数字的核心问题**：数字本身没有表达其业务含义或物理意义。

**解决原则**：通过有意义的命名让数字"说话"，使代码自文档化，提高可读性和可维护性。