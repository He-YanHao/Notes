# 树 tree

## 树的基本描述

树（tree）是一种表达数据之间层次关系的数据结构，树中的每个节点有0个或多个子节点，但是只有一个父节点，父节点为空的节点就是根节点，一棵树只有一个根节点。

树结构的相关概念如下。

-   树的度：一个节点含有子树的个数称为该节点的度，一棵树中最大节点的度称为整棵树的度。
-   叶节点：度为0的节点称为叶节点。
-   根节点：没有父节点的节点就是根节点。
-   树的高度：从根节点开始，每多一级子节点，树的层次就+1，一棵树的最大层次数就是树的高度。
-   兄弟节点：具有相同父节点的子节点互称为兄弟节点



## 二叉树的C语言实现

### 头文件

```c
#include <stdio.h>  //基本输入输出
#include <stdlib.h> //动态内存分配
```



### 定义节点

```c
// 二叉树节点结构
typedef struct TreeNode {
    int data;              //数据域
    struct TreeNode* left; //左子节点指针
    struct TreeNode* right;//右子节点指针
} TreeNode;
```



### 创建节点

```c
// 创建新节点
TreeNode* createNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (newNode == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```



## 基本操作实现

### 1. 插入节点（二叉搜索树）

```c
// 二叉搜索树插入
TreeNode* insert(TreeNode* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    
    return root;
}
```

### 2. 遍历算法

```c
// 前序遍历
void preorderTraversal(TreeNode* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

// 中序遍历
void inorderTraversal(TreeNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// 后序遍历
void postorderTraversal(TreeNode* root) {
    if (root != NULL) {
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        printf("%d ", root->data);
    }
}

// 层次遍历（需要队列支持）
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    
    // 简单队列实现
    TreeNode* queue[100];
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    while (front < rear) {
        TreeNode* current = queue[front++];
        printf("%d ", current->data);
        
        if (current->left != NULL) {
            queue[rear++] = current->left;
        }
        if (current->right != NULL) {
            queue[rear++] = current->right;
        }
    }
}
```

### 3. 搜索节点

```c
// 二叉搜索树查找
TreeNode* search(TreeNode* root, int key) {
    if (root == NULL || root->data == key) {
        return root;
    }
    
    if (key < root->data) {
        return search(root->left, key);
    } else {
        return search(root->right, key);
    }
}
```

### 4. 计算树的高度

```c
// 计算树的高度
int treeHeight(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    
    int leftHeight = treeHeight(root->left);
    int rightHeight = treeHeight(root->right);
    
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}
```

### 5. 统计节点数量

```c
// 统计节点总数
int countNodes(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// 统计叶子节点数量
int countLeaves(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    
    if (root->left == NULL && root->right == NULL) {
        return 1;
    }
    
    return countLeaves(root->left) + countLeaves(root->right);
}
```

### 6. 删除节点

```c
// 找到最小值节点（用于删除操作）
TreeNode* findMin(TreeNode* root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

// 删除节点
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == NULL) return root;
    
    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到要删除的节点
        if (root->left == NULL) {
            TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp;
        }
        
        // 有两个子节点的情况
        TreeNode* temp = findMin(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
```

### 7. 释放整棵树

```c
// 释放树的内存
void freeTree(TreeNode* root) {
    if (root != NULL) {
        freeTree(root->left);
        freeTree(root->right);
        free(root);
    }
}
```

## 完整示例程序

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 所有函数实现如上...

int main() {
    TreeNode* root = NULL;
    
    // 插入节点
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);
    
    printf("中序遍历: ");
    inorderTraversal(root);
    printf("\n");
    
    printf("前序遍历: ");
    preorderTraversal(root);
    printf("\n");
    
    printf("层次遍历: ");
    levelOrderTraversal(root);
    printf("\n");
    
    printf("树的高度: %d\n", treeHeight(root));
    printf("节点总数: %d\n", countNodes(root));
    printf("叶子节点数: %d\n", countLeaves(root));
    
    // 搜索节点
    int searchKey = 40;
    TreeNode* found = search(root, searchKey);
    if (found != NULL) {
        printf("找到节点 %d\n", searchKey);
    } else {
        printf("未找到节点 %d\n", searchKey);
    }
    
    // 删除节点
    printf("删除节点 20\n");
    root = deleteNode(root, 20);
    printf("中序遍历: ");
    inorderTraversal(root);
    printf("\n");
    
    // 释放内存
    freeTree(root);
    
    return 0;
}
```

## 树的扩展类型

1. **二叉搜索树**：左子树所有节点值小于根节点，右子树所有节点值大于根节点
2. **平衡二叉树**：如AVL树、红黑树，保持树的高度平衡
3. **堆**：完全二叉树，用于优先队列
4. **B树**：多路搜索树，用于数据库和文件系统
5. **Trie树**：用于字符串检索

## 应用场景

- 文件系统目录结构
- 数据库索引
- 编译器语法分析
- 游戏决策树
- 网络路由表

这种实现提供了树的基本操作框架，可以根据具体需求进行扩展和优化。