# 环形缓冲区算法

环形缓冲区（Circular Buffer），也称为循环缓冲区或环形队列，是一种常用的数据结构，特别适用于数据流处理和缓存场景。

## 基本概念

### 什么是环形缓冲区？
环形缓冲区是一个固定大小的缓冲区，当数据填满后，新的数据会覆盖最旧的数据，形成一个循环使用的结构。

### 核心特点
- **固定大小**：预分配固定容量的内存
- **FIFO特性**：先进先出的数据访问模式
- **高效操作**：O(1)时间复杂度的插入和删除
- **内存友好**：避免频繁的内存分配和释放

## 数据结构设计

### 基本结构
```c
typedef struct {
    int *buffer;     // 缓冲区数组
    int capacity;    // 缓冲区容量
    int head;        // 写入位置（下一个可写位置）
    int tail;        // 读取位置（下一个可读位置）
    int count;       // 当前元素数量
} CircularBuffer;
```

### 初始化
```c
CircularBuffer* cb_create(int capacity) {
    CircularBuffer *cb = malloc(sizeof(CircularBuffer));
    cb->buffer = malloc(capacity * sizeof(int));
    cb->capacity = capacity;
    cb->head = 0;
    cb->tail = 0;
    cb->count = 0;
    return cb;
}
```

## 基本操作

### 1. 判断缓冲区状态
```c
int cb_is_empty(CircularBuffer *cb) {
    return cb->count == 0;
}

int cb_is_full(CircularBuffer *cb) {
    return cb->count == cb->capacity;
}

int cb_size(CircularBuffer *cb) {
    return cb->count;
}
```

### 2. 写入数据
```c
int cb_write(CircularBuffer *cb, int data) {
    if (cb_is_full(cb)) {
        // 缓冲区已满，可以选择覆盖或返回错误
        return 0; // 写入失败
    }
    
    cb->buffer[cb->head] = data;
    cb->head = (cb->head + 1) % cb->capacity;
    cb->count++;
    return 1; // 写入成功
}
```

### 3. 读取数据
```c
int cb_read(CircularBuffer *cb, int *data) {
    if (cb_is_empty(cb)) {
        return 0; // 读取失败
    }
    
    *data = cb->buffer[cb->tail];
    cb->tail = (cb->tail + 1) % cb->capacity;
    cb->count--;
    return 1; // 读取成功
}
```

## 完整实现示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int *buffer;
    int capacity;
    int head;
    int tail;
    int count;
} CircularBuffer;

// 创建环形缓冲区
CircularBuffer* cb_create(int capacity) {
    CircularBuffer *cb = malloc(sizeof(CircularBuffer));
    cb->buffer = malloc(capacity * sizeof(int));
    cb->capacity = capacity;
    cb->head = 0;
    cb->tail = 0;
    cb->count = 0;
    return cb;
}

// 销毁环形缓冲区
void cb_destroy(CircularBuffer *cb) {
    free(cb->buffer);
    free(cb);
}

// 检查是否为空
bool cb_is_empty(CircularBuffer *cb) {
    return cb->count == 0;
}

// 检查是否已满
bool cb_is_full(CircularBuffer *cb) {
    return cb->count == cb->capacity;
}

// 获取元素数量
int cb_size(CircularBuffer *cb) {
    return cb->count;
}

// 写入数据（不覆盖）
bool cb_write(CircularBuffer *cb, int data) {
    if (cb_is_full(cb)) {
        return false;
    }
    
    cb->buffer[cb->head] = data;
    cb->head = (cb->head + 1) % cb->capacity;
    cb->count++;
    return true;
}

// 读取数据
bool cb_read(CircularBuffer *cb, int *data) {
    if (cb_is_empty(cb)) {
        return false;
    }
    
    *data = cb->buffer[cb->tail];
    cb->tail = (cb->tail + 1) % cb->capacity;
    cb->count--;
    return true;
}

// 查看但不移除头部元素
bool cb_peek(CircularBuffer *cb, int *data) {
    if (cb_is_empty(cb)) {
        return false;
    }
    
    *data = cb->buffer[cb->tail];
    return true;
}

// 打印缓冲区内容（用于调试）
void cb_print(CircularBuffer *cb) {
    printf("Buffer [");
    if (!cb_is_empty(cb)) {
        int index = cb->tail;
        for (int i = 0; i < cb->count; i++) {
            printf("%d", cb->buffer[index]);
            if (i < cb->count - 1) printf(", ");
            index = (index + 1) % cb->capacity;
        }
    }
    printf("] (head=%d, tail=%d, count=%d/%d)\n", 
           cb->head, cb->tail, cb->count, cb->capacity);
}

// 测试示例
int main() {
    CircularBuffer *cb = cb_create(5);
    
    printf("初始状态: ");
    cb_print(cb);
    
    // 写入数据
    for (int i = 1; i <= 6; i++) {
        if (cb_write(cb, i * 10)) {
            printf("写入 %d: ", i * 10);
            cb_print(cb);
        } else {
            printf("写入失败 %d (缓冲区已满)\n", i * 10);
        }
    }
    
    // 读取数据
    int data;
    while (cb_read(cb, &data)) {
        printf("读取 %d: ", data);
        cb_print(cb);
    }
    
    // 再次写入和读取
    cb_write(cb, 100);
    cb_write(cb, 200);
    printf("写入后: ");
    cb_print(cb);
    
    cb_read(cb, &data);
    printf("读取 %d 后: ", data);
    cb_print(cb);
    
    cb_destroy(cb);
    return 0;
}
```

## 高级特性

### 1. 覆盖写入模式
```c
// 强制写入（覆盖最旧数据）
void cb_force_write(CircularBuffer *cb, int data) {
    cb->buffer[cb->head] = data;
    cb->head = (cb->head + 1) % cb->capacity;
    
    if (cb_is_full(cb)) {
        // 如果已满，移动tail指针（覆盖最旧数据）
        cb->tail = (cb->tail + 1) % cb->capacity;
    } else {
        cb->count++;
    }
}
```

### 2. 批量操作
```c
// 批量写入
int cb_write_batch(CircularBuffer *cb, int *data, int size) {
    int written = 0;
    for (int i = 0; i < size; i++) {
        if (cb_write(cb, data[i])) {
            written++;
        } else {
            break;
        }
    }
    return written;
}

// 批量读取
int cb_read_batch(CircularBuffer *cb, int *data, int size) {
    int read = 0;
    for (int i = 0; i < size; i++) {
        if (cb_read(cb, &data[i])) {
            read++;
        } else {
            break;
        }
    }
    return read;
}
```

## 应用场景

### 1. 数据流处理
```c
// 实时数据采样缓冲区
#define SAMPLE_BUFFER_SIZE 1000
CircularBuffer *sample_buffer = cb_create(SAMPLE_BUFFER_SIZE);

// 添加新采样数据
void add_sample(int sample) {
    cb_force_write(sample_buffer, sample); // 覆盖旧数据
}

// 处理最近的N个采样
void process_recent_samples(int n) {
    int samples[n];
    // 注意：这里需要特殊处理，因为环形缓冲区可能不包含连续的n个数据
    // 实际应用中可能需要更复杂的逻辑
}
```

### 2. 命令队列
```c
// 多线程环境中的命令缓冲区
CircularBuffer *command_buffer = cb_create(100);

// 生产者线程：添加命令
void produce_command(int command) {
    while (!cb_write(command_buffer, command)) {
        // 缓冲区满，等待或处理
        usleep(1000); // 短暂等待
    }
}

// 消费者线程：处理命令
void consume_commands() {
    int command;
    while (cb_read(command_buffer, &command)) {
        execute_command(command);
    }
}
```

### 3. 网络数据包缓冲
```c
// 网络数据包缓冲区
typedef struct {
    char *data;
    int size;
} Packet;

CircularBuffer *packet_buffer = cb_create(50); // 存储50个数据包

void buffer_packet(char *data, int size) {
    Packet pkt;
    pkt.data = malloc(size);
    pkt.size = size;
    memcpy(pkt.data, data, size);
    
    if (!cb_write(packet_buffer, (int)&pkt)) { // 注意：这里简化了类型转换
        free(pkt.data); // 缓冲区满，丢弃数据包
    }
}
```

## 注意事项

1. **线程安全**：在多线程环境中使用需要加锁
2. **内存管理**：如果存储指针，需要妥善管理内存
3. **边界条件**：仔细处理空和满的状态
4. **性能考虑**：模运算可以用位运算优化（当容量是2的幂时）

环形缓冲区是嵌入式系统、实时系统和数据流处理中非常重要的数据结构，掌握它对于处理连续数据流非常有用。