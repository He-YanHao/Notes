这段话系统地介绍了**图（Graph）** 这种重要的数据结构。让我为您详细解析其中的核心概念：

## 图的基本概念

### 什么是图？
图是由**顶点（Vertex）** 和**边（Edge）** 组成的数据结构：
- **顶点**：表示数据元素（对象）
- **边**：表示数据元素之间的关系

## 图的分类方式

### 1. 按边的方向性
- **有向图**：边有方向（如A→B）
- **无向图**：边没有方向（如A-B）

### 2. 按边的数量
- **简单图**：任意两个顶点之间最多只有一条边
- **多重图**：允许两个顶点之间有多条边

### 3. 按连通性
- **连通图**：任意两个顶点之间都有路径相连
- **非连通图**：存在不相连的顶点

### 4. 按边的权重
- **带权图**：边有权重（如距离、成本）
- **不带权图**：边没有权重

## 图的数学定义

### 二元组定义
```
G = (V, E)
```
- V(G)：顶点集合
- E(G)：边集合

### 三元组定义
```
G = (V, E, I)
```
- I：关联函数，将每条边映射到两个顶点
- I(e) = (u, v)，其中u,v ∈ V(G)

## 图的存储结构

### 1. 邻接矩阵
```c
// 使用二维数组表示
int graph[MAX_VERTEX][MAX_VERTEX];

// 示例：无向图的邻接矩阵
//    A  B  C  D
// A  0  1  1  0
// B  1  0  1  1  
// C  1  1  0  0
// D  0  1  0  0
```

**优点**：
- 快速判断两个顶点是否相邻
- 适合稠密图

**缺点**：
- 空间复杂度高（O(n²)）
- 存储稀疏图时浪费空间

### 2. 邻接表
```c
// 使用链表或动态数组
struct Node {
    int vertex;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};
```

**优点**：
- 空间效率高（O(V+E)）
- 适合稀疏图

**缺点**：
- 判断两个顶点是否相邻较慢

### 3. 十字链表（有向图专用）
结合邻接表和逆邻接表的优点，同时记录出边和入边。

## 图的遍历算法

### 深度优先搜索（DFS）
**核心思想**："一条路走到黑，不行再回头"

**算法过程**：
1. 从起始顶点v开始访问
2. 选择v的一个未访问邻接顶点vi访问
3. 从vi继续深度优先遍历
4. 如果vi的所有邻接顶点都已访问，回溯到v
5. 重复直到所有顶点都被访问

**递归实现**：
```c
void DFS(int v, bool visited[], Graph* graph) {
    // 标记当前顶点为已访问
    visited[v] = true;
    printf("%d ", v);
    
    // 递归访问所有未访问的邻接顶点
    Node* temp = graph->adjLists[v];
    while (temp != NULL) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            DFS(adjVertex, visited, graph);
        }
        temp = temp->next;
    }
}
```

**非递归实现（使用栈）**：
```c
void DFS_Iterative(int start, Graph* graph) {
    bool visited[MAX_VERTEX] = {false};
    int stack[MAX_VERTEX];
    int top = -1;
    
    // 起始顶点入栈
    stack[++top] = start;
    visited[start] = true;
    
    while (top >= 0) {
        // 出栈并访问
        int current = stack[top--];
        printf("%d ", current);
        
        // 将所有未访问的邻接顶点入栈
        Node* temp = graph->adjLists[current];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = true;
                stack[++top] = adjVertex;
            }
            temp = temp->next;
        }
    }
}
```

### 广度优先搜索（BFS）
**核心思想**："层层推进，先近后远"

**算法过程**：
1. 从起始顶点开始，先访问所有直接邻接顶点
2. 再访问这些邻接顶点的邻接顶点
3. 使用队列来维护访问顺序

**实现**：
```c
void BFS(int start, Graph* graph) {
    bool visited[MAX_VERTEX] = {false};
    int queue[MAX_VERTEX];
    int front = 0, rear = 0;
    
    // 起始顶点入队
    queue[rear++] = start;
    visited[start] = true;
    
    while (front < rear) {
        // 出队并访问
        int current = queue[front++];
        printf("%d ", current);
        
        // 将所有未访问的邻接顶点入队
        Node* temp = graph->adjLists[current];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = true;
                queue[rear++] = adjVertex;
            }
            temp = temp->next;
        }
    }
}
```

## 应用场景

- **社交网络**：用户关系图
- **交通网络**：道路连接图
- **网络路由**：路由器连接图
- **任务调度**：依赖关系图
- **推荐系统**：物品关联图

## 总结

这段话全面介绍了图论的基础知识，从基本定义到分类方法，再到存储结构和遍历算法，为理解和应用图这种强大的数据结构奠定了坚实的理论基础。图的遍历算法（特别是DFS和BFS）是解决许多复杂问题的基础工具。