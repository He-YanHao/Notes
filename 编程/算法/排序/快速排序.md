# 快速排序

用到了递归思想，分而治之。



```c
// 随机选择基准并分区（避免最坏情况）
int partition(int arr[], int low, int high)//
{
    srand(time(NULL));
    // 随机选择基准（避免最坏时间复杂度）
    int random_idx = low + rand() % (high - low + 1);//让基准在低元素和高元素之间随机生成
    //random_idx 基准
    //low 低元素
    //high 高元素
    swap(&arr[random_idx], &arr[high]);//交换基准和高元素
    int pivot = arr[high];  // 基准值
    int i = low - 1;        // 小于基准的边界指针
    for (int j = low; j < high; j++)
    {
        if (arr[j] <= pivot)//小于基准值的
        {
            i++;
            swap(&arr[i], &arr[j]);//和基准值交换
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return i + 1;  //返回基准最终位置
}

// 快速排序主函数
void quickSort(int arr[], int low, int high)
{
    if (low < high)//只高元素大于低元素就执行排序
    {
        // 获取基准位置
        int pi = partition(arr, low, high);//
        // 递归排序子数组
        quickSort(arr, low, pi - 1);  // 左半部分小于基准
        quickSort(arr, pi + 1, high); // 右半部分大于基准
    }
}
```

```
初始状态：
索引: 0  1  2  3  4
数值: 3, 2, 5, 1, 4  (pivot=4)

分区过程：
j=0: 3<=4 → i=-1→0 → 交换arr[0]和arr[0] → [3],2,5,1,4
j=1: 2<=4 → i=0→1  → 交换arr[1]和arr[1] → 3,[2],5,1,4
j=2: 5>4  → 无操作
j=3: 1<=4 → i=1→2  → 交换arr[2]和arr[3] → 3,2,[1],5,4

循环结束：
小于区: [3,2,1] → 结束位置i=2
执行关键交换：swap(&arr[3], &arr[4])
结果：3,2,1,[4],5 
```

- 大于排在右边

    ```
    初始状态：
    索引: 0  1  2  3  4
    数值: 1, 3, 2, 5, 4  (pivot=1)
    
    
    ```

    

- 小于排在左边

- 

