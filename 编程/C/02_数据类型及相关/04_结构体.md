# 结构体struct

## 创建结构体struct

使用`struct`命令创建结构体类型，具体流程为：

```c
struct 结构体类型名
{
成员数据类型1 成员名1;//声明其数据类型
成员数据类型2 成员名2;
···   ···;
};
```

然后通过：

```c
struct 结构体类型名 申请结构体数据的名称;
```

申请结构体并初始化。

或者使用`struct`命令和`typedef`命令共同创造结构体：

```c
typedef struct 结构体类型原名称
{
成员数据类型1 成员名1;//声明其数据类型
成员数据类型2 成员名2;
···   ···;
} 结构体类型简化名称;
```

这样可以省略struct，直接

```c
结构体类型简化名称 申请结构体数据的名称;
//C语言无 typedef 不可以不带 struct，C++可以。
```

也可以通过下面这种方式直接创建结构体类型和申请结构体一步到位：

```c
struct 结构体类型名
{
成员数据类型1 成员名1;//声明其数据类型
成员数据类型2 成员名2;
···   ···;
} 申请结构体数据的名称;
```

按旧版规则，若是按此种方式申请的结构体无法通过正常方式再次申请相同类型结构体，但新版可以。





## 结构体成员及初始化

```c
//结构体成员为：
申请结构体数据的名称.成员名1 = {};
申请结构体数据的名称.成员名2 = {};
//或者这样初始化
申请结构体数据的名称 = { , , };
```



## 结构体对齐

假设有这样一个结构体：

```c
struct DefaultAlign {
    char a;      // 1字节
    double c;    // 8字节
    int b;       // 4字节
};
```

看上去是 $1+8+4=13$ 字节，但实际上会进行填充。

填充规则如下：

-   **成员自身对齐**：每个成员的起始地址必须是其**类型大小**的整数倍。
-   **结构体整体对齐**：结构体的总大小必须是其**最大基本类型成员**大小的整数倍。

```c
struct DefaultAlign {
    char a;      // 起始地址 0
    // 填充七个字节
    double c;    // 起始地址 8
    int b;       // 起始地址 16
    // 现在大小是 20 字节 不是 double类型的大小 8 的整数倍，填充 4 字节。
};
```



## 位域

如果一个变量仅储存开或关，也就是 0 或 1 ，那么就算是使用 char 也是浪费的。这是可以使用位域操作。

```c
struct 位域结构名
{
	type [member_name] : width ;
}；
```

| 元素        | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| type        | 只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。 |
| member_name | 位域的名称。                                                 |
| width       | 位域中位的数量。宽度必须小于或等于指定类型的位宽度。         |

与结构体类似，但其成员会被指定位数，若空间足够，则会被存储到同一个变量的不同的位里。

如果变量仅剩下三位，但要存储一个四位的位域值，会弃置这三位另起一个新的变量。可以用下面的方式强制新启用变量：

```c
struct bs{
    unsigned a:4;
    unsigned  :4;    /* 空域 */
    unsigned b:4;    /* 从下一单元开始存放 */
    unsigned c:4
}
```

由于使用了结构体关键字，位域自然是结构体的一种，符合结构体的性质。

