# 存储类

## 内存分段

计算机内存被分为不同的“段”（Segment），每个段有不同的管理方式和用途：

| 内存段             | 用途                                                         |
| :----------------- | :----------------------------------------------------------- |
| **栈（Stack）**    | 存储局部变量、函数参数、返回地址等，由系统自动管理（先进后出） |
| **堆（Heap）**     | 动态分配的内存（如 `malloc` / `new`），需手动管理            |
| **数据段（Data）** | 存储显式初始化为非零的全局变量和静态变量（已初始化数据区）   |
| **BSS 段**         | 存储未初始化或显式初始化为0的全局变量和静态变量（未初始化数据区） |
| **代码段（Text）** | 存储程序代码（机器指令），通常只读                           |

“存储类”在这里指的是变量被分配在哪个内存段，而不是 C/C++ 语言中的 `static`、`auto` 等关键字。

它描述了变量的**内存位置和生命周期**。



## 变量类型与存储位置的对应关系

### 局部变量 → 栈（Stack）**

```c
void func() {
    int x = 10;  // x 在栈上分配
}
```

**特点**：函数调用时分配，函数返回时自动释放。



### 显式初始化为非零的全局变量 → 数据段（Data）

```c
int global = 100;  // 在数据段（Data）
```

**特点**：程序启动时分配，程序结束时释放，初始值存储在可执行文件中。



### 未初始化或初始化为0的全局变量/静态变量 → BSS 段

```c
int zero_global = 0;      // 在 BSS 段
int uninit_global;        // 默认初始化为0，也在 BSS 段
static int static_var;    // 同上
```

**特点**：程序启动时分配并自动清零，不占用可执行文件空间（只记录大小）。



### 动态分配的内存 → 堆（Heap）

```c
int *p = (int*)malloc(sizeof(int));  // 在堆上分配
```

**特点**：手动管理（需 `free` / `delete`），生命周期由程序员控制。



### 常量、代码 → 代码段/只读数据段

```c
const char *str = "Hello";  // 字符串字面量可能在只读数据段
```



## 总结

嵌入式系统或特殊架构可能没有严格区分上述分段，但通用操作系统（如 Linux、Windows）通常遵循此模型。

变量的存储类取决于它被分配在哪个内存段（栈、堆、Data、BSS 等），而内存段的选择由变量的类型（局部/全局/静态）、初始化方式以及编译器的内存管理策略共同决定。







```Mermaid
flowchart TD
    P["进程虚拟地址空间"]
    
    P --> KernelSpace["内核空间（高位）"]
    P --> UserSpace["用户空间（低位）"]

    UserSpace --> Stack["栈"]
    UserSpace --> MMAP["内存映射区<br>（共享库、mmap 等）"]
    UserSpace --> Heap["堆（向上增长）"]
    UserSpace --> BSS["BSS 段<br>（未初始化/零初始化全局/静态变量）"]
    UserSpace --> Data["数据段<br>（已初始化全局/静态变量）"]
    UserSpace --> Text["代码段（只读）<br>（机器指令、常量字符串）"]
    
    %% 方向说明
    direction["栈向低地址增长<br>堆向高地址增长"]:::noteStyle

    classDef noteStyle fill:#f9f,stroke:#333,stroke-width:1px,color:#000
```

下面详细解释图中的各个部分：

------

### **1. 内核空间**

-   **位置**：虚拟地址空间的**高地址部分**（如 `0xC0000000` 以上，32位系统）。
-   **内容**：操作系统内核代码和数据。
-   **权限**：用户态程序**不可访问**（触发段错误）。仅在进程执行系统调用陷入内核态时才能访问。

------

### **2. 用户空间**

#### **（1）代码段 / Text Segment**

-   **存放内容**：
    -   编译后的**机器指令**。
    -   **只读数据**：如字符串字面量（`"Hello"`）、`const` 全局变量（可能）。
-   **权限**：只读、可执行。
-   **特点**：
    -   在多个运行同一程序的进程间**可共享**。
    -   对应 ELF 文件中的 `.text` 和 `.rodata` 节。

#### **（2）数据段 / Data Segment**

-   **组成**：

    -   **`.data` 段**：已**显式初始化且非零**的全局变量和静态变量。

        c

        ```
        int global_init = 100;    // 进入 .data
        static int static_init = 1; // 进入 .data
        ```

        

    -   **`.bss` 段**：**未初始化或显式初始化为 0** 的全局变量和静态变量。

        c

        ```
        int global_zero = 0;      // 进入 .bss
        static int static_uninit; // 默认为0，进入 .bss
        ```

        

-   **权限**：可读写，不可执行。

-   **特点**：

    -   `.data` 的内容在可执行文件中占用空间，加载时直接映射。
    -   `.bss` 的内容在文件中**只记录大小**，加载时由系统初始化为零，节省磁盘空间。
    -   从低地址到高地址通常顺序为：`.data` → `.bss`。

#### **（3）堆 / Heap**

-   **位置**：紧接在 `.bss` 段之后，向**高地址**增长。
-   **管理**：通过 `brk()`/`sbrk()` 系统调用调整堆顶指针，或通过 `mmap()` 分配大块内存。
-   **分配函数**：`malloc()`、`calloc()`、`realloc()`。
-   **特点**：
    -   手动管理，需要 `free()` 避免内存泄漏。
    -   频繁分配/释放会产生碎片。

#### **（4）内存映射区 / Memory Mapping Segment**

-   **位置**：位于堆和栈之间的大片区域。
-   **用途**：
    -   动态链接库（如 `libc.so`）的加载地址。
    -   通过 `mmap()` 系统调用创建的文件映射或匿名映射。
    -   较大的 `malloc()` 请求可能直接用 `mmap()` 分配在此区域。
-   **特点**：灵活、可共享、可按需调页。

#### **（5）栈 / Stack**

-   **位置**：用户空间的**最高地址**附近，向**低地址**增长。
-   **内容**：
    -   局部变量（非静态）。
    -   函数调用信息：返回地址、参数、保存的寄存器。
    -   临时数据。
-   **管理**：由内核自动维护栈指针（`SP`）。
-   **特点**：
    -   后进先出（LIFO），与函数调用/返回完美匹配。
    -   大小有限（通常 8 MB，可用 `ulimit -s` 查看），溢出导致“栈溢出”。

#### **（6）其他区域（未在图中标出）**

-   **环境变量和参数**：位于栈的更低地址处，存放 `argv` 和 `envp`。
-   **vdso / vsyscall**：内核提供的快速系统调用入口，通常位于栈附近。

------

### **3. 如何查看内存映像？**

-   **编译时**：`size` 命令查看可执行文件的段大小。

    bash

    ```
    size a.out
    ```

    

    显示 `text`、`data`、`bss` 的字节数。

-   **运行时**：查看 `/proc/<pid>/maps`。

    bash

    ```
    cat /proc/self/maps  # 查看 cat 命令自身的内存映射
    ```

    

    显示进程所有内存区域的地址范围、权限、映射文件等。

------

### **4. 示例代码与映射**



```c
#include <stdio.h>
#include <stdlib.h>

int global_data = 100;          // .data 段
int global_bss;                 // .bss 段
static int static_data = 200;   // .data 段
static int static_bss;          // .bss 段
const int global_ro = 300;      // 可能 .rodata 段（只读）

int main() {
    int local_stack = 400;      // 栈
    static int local_static = 0;// .bss 段（初始化为0）
    char *heap_ptr = malloc(100); // 指针在栈，指向堆内存
    const char *ro_str = "Hello"; // 指针在栈，字符串在 .rodata

    printf("pid = %d\n", getpid());
    while(1); // 保持进程运行，方便查看 /proc/pid/maps
    return 0;
}
```



------

### **5. 关键特点总结**

1.  **地址空间布局随机化**：现代 Linux 默认启用 ASLR，栈、堆、库的地址在每次运行时随机化，增加安全性。
2.  **按需调页**：内存区域开始时可能没有分配物理页，首次访问时触发缺页异常，由内核分配。
3.  **共享库**：多个进程可共享同一库的代码段（`.text`），节省内存。
4.  **段权限**：代码段不可写（防攻击），数据段不可执行（防溢出代码执行）。

理解 Linux 的内存映像对于**调试内存错误、理解程序性能、进行安全分析**至关重要。