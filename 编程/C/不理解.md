===
5.下面算法中可以判断出一个有向图是否有环的是(BD)[多选]
A.求短路径
B.深度优先遍历
C.广度优先遍历
D.拓扑排序
分析：判断无向图 中是否存在回路（环）的算法描述
如果存在回路，则必存在一个子图，是一个环路。环路中所有顶点的度>=2。
算法：
第一步：删除所有度<=1的顶点及相关的边，并将另外与这些边相关的其它顶点的度减一。
第二步：将度数变为1的顶点排入队列，并从该队列中取出一个顶点重复步骤一。
如果最后还有未删除顶点，则存在环，否则没有环。
有向图是否有环的判定算法，主要有深度优先和拓扑排序两种方法。
权重：中

====
15.线性表(a1,a2,…,an)以链接方式存储时,访问第i位置元素的时间复杂性为©
A O(i)
B O(1)
C O(n)
D O(i-1)
权重：中

====
17.对一个含有20个元素的有序数组做二分查找，数组起始下标为1，则查找A[2]的比较序列的下标为(B)

A 9,5,4,2
B 10,5,3,2
C 9,6,2
D 20,10,5,3,2
解析：
(high-low)/2+low = middle; 下标从1开始，因为查找查找A[2]， low始终为1；
20-1）/2+1=10;
(10-1)/2+1 = 5;
(5-1)/2+1 = 3;
(3-1)/2+1 = 2;
权重：中

====
25.以下()属于线性分类器佳准则?（ACD）【多选】
A 感知准则函数
B 贝叶斯分类
C 支持向量机
D Fisher准则
权重：较低

====
1、写出两个排序算法，并说明哪个好?
答：一般使用冒泡法和快速排序法，对堆栈局域比较小的单片机来说冒泡法比较好，对时间要求苛刻的实时响应来说快速排序法好。
题注：时间复杂度：一个算法花费的时间与算法中语句的执行次数成正比例，用T(n)表示，n为问题的规模，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。
本题中，最坏的情况要计算9+8+7+6+5+4+3+2+1次，即n的级数，结果为n（n/2）=n2/2。所以冒泡法时间复杂度O（n2）
1） 冒泡法：从小到大排，时间复杂度On2
#define MAX_NUM 10
int a_data[MAX_NUM]={1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; // 也可以用scanf获取
int main(void)
{
    int i=0, j=0, tmp=0;
    for(i=0; i<MAX_NUM-1; i++) {
        for(j=i+1; j<MAX_NUM; j++) {
            if(a_data[i] > a_data[j]) { // 如果i不是小于j，则调换
                tmp = a_data[i];
                a_data[i] = a_data[j];
                a_data[j] = tmp;
            }
        }
    }
    return 0;
}

2）交换排序-快速排序，类似于二分法：采用递归。选第一个点或中间的点，左边放最小值，右边放最大值，依次递归到最低层的两个元素。因为每递归一次要压栈一次，占用存储空间，所以空间复杂度较高。时间复杂度Onlog2n
#define MAX_NUM 16
int a_data[MAX_NUM]={1, 2, 3, 4, 5, 6, 7, 8, 9, 0,11,12,13,14,15,16}; // 也可以用scanf获取
//快速排序  
void quick_sort(int s[], int l, int r)
{
	if (l < r)
	{
		//Swap(s[l], s[(l + r) / 2]); // 将中间的这个数和第一个数交换 可换可不换  
		int i = l, j = r, x = s[l]; // s[l]会先被替换，最后这个值会被写回到s[i]，它们也充当了临时变量的角色
		while (i < j)
		{
			while (i < j && s[j] >= x) // 从右向左找第一个小于x的数  
				j--;
			if (i < j)
				s[i++] = s[j];

			while (i < j && s[i] < x) // 从左向右找第一个大于等于x的数  
				i++;
			if (i < j)
				s[j--] = s[i];
		}
		s[i] = x;
		quick_sort(s, l, i - 1); // 递归调用   
		quick_sort(s, i + 1, r);
	}

}
int main(void)
{
    sort(a_data, 0, MAX_NUM - 1);
}
权重：高

====
21、可重入函数的条件有哪些？
答：主要用于多任务环境中，可被中断。除了自己栈上的变量外不调用全局变量（即便少量使用也要用同步与互斥进行保护）；不能调用malloc和free；操作硬件时屏蔽硬件中断，操作完成后释放硬件中断。

====
1、将一整数逆序后放入一数组中（要求递归实现）
void convert(int *result, int n) {
     if(n>=10)
         convert(result+1, n/10);
     *result = n%10; 
}

int main(int argc, char* argv[]) {
     int n = 123456789, result[20]={};
     convert(result, n);
     printf("%d:", n);
     for(int i=0; i<9; i++)
         printf("%d", result[i]);
}
权重：中

====
2、求高于平均分的学生学号及成绩（学号和成绩人工输入）
答：
double find(int total, int n) {
     int number, score,  average;
     scanf("%d", &number);
     if(number != 0) {
         scanf("%d", &score);
         average = find(total+score, n+1);
         if(score >= average)
              printf("%d:%d\n", number, score);
         return average;
     } else {
         printf("Average=%d\n", total/n);
         return total/n;
     }
}
int main(int argc, char* argv[]) {
     find(0, 0);
}
权重：中

====
3、递归实现回文判断（如：abcdedbca就是回文，判断一个面试者对递归理解的简单程序）
int find(char *str, int n) {
     if(n<=1) return 1;
     else if(str[0]==str[n-1])   return find(str+1, n-2);
     else     return 0;
}
int main(int argc, char* argv[]) {
     char *str = "abcdedcba";
     printf("%s: %s\n", str, find(str, strlen(str)) ? "Yes" : "No");
}
权重：较高

====
8.冒泡排序算法的时间复杂度是什么？
      时间复杂度是O(n^2)。
权重：中

====
2.数组a[N]，存放了1至N-1个数，其中某个数重复一次。写一个函数，找出被重复的数字.时间复杂度必须为o（N）函数原型：
int do_dup(int a[],int N)
答
算法思想：先对1..N-1之间的所有整数累加求和，再对数组中的所有元素累加求和；用后者减去前者得到的差就是重复的数字。
参考源代码(C++)：
#include "iostream.h"

void main()
{
    int arr[] = {6, 2, 3, 4, 3, 5, 1};
    int N = 7;
    int sum1, sum2;
    int i;

    for(i=1,sum1=0; i<N; sum1+=i,i++);
    for(i=0,sum2=0; i<N; sum2+=arr[i],i++);
    cout<<"重复的数字是 "<<sum2-sum1<<endl;

}
时间复杂度：O（n）
算法特点：对于数组中数值的出现顺序不做任何要求，即无需有序（这是二楼算法的缺陷）。
权重：中

====
2.写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。函数接口为：int find_orderk(const int* narry,const int n,const int k) 
要求算法复杂度不能是O(n^2）
答：
    可以先用快速排序进行排序，其中用另外一个进行地址查找
代码如下，在VC++6.0运行通过。
//快速排序
#include <iostream>
using namespace std;
int Partition (int *L, int low, int high)
{
    int temp = L[low];
    int pt = L[low];

    while (low < high)
    {
        while (low < high && L[high] >= pt)
            --high;
        L[low] = L[high];
        while (low < high && L[low] <= pt)
            ++low;
        L[low] = temp;
    }
    L[low] = temp;
    
    return low;

}

void QSort (int*L, intlow, int high)
{
    if (low < high)
    {
        int pl = Partition (L, low, high);

        QSort (L, low, pl - 1);
        QSort (L, pl + 1, high);
    }

}

int main()
{
    int narry[100], addr[100];
    int sum = 1, t;

    cout << "Input number:" << endl;
    cin >> t;
    
    while (t != -1)
    {
        narry[sum] = t;
        addr[sum - 1] = t;
        sum++;
    
        cin >> t;
    }
    
    sum -= 1;
    QSort (narry,1,sum);
    
    for (int i = 1; i <= sum;i++)
        cout << narry[i] << '\t';
    cout << endl;
    
    int k;
    cout << "Please input place you want:" << endl;
    cin >> k;
    
    int aa = 1;
    int kk = 0;
    for (;;)
    {
        if (aa == k)
            break;
        if (narry[kk] != narry[kk + 1])
        {
            aa += 1;
            kk++;
        }
    }
    
    cout << "The NO." << k << "number is:" << narry[sum - kk] << endl;
    cout << "And it's place is:" ;
    for (i = 0; i < sum; i++)
    {
    if (addr[i] == narry[sum - kk])
        cout << i << '\t';
    }
    
    return 0;

}
权重：较高

====
3、用递归算法判断数组a[N]是否为一个递增数组。
答：
递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false结束：
bool fun( int a[], int n )
{
    if( n == 1 )
    return true;
    if( n == 2 )
    return a[n-1] >= a[n-2];
    return fun(a, n-1) && ( a[n-1] >= a[n-2] );
}
权重：较高
备注：嵌入式使用递归要特别注意，事先预估好可能的递归次数，每次函数压栈时占用的空间，不要堆栈溢出了

====
5 设周期性任务P1,P2,P3的周期为T1,T2,T3分别为100，150，400；执行时间分别为20，40，100。请设计一种调度算法进行任务调度，满足任务执行周期及任务周期。
答：

1.  任务当然可以分段执行，不然P3执行时间100大于P1最大的间隔时间80（100-20，即从P1本次执行完毕到下次开始执行的间隔），无论如何都不可能。
2.  整个调度是可以循环的，即我们假设在一个时间轴上安排了一系列的任务运行，时间轴在某时刻与0时刻重合，这样就可以一直进行下去
    权重：中



====
23.设fp已定义,执行语句fp=fopen(“file”,“w”);后,以下针对文本文件file操作叙述的选项错误的是:（ACD）【多选】
A 可以随意读和写
B 只能写不能读
C 可以在原有内容后追加写
D 写操作结束后可以从头开始读
权重：高
备注：还要理解r w r+ w+ rw等参数的含义

====
b) 在ARM系统中，函数调用的时候，参数是通过哪种方式传递的?
参数<=4时候，通过R0~R3传递，>4的通过压栈方式传递
权重：中

====
2、打开一个文件，并读取从第100字节开始的50字节数据。
答：
#include <stdio.h> // C库标准文件操作
#define FILE_PATH “test.txt”
char a_buf[50] = {0};
int main(void)
{
    FILE *p_fd = fopen(FILE_PATH, “rb”); // 只读打开文件
    if (p_fd == NULL) {
        return -1;
    }
    rewind(p_fd); // 读写位置重置到开头
    // fseek(p_fd, 0, SEEK_END); // （以文件尾为基准偏移0字节）将文件内部指针放到文件最后面，便于获取文件总长度
    // length = ftell(p_fd); // 读取文件指针的位置，得到整个文件字符的个数
    // rewind(fs); // 将文件指针重置到文件最前面

    fseek(p_fd, 100, SEEK_SET); // （以文件头为基准偏移100字节）
    fread(a_buf, 50, 1, p_fd); // 读1组，每组50字节
    fflush(p_fd); // 刷新存储内容到flash
    fclose(p_fd);
    
    return 0;

}
权重：较高
备注：会文件操作

====
如何在C程序中调用shell命令
答：使用system函数，如system(ls .)
权重：较高


8、描述LINUX中字符设备驱动的基本编程框架.
答：Linux一切皆文件，那么作为一个设备文件，它的操作方法接口封装在struct file_operations，当我们写一个驱动的时候，一定要实现相应的接口，这样才能使这个驱动可用。实现的接口有read，write，ioctl，遵循的框架有字符设备的注册与销毁，模块的注册与销毁。

9、 在Linux编程中若一个用户程序希望将一组数据传递给Kernel有几种方式？他们的优缺点是什么？


====
26.动态连接库的两种方式?
答：调用一个DLL中的函数有两种方法：
1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数
，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向
系统提供了载入DLL时所需的信息及DLL函数定位。 
2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa
dLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的
出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了。
权重：较低
备注：Linux的动态库是.so，Windows是dll

====

6. system（”pause”);作用?
   答:系统的暂停程序，按任意键继续，屏幕会打印，”按任意键继续。。。。。” 省去了使用getchar（）；
   权重：中
   备注：要知道linux system()系统调用函数



====
试题1：请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1
解答： 
int checkCPU()
{
    union w
    { 
        int a;
        char b;
    } c;
    c.a = 1;

    return (c.b == 1);

}
剖析：
　 　嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址 存放内容 
0x4000 0x34 
0x4001 0x12 
　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址 存放内容 
0x4000 0x12 
0x4001 0x34 
　　32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址 存放内容 
0x4000 0x78 
0x4001 0x56 
0x4002 0x34 
0x4003 0x12 
　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址 存放内容 
0x4000 0x12 
0x4001 0x34 
0x4002 0x56 
0x4003 0x78 
　　联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写
权重：高





====
2.设数组data[m]作为循环队列的存储空间。front为队头指针，rear为队尾指针，则执行出队操作后其头指针front值为(D)
A.front=front+1
B.front=(front+1)%(m-1)
C.front=(front-1)%m
D.front=(front+1)%m
解析：循环队列中出队操作后头指针需在循环意义下加1，因此为front=(front+l)%m。
权重：高
备注：C语言经常需要自己写各种队列、平直缓存、循环缓存

====
在循环队列中用数组A［0.m-1］存放队列元素，其队头和队尾指针分别为front和rear，则当前队列中的元素个数是 (D) 。
A．(front-rear+1)％m
B．(rear-front+1)％ m
C．(front-rear+m)％ m
D．(rear-front+m)％ m
解析：循环队列中，队头指向的是队首元素的前一个位置，队尾指向队尾元素所在位置。所以当前队列中的元素个数是(rear-froot+m)％m。
权重：高

====
19、队列和栈有什么区别？
    队列先进先出，栈后进先出
权重：高

====
请写一个循环队列和与其相关的操作函数
权重：较高





====

15. Linux驱动的基本结构
    驱动位于OS之下，为OS提供硬件操作(当然驱动也有可能不是针对硬件的)的逻辑和底层抽象的封装，所以他要上下兼顾，上边必须符合OS的驱动调用接口，下边要处理好硬件的操作。
    Linux比较特殊，把所有的设备都抽象成了文件，这样的话操作接口会比较统一，并且给开发也带来了很大的方便。Linux下设备文件有三种：字符设备、块设备、网络设备。
    权重：高

====

12. 
    8、PCI总线的含义是什么？PCI总线的主要特点是什么？
    权重：较低

====

====
11、RS232c高电平脉冲对应的TTL逻辑是?(负逻辑?) 
权重：较低

====
1、Linux系统下.ko是什么文件？.so是什么文件？
答：.ko是可动态安装卸载的驱动文件；.so是动态链接库，类似于Windows的.dll。

====
5、将一个链表逆序
答：思路为先定义链表结构体，并假定输入的链表是已经初始化好的
typedef struct _LIST {
    int data;
    LIST_T *ps_next;
} LINKED_LIST_T

LINKED_LIST *linked_list_reverse(LINKED_LIST * ps_list) // 直接修改该链表中的指针
{
    LINKED_LIST * ps_tmp1= NULL;
    LINKED_LIST * ps_tmp2= NULL;

    while (ps_list->ps_next != NULL) {
        ps_tmp2 = ps_list->ps-next; // 将原来的下一个暂存
        ps_list->ps-next = ps_tmp; // 赋值上一个
        ps_tmp = ps_list; // 更新上一个
        ps_list = ps_tmp2 ; // 继续计算下一个
    } 
    ps_list->ps_next = ps_tmp;
    
    return ps_list;

}
权重：中
备注：C语言中一般链表和循环缓存都是需要自己写的，没有现成的库函数可用。
    链表可以用来做人机交互的菜单，这样方便增删条目，也可以用来做队列，便于数据缓存。

====
16、 判断单向链表是否存在循环？
方法1：单链表判断是否存在循环，即判断是否有两个指针指向同一位置，即判断海量指针中是否有相同数据。然后对所有指针选择插入排序或者快速排序。
方法2：设置两个指针互相追逐。一个指针每次前进一步，第二个指针每次前进两步，如果有相遇，则说明有环。（如果一个单链表中有环，用一个指针去遍历，永远不会结束，所以可以用两个指针，一个指针一次走一步，另一个指针一次走两步，如果存在环，则这两个指针会在环内相遇，时间复杂度为O(n)）
权重：较高

====
4、数组与链表的区别。
　　数组中的数据在内存中的按顺序存储的，而链表是随机存储的！
 要访问数组中的元素可以按下标索引来访问，速度比较快，如果对他进行插入操作的话， 就得移动很多元素，所以对数组进行插入操作效率很低！由于连表是随机存储的，
 链表在插入，删除操作上有很高的效率（相对数组），如果要访问链表中的某个元素的话，
 那就得从链表的头逐个遍历，直到找到所需要的元素为止，
 所以链表的随机访问的效率就比数组要低  
权重：中

====
5、试编写3个函数实现
a.建立一个双向链表
b.插入一个节点
c.删除一个节点
其实明白了链表的概率，知道怎么用结构体来表示，指针如何指，编程就简单些了。
权重：高





13. Linux移植ARM的基本步骤和完成的任务
    1）首先是准备工作，包括下载源码、建立交叉编译环境等；
    2）然后是配置和编译内核，必要时还要对源码做一定的修改；
    3）第三步就是需要制作文件系统（如RAM disk）来挂接根文件系统；
    4）最后是下载、调试内核并在fs中添加自己的应用程序。
    权重：较高

====
1、ARM-linux启动分几部分，简述流程：
答：ARM-linux启动分为四个部分：引导加载程序（bootloader），Linux内核，文件系统，应用程序。
bootloader是系统启动和复位后执行的第一段代码，它主要用来初始化处理器及外设，然后调用Linux内核。Linux内核在完成系统的初始化之后需要挂载某个文件系统作为根文件系统（root filesystem）。根文件系统是Linux系统的核心组成部分，它可以作为Linux系统中文件和数据的存储区域，通常它还包括配置文件运行应用程序所需要的库。应用程序实现该嵌入式产品所要实现的目标。
其中bootloader可以使用芯片厂商提供的最基础的版本，只能用来引导Linux内核，也可以使用通用的U-Boot，U-Boot不光可以引导Flash上的Linux内核，还可以引导网络等其它位置上的Linux内核，对Linux内核进行升级等。
bootloader一般包含BL1和BL2，BL1硬件相关，用汇编语言编写，BL2硬件无关，用C语言编写。
权重：较高

====
3、说出你知道的文件系统，至少3种。
答：系统移植的同时也要移植文件系统。
Linux：ext、ext2、ext3、ext4
RTOS：jffs2, yaffs, cramfs, romfs, ramdisk, initramfs, ramfs/tmpfs, ubifs等，存储介质不是基于rom就是基于ram。
权重：较高

====
8、从internet上得到一个Linux Kernel的软件包linux-2.4-20.tz请描述出将其编译安装的过程。
权重：中

====
3、CPU中cache的作用？cache的基本组织结构？ 
  （1）高速缓冲存储器Cache是位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。    
在Cache中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从Cache中调用，从而加快读取速度。由此可见，在CPU中加入Cache是一种高效的解决方案，这样整个内存储器（Cache+内存）就变成了既有Cache的高速度，又有内存的大容量的存储系统了。
  （2）全相连映射，直接映射，组相连映射
权重：较低

====
3.int main(){fork()||fork();}共创建几个进程（B）
A.2
B.3
C.4
D.5
解析：首先，父进程fork后，给父进程返回子进程pid，此时为真，逻辑或语句不再执行，但是fork出的子进程是复制的父进程，此时PC程序指针也在当前位置，而且子进程的返回值是0，逻辑或语句为假，继续执行，注意此时进入子进程，多以子进程fork出孙子进程，不论子进程返回的是孙子进程的pid，还是孙子进程返回的是0，已经没有代码了，程序停止，main函数结束。所以孙子进程不再fork了，是因为没有代码了。
权重：较低

====
5 设周期性任务P1,P2,P3的周期为T1,T2,T3分别为100，150，400；执行时间分别为20，40，100。请设计一种调度算法进行任务调度，满足任务执行周期及任务周期。
权重：较低

====

10. 信号量最常用的两个功能
    信号量是用来调协进程对共享资源的访问的。
    用于进程中传递信号的一个整数值。
    权重：较高

====
7、LINUX中的管道指什么，重定向又指什么？
管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：

1. 其本质是一个伪文件(实为内核缓冲区)
2. 由两个文件描述符引用，一个表示读端，一个表示写端。
3. 规定数据从管道的写端流入管道，从读端流出。
   管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。
   管道的局限性：
   ① 数据自己读不能自己写。
   ② 数据一旦被读走，便不在管道中存在，不可反复读取。
   ③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。
   ④ 只能在有公共祖先的进程间使用管道。
   常见的通信方式有，单工通信、半双工通信、全双工通信。

重定向：文件标识符是从0到9结束的整数，指明了与进程有关的特定数据流源。当Linux系统启动一个进程（该进程可能用于执行Shell命令）时，将自动为该进程打开三个文件：标准输入、标准输出和标准错误输出，分别由文件标识符0、1、2标识，如果进程要打开其他的输入和输出文件，则从3开始标识。另外3-9是保留的标识符，可以把这些标识符指定为标准输入、标准输出和标准错误输出的临时连接。通常这样可以解决好多复杂的重定向请求。
例如可以将标准输出重定向到一个文件。
权重：中



====
7.TCP/IP模型的体系结构中，ICMP协议属于( A)。
A.网络层
B.应用层
C.数据链路层
D.传输层
权重：中

===
10.在局域网络内的某台主机用ping命令测试网络连接时发现网络内部的主机都可以连同，而不能与公网连通，问题可能是©。
A.主机IP设置有误
B.没有设置连接局域网的网关
C.局域网的网关或主机的网关设置有误
D.局域网DNS服务器设置有误
解析：
A 主机IP地址有误 不对，若是主机IP地址有误的话内网也不会通的
B 没有设置连接局域网的网关，也不对，因为若是没有连接局域网网关，局域网内也不会通，不可能所有主机都是两两连接吧
C局域网的网关或主机的网关设置有误， 局域网的网关设置有误，是可以的，主机的网关设置有误，那么内网也不会通的
D局域网DNS服务器设置有误也是不对的，DNS域名解析，那么IP地址有可能是通的.
权重：较高

====
14.FTP服务和SMTP服务的端口默认分别是©
A 20与25
B 21与25
C 20，21与25
D 20与21
解析：21端口用于连接，20端口用于传输数据
进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。
权重：中

====
1、winsock建立连接的主要实现步骤?
答：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（） 等待客户端连接。  客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（ ），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。  服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连 接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesock et()关闭套接字。
权重：高
备注：网络编程必备，socket和winsock使用方法差不多

====
2、Internet采用哪种网络协议？该协议的主要层次结构？
       Tcp/Ip协议
       主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。 
权重：高

====
16：IP地址有两部分组成： 网络号和主机号
权重：中

====
4、物理地址转换成IP地址的协议？反之？
 地址解析协议（ARP）的作用是将IP地址转换成物理地址；反地址解析协议（RARP）则负责将物理地址转换成IP地址。
权重：中

====
5、TCP/IP四层模型？OSI七层模型？TCP/IP协议包括？
 这7层是:物理层、数据链路层、网路层、传输层、话路层、表示层和应用层
 这4层分别为：应用层、传输层、网络层、链路层。 
 TCP/IP协议族包括(IP)、(ARP)、(RARP)、(ICMP)、(UDP)、(TCP)、(RIP)、Telnet、(SMTP)、DNS等协议。
权重：较高



====
4.下列说法错误的是 (BC)[多选]
A.当top等于数组的大下标值时则栈满
B.栈不能对输入序列部分或全局起求逆作用
C.top=0 时为空栈,元素进栈时指针 top 不断地减 1
D.利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素,这种形式的栈也称为顺序栈
解析：B错误，top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增。
D错误，栈的特性（先进后出）就决定了可以作为求逆元素的辅助空间。所谓求逆运算就是ABC依次入栈，输入CBA。
权重：中

====
8.向一个栈顶指针为h的带头结点的链栈中插入指针s所指的结点时,应执行(D)
A.h->next=s;
B.s->next=h;
C.s->next=h;h->next=s;
D.s->next=h->next;h->next=s;
权重：中

====
22.设栈S和队列Q的初始状态均为空，元素a,b,c,d,e,f,g依次进入栈S。若每个元素出栈后立即进入推列Q，且7个元素出队的顺序是b,d,c,f,e,a,g，则栈S的容量至少是?（C）
A 1
B 2
C 3
D 4
权重：较高

====
3.Heap与Stack的差别？
答案：Heap是堆，Stack是栈。
Stack的空间由系统自动分配/释放，Heap上的空间手动分配/释放。
Stack空间有限，Heap是很大的自由存储区，malloc函数分配的内存空间即在堆上。
网上经典例子：
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
void main(void)
{
  int b; //栈 
  char s[] = "abc"; //栈 
  char *p2; //栈 
  char *p3 = "123456"; //123456\0在常量区，p3在栈上
  static int c =0; //全局（静态）初始化区 
  p1 = (char *)malloc(10); //堆 
  p2 = (char *)malloc(20); //堆 
}
权重：高

====
15、堆和栈的区别  
一、预备知识—程序的内存分配
      一个由c/C++编译的程序占用的内存分为以下几个部分
      1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
      2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
      3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
      4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
      5、程序代码区—存放函数体的二进制代码。
权重：较高

====
2．Heap与stack的差别。
Heap是堆，stack是栈。
Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。
Stack空间有限，Heap是很大的自由存储区
C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。
程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行
权重：较高

====
6.堆栈溢出一般是由什么原因导致的？
      没有回收垃圾资源。
      函数内数组太大超过总大小。
权重：较高



====
1.设一棵完全二叉树有700个结点，则在该二叉树中有多少个叶子结点
答：
    如果一棵具有n个结点的深度为k的二叉树，它的每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，这棵二叉树称为完全二叉树。
    可以根据公式进行推导，假设n0是度为0的结点总数（即叶子结点数），n1是度为1的结点总数，n2是度为2的结点总数，由二叉树的性质可知：n0＝n2＋1，则n= n0＋n1＋n2（其中n为完全二叉树的结点总数），由上述公式把n2消去得：n= 2n0+n1－1，由于完全二叉树中度为1的结点数只有两种可能0或1，由此得到n0＝（n＋1）/2或n0＝n/2，合并成一个公式：n0＝（n＋1）/2 ，就可根据完全二叉树的结点总数计算出叶子结点数。

700/2=350个叶子节点 
权重：中

====
5.什么是平衡二叉树？
      左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。
权重：中

====
2、什么是平衡二叉树？
	当且仅当两个子树的高度差不超过1时，这个树是平衡二叉树。
权重：中

====
扩展：以下与数据的存储结构有关的术语是（ABC）[多选]
A．循环队列
B．链表
C．哈希表
D．栈
解析：循环队列、链表和哈希表都属于存储结构的描述，而栈属于逻辑结构描述
权重：中

====
1.若某线性表常用的操作是存取任一指定序号的元素和在后进行插入和删除运算，则利用()存储方式节省时间（A）
A.顺序表
B.双链表
C.带头结点的双循环链表
D.单循环链表
解析：采用顺序存储方式在已知元素序号的情况下可以直接计算出地址，当指定在线性表的最后进行插入和删除运算时，也不需要进行大量元素的移动
权重：中

====
11.若一棵具有n(n>0)个结点的二叉树的先序序列与后序序列正好相反，则该二叉树一定？( C)
A.结点均无左孩子的二叉树
B.结点均无右孩子的二叉树
C.高度为n的二叉树
D.存在度为2的结点的二叉树
解析：
原理如下：
先序遍历顺序是：M-L-R;
后序遍历顺序是：L-R-M;
可以看到，只有中间的结点（M）顺序变化了，左右结点相对位置是不变的。那可以推断出，要满足题意的话“二叉树的先序序列与后序序列正好相反”，说明整个二叉树左子树或者右子树有一个没有（遍历就成了，先：M-L ；后：L-M 或者 先：M-R ；后：R-M ）也就是必然是一条链.
权重：中

====
19.在一个10阶的B-树上，每个树根结点中所含的关键字数目多允许为( )个，少允许为( B)个。

A 10,5
B 9,4
C 8,3
D 7,6
解析：最多M-1 最少M/2-1 向上取整。
权重：中

====
20.关于红黑树和AVL树，以下哪种说法正确?（ABC）[多选]
A 两者都属于自平衡二叉树
B 两者查找,插入，删除的时间复杂度相同
C 包含n个内部节点的红黑树的高度是O(log(n))
D JDK的TreeMap是一个AVL的实现
解析：红黑树和avl树都属于自平衡二叉树；
两者查找、插入、删除的时间复杂度相同；
包含n个内部结点的红黑树的高度是o(logn);
TreeMap是一个红黑树的实现，能保证插入的值保证排序。
权重：中



====
2、 如果有一个简单的helloworld项目目录如下：

# tree helloworld

helloworld
|– file2.h
|– file1.cpp
|– file2.cpp
请编写一个Makefile文件。
答：
TARGET = helloworld
CXX = g++
COMPILE := $(COMPILE) file1.cpp
COMPILE := $(COMPILE) file2.cpp
OBJECTS := $(foreach var,$(COMPILE), $(var:.cpp=.o))

.PHONY default clean
default: $(TARGET)
$(TARGET):$(OBJECTS)
	$(CXX) -o $(TARGET) $(OBJECTS)
%.o:%.cpp
	$(CXX) -c $<
clean:
	@rm -rf $(OBJECTS) $(TARGET)

讲解1：
foo := a.o b.o c.o // 在变量后追加值
bar := $(foo:.o=.c)
这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。
讲解2：
“$<”表示所有的依赖目标集（也就是“file1.cpp file2.cpp”），“$@”表示目标集（也就是file1.o file2.o”）
讲解3：
$(foreach <var>,<list>,<text>)
这个函数的意思是，把参数<list>;中的单词逐一取出放到参数<var>;所指定的变量中，然后再执行< text>;所包含的表达式。每一次<text>;会返回一个字符串，循环过程中，<text>;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。

或者简单点的：
helloworld: file1.o file2.o
	g++ -o helloworld file1.o file2.o
file1.o:file1.cpp
	g++ -c file1.cpp
file2.o:file2.cpp file2.h
	g++ -c file2.cpp
clean: 
	rm file1.o file2.o helleworld
权重：中

====
12.在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件?(D)
A./usr/tmp
B./etc/default
C./etc/skel
D./etc/users
权重：中

====
Linux默认的可执行bin文件路径是什么
答：/bin, /usr/bin
权重：中

====
Linux默认的库文件路径是什么
答：/lib, /usr/lib
权重：中

====
Linux的启动脚本一般在哪里
答：rc.d、etc/profile等
权重：中

====
21.Linux执行ls，会引起哪些系统调用(BCD)【多选】
A nmap
B read
C execve
D fork
解析：任何shell都会执行 exec 和 fork，而ls会执行read三个加起来
权重：较低

====
6、GCC -g -o test.elf test.c的具体含义.
答：将当前目录下test.c编译成带GDB调试功能的应用程序test.elf。注意，其中应用到了gcc的隐藏规则，本来应该是两步：GCC -o test.elf test.o    GCC -c test.c，但是直接用-o test.c的时候gcc会自动推导。-g选项嵌入式应该掌握，-g后程序崩溃后生成的core文件在GDB下可以看到更多的信息，也可以配合GDB在运行时单步执行，设置断点什么的。
权重：中

===
用gcc将test.c编译成一个可执行文件test
答：gcc -o test test.c
权重：中

====
1、一些Linux命令：显示文件、拷贝文件、移动文件、删除文件。
答：显示文件ls，显示隐藏文件ls -a，显示文件详细信息ls -l；
拷贝文件cp source_name dest_name，强制复制文件和目录cp -rf source_name dest_name；移动文件mv source_name dest_name；删除文件rm file_name。
权重：高

====
4、LINUX下查看进程的命令？查看系统资源使用情况的命令？netstat是作什么用的？
答：linux下查看进程的命令，ps命令
使用free-m命令
Netstat命令是查看网络连接的详细状态的命令
权重：较高

====
Linux查看进程信息的命令
答：top
权重：较高

====
Linux搜索文件内容和文件名的命令
答：grep -rn 文件内容
find . 文件名
或者在匹配文件名的文件中查找文件内容
find . filename | xargs grep -rn filecontent
权重：中

====
描述*在查找和正则表达式中的含义
答：表示0个或多个任意字符
权重：中

====
6、解释命令ls -a | more具体含义.
答：分页显示当前目录下包含隐藏文件在内的所有文件。
权重：中



====
6 优先级反转问题在嵌入式系统中是一中严重的问题，必须给与足够重视。
a) 首先请解释优先级反转问题
b) 很多RTOS提供优先级继承策略(Priority inheritance)和优先级天花板策略(Priority ceilings)用来解决优先级反转问题，请讨论这两种策略。
答：
    优先级反转：高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。
    具体来说，当高优先级任务正等待信号量（此信号量被一个低优先级任务拥有着）的时候，一个介于两个任务优先之间的中等优先级任务开始执行，这就会导致一个高优先级任务在等待一个低优先级任务，而低优先级任务却无法执行类似死锁的情形发生。
    优先级继承策略：进程调度算法对获取到临界资源的进程(A)增加其优先级为所有等待该资源的进程中的最高优先级。一旦进程(A)释放了该资源，就恢复到原来的优先级。
    优先级天花板策略：给每个信号量设置一个优先级天花板，优先级天花板的值大于所有使用该信号的任务的优先级，当某个任务得到该信号量时，将其优先级置为优先级天花板的值。
权重：中
备注：平常编程时用不到，但需要了解运行原理，类似的还有内存管理的原理。

====
18.操作系统采用缓冲技术，能够减少CPU（A）次数，从而提高资源的利用率。
A 中断
B 访问
C 控制
D 依赖
解析：
引入缓冲的主要原因包括：缓和CPU与I/O设备间速度不匹配的矛盾；减少对CPU的中断频率，放宽对中断响应时间的限制；提高CPU和I/O设备之间的并行性。所以采用缓冲技术，可减少对CPU的中断次数，从而提高系统效率。
权重：中

====

11. uClinux 和linux的区别（或者说rtos和linux的区别）
    对uCLinux来说，其设计针对没有MMU的处理器，不能使用处理器的虚拟内存管理技术。uCLinux仍然采用存储器的分页管理，系统在启动时把实际存储器进行分页。在加载应用程序时程序分页加载。但是由于没有MMU管理，所以实际上uCLinux采用实存储器管理策略。uCLinux系统对于内存的访问是直接的，所有程序中访问的地址都是实际的物理地址。操作系统对内存空间没有保护，各个进程实际上共享一个运行空间。
    权重：较高

====

14. Linux图形系统有哪些?
    X Window、SVGALib、FrameBuffer、LibGGI、QT
    权重：较低

====
c) 中断(interrupt,如键盘中断)与异常(exception,如除零异常)有何区别?
异常：在产生时必须考虑与处理器的时钟同步，实践上，异常也称为同步中断。在处理器执行到由于编程失误而导致的错误指令时，或者在执行期间出现特殊情况(如缺页)，必须靠内核处理的时候，处理器就会产生一个异常。
所谓中断应该是指外部硬件产生的一个电信号，从cpu的中断引脚进入，打断cpu当前的运行；
所谓异常，是指软件运行中发生了一些必须作出处理的事件，cpu自动产生一个陷入来打断当前运行，转入异常处理流程。
权重：中

====
6 优先级反转问题在嵌入式系统中是一中严重的问题，必须给与足够重视。
a) 首先请解释优先级反转问题
b) 很多RTOS提供优先级继承策略(Priority inheritance)和优先级天花板策略(Priority ceilings)用来解决优先级反转问题，请讨论这两种策略。
答：
高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务的现象叫做优先级反转
  优先级继承策略(Priority inheritance):继承现有被阻塞任务的最高优先级作为其优先级，任务退出临界区，恢
复初始优先级。
  优先级天花板策略(Priority ceilings):控制访问临界资源的信号量的优先级天花板。
  优先级继承策略对任务执行流程的影响相对教小，因为只有当高优先级任务申请已被低优先级任务占有的临界资源
这一事实发生时，才抬升低优先级任务的优先级。
权重：中

====
5、进程调度策略。
先进先出算法，最短CPU运行期优先调度算法，轮转法，多级队列方法
权重：较高

====
3、进程间通讯机制有哪些？
答：linux下使用的进程间通信的方式主要有：管道和有名管道，信号，消息队列，共享内存，信号量，套接字。
权重：较高

====
4、比较一下进程和线程的区别？
 （1）、调度：线程是CPU调度和分派的基本单位
 （2）、拥有资源：

  *  进程是系统中程序执行和资源分配的基本单位
  *  线程自己一般不拥有资源（除了必不可少的程序计数器，一组寄存器和栈），但他可以去访问其所属进程的资源，
     如进程代码，数据段以及系统资源（已打开的文件，I/O设备等）。
      （3）系统开销：
  *  同一进程中的多个线程可以共享同一地址空间，因此它们之间的同步和通信的实现也比较简单
  *  在进程切换的时候，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置；
     而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，从而能更有效地使用系统资源和
     提高系统吞吐量。
     权重：较高

====
21：进程和线程的区别：
    1：调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位；
    2：并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行。
    3：拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源；
    4：在创建或撤销线程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销。
权重：较高

====
5、死锁的四个条件及处理方法。
　　  (1)互斥条件：一个资源每次只能被一个进程使用。
    (2) 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
    (3)不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
    (4)循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  
　　    解决死锁的方法分为死锁的预防，避免，检测与恢复三种 
权重：高

===
9、中断的概念？简述中断的过程。
可以描述一下isr、dsr，中断上半部、中断下半部，软中断
权重：较高

====
3.描述实时系统的基本特性
       在特定时间内完成特定的任务，实时性与可靠性。
权重：高

====
8．谈谈IA32下的分页机制
小页(4K)两级分页模式，大页(4M)一级
权重：低
备注：内存分页





















