# 指针与数组

数组的本质是用指针进行偏置的变量。

数组的指针是连续的。对于数组的指针，`&a[0]`与`&a`是相同的。

## 指向数组元素的指针

```c
int num[32] = {0};
int *p1 = &num;
int *p2 = &num[0];
```

通常情况下这样申请数组指针，指针指向数组中的单个元素，

```c
p2++;
//则 p2 == num[1]
```

## 指向数组的指针

```c
int num[32] = {0};
int (*p1)[32] = &num;
```

通过这种方式申请指向数组的指针，这种情况下

```c
pa++;
```

则是直接移动整个数组(32个int)大小。

## 指针数组

指针数组是数组形式的指针，可以通过

```c
int  var[] = {10, 100, 200};
int i, *ptr[MAX];
for ( i = 0; i < MAX; i++)
{
	ptr[i] = &var[i]; /* 赋值为整数的地址 */
}
for ( i = 0; i < MAX; i++)
{
	printf("Value of var[%d] = %d\n", i, *ptr[i] );
}
```

的方式申请和赋值。


## 访问操作的编译时处理

```c
int a[10];
int *p = a;
```


以下四种访问方式在编译时会被处理为**完全相同的机器指令**：
```c
a[i]    // 数组下标访问
*(a+i)  // 数组名指针算术
p[i]    // 指针下标访问
*(p+i)  // 指针算术解引用
```

**编译处理过程**：

1. **数组访问 `a[i]`**：
   - 数组名 `a` 退化为指向首元素的指针（`int*`）
   - 计算地址：`基地址 + i × sizeof(int)`
   - 生成指令：`mov eax, [base + i*4]`

2. **指针算术 `*(a+i)`**：
   - 与 `a[i]` 完全等价，编译后代码相同

3. **指针访问 `p[i]`**：
   - 直接计算地址：`p 的值 + i × sizeof(int)`
   - 生成指令：`mov eax, [p + i*4]`

4. **指针解引用 `*(p+i)`**：
   - 与 `p[i]` 完全等价，编译后代码相同

**关键区别**：
- `a` 是**数组标识符**（编译时确定地址常量）
- `p` 是**指针变量**（运行时存储地址值）

## 结论
1. **数组名不是指针**：
   
   - 在大多数上下文中数组名会退化为指针，但 `sizeof` 和 `&` 操作保留了数组的完整类型信息
   
2. **指针运算的本质**：
   ```c
   a[i] ≡ *(a+i) ≡ *(p+i) ≡ p[i]
   ```
   所有形式最终都编译为：`基地址 + 索引 × 元素大小`

3. **类型系统的作用**：
   - `&a + 1` 的正确性依赖于编译器知道 `a` 的完整类型（`int[10]`）
   - 指针运算 `p + i` 自动考虑元素大小（`sizeof(int)`）