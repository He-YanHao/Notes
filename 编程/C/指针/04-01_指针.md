# 指针

## 指针基础

代表按位与运算的`&`同时也可以作为取地址符，例如：

```c
int a=123;         //申请int变量a
printf("%d",a);    //输出a的值，为123
printf("%p",&a);   //输出a的地址，是一串16进制数
```

使用`*`申请指针变量，`*`是类型的一部分，表示"指针"


```c
int *pa = &a;      //申请指向a的指针pa，指针一般用p做前缀
pa = &a;           //将a的地址存入pa，从此，pa指向a。
printf("%p",pa);   //输出a的地址，是一串16进制数
printf("%p",&pa);  //输出pa的地址，是一串16进制数.指针变量也要存放在内存里，所以也会有指向指针的指针。
```

当`*`用于已存在的指针变量前时，表示访问该指针指向的内存位置的值。


```c
printf("%d",*a);    //不合法，因为a不是指针变量。
printf("%d",*pa);   //输出a的值，为123。因为pa是指向a的指针。
```

64位系统里，指针地址为8字节，一般用16个十六进制字符组成数字表示，这个数字表示操作系统里的第该数字个字节数据为其指向的数据的首地址。

指针可以递增或递减，每递增或递减一次移动指针数据类型个地址。

```c
uint16_t a = 10, *pa = &a;
pa++; //指针右移16位
uint32_t b = 10, *pb = &b;
pb++; //指针右移32位
```

指针也可以比较大小，从而确定指针是否指向同一块内存，或是两个指针指向位置的先后。

指针也可以通过强制类型转换改变移动的大小：

```c
uint16_t a = 10, *pa = &a;
(*uint32_t)pa++; //指针右移32位
uint32_t b = 10, *pb = &b;
(*uint16_t)pb++; //指针右移16位
```

## 空地址NULL

如果定义了指针但是暂时没有合适的赋值，那么可以先赋予一个空地址NULL。

```c
pa = NULL;
```

NULL 是预处理宏所包含的，为：

```c
#define NULL ((void *)0)
```

## `*`的运算顺序

***** 和取地址符**&** 一样，也是运算符的一种，也有运算顺序，比 **++** 和 **--** 运算符要低，也就意味着 ***pa++** 和 ***(pa++)** 等价，时指针地址自加，然后指向。

## const char * const Name

```c
const char * const pcName = 'A';
```

- 第一个const表示指针指向的地方为只读，不可修改。
- char为指针的类型。
- 第二个const表示指针指向的地方存放的变量为只读，不可修改。
- pcName为指向只读变量的只读指针名。

## 指向结构体的指针

申请结构体指针和普通指针一样是数据类型加*，只不过数据类型为自定义的结构体名。如：

```c
struct student stu_1;
struct student *p;
```

对于其成员依旧是 ` . ` 的形式引出，如：

```c
(*p).num, (*p).name, (*p).sex, (*p).score)
```

## 参数为指针的函数

允许传递指针给函数，只需要简单地声明函数参数为指针类型即可。

## 函数指针

函数指针是指向函数的指针，定义格式如下：

```c
返回值类型 (*函数指针名) (参数1类型 参数名1, 参数2类型 参数名2) = & max;
//如：
int (*p)(int, int) = & max;//参数名可以省略，并且通常是省略的。
```

后面可以直接用p代替max函数。

### 回调函数

是指参数包含函数的函数，一般用函数指针代替。

## 指针函数

指针函数是返回值为指针的函数。定义格式如下：

```c
int *p(int a,int b); //注意这里的*与P之间是没有括号的，所以含义是函数p(int,int)会返回一个（int *）指针
{
    int a = 123;
    int *pa = &a;
    return pa;
}
```

则返回值pa是一个指向a的指针。













