# C语言题目

## 如何判别一个数是unsigned

#define issignal(x) ((x>=0 && ~x>=0) ? 1:0) //为1是无符号 为0有符号。

对于无符号类型，必定大于或等于零，取反也一样，所以输出1。

对于有符号类型，若小于0，输出0，若大于或等于0，取反后符号位为1，为负数，小于0，所以也输出0。

signed最高位只是用来做标记(sign)，标记整数的正负，0表示正，1表示负。

## 实现x是否为2的若干次幂的判断

```c
!(X)&(X-1)
```

数据都是按照二进制保存，

若为2的若干次幂，转化为2进制所有位都是1，将其减一后形成除最小位外为0外都为1，然后取和，结果也是除最小位外为0都为1，取反，结果为1。

若不是2的若干次幂，转化为2进制有的位是0，将其减一后形成除最小位外为0外包含其他0，然后取和，结果也是除最小位外为0外包含其他0，取反，结果不为1。

## 程序跳转到绝对地址是0x100000去执行

要对绝对地址0x100000赋值，我们可以用(unsigned int *)0x100000 = 1234；那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？

答案:

```c
*((void (*)( ))0x100000)( );
```

解析：首先要将0x100000强制转换成函数指针,即:

```c
(void (*)())0x100000
```

然后再调用它。

```c
*((void (*)( ))0x100000)( );
```

 用typedef可以看得更直观些:

```c
typedef void(*)() voidFuncPtr;
*((voidFuncPtr)0x100000)();
```

## 将一个数字字符串转换为数字

将一个数字字符串转换为数字."1234" --> 1234

```c
int convert(char* str)
{
    int k = 0;
    while (*str != '\0')
    {
        k = k * 10 + (*str++) - '0';
        //每循环一次k十进制左移一位，字符串指针后移一位，减去'0'，刚好将字符转换为数字。
        //从字符串第一位开始，此时k=0，字符串指针第一位减去'0'，将字符转换为数字，然后下一次循环将其左移。
    }
    return k;
}
```

## static

1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件

static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

## 常量字符串地址优化

```c
1.分析下面的代码,结果是什么：
char *a = "hello";
char *b = "hello";
if(a == b)
    printf("YES");
else
    printf("NO");
答：
如果是笔试题目，答案是no(考察指针地址)
可在VC实际结果是YES 在C是NO
常量字符串存储于静态存储区，它在程序生命期内恒定不变。如果编译器优化的话，会有可能a和b同时指向同一个hello的。则地址相同。如果编译器没有优化，那么就是两个不同的地址，则不同！
权重：较高
```




====
2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。
权重：高
备注：编程时，在有需要的情况下，需要手动调整分区表配置，要理解代码的存储机制

## inline

41、对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

答：c用宏定义，c++用inline。

其实，c里面也可以用inline啊。

备注：宏定义函数每行句末都必须加上反斜杠

====
intel：

1. A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?
   答：static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。
   他们都放在数据区，但是编译器对他们的命名是不同的。
   权重：高

====

1. const的理解：const char*, char const*, char*const有什么区别？
   答：常考的题目。事实上这个概念谁都有，只是三种声明方式非常相似很容易记混。Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。 
   char * const cp; ( * 读成 pointer to ) 
   cp is a const pointer to char 
   const char * p; 
   p is a pointer to const char; 
   char const * p; 
   同上因为C++里面没有const*的运算符，所以const只能属于前面的类型。
   权重：高

====

2. c指针，解释下面定义是什么意思？
   int *p[n];—–指针数组，每个元素均为指向整型数据的指针。
   int (*p)[n];——p为指向一维数组的指针，这个一维数组有n个整型数据。
   int *p();———-函数带回指针，指针指向返回的值。
   int (*p)();——p为指向函数的指针。
   权重：高

====

5. ASSERT()是干什么用的
   答:ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序： 
   …… 
   ASSERT( n != 0); 
   k = 10/ n; 
   …… 
   ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。 
   assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。
   权重：较高

====

9. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
   答;全局变量的生命周期是整个程序运行的时间，而局部变量的生命周期则是局部函数或过程调用的时间段。其实现是由编译器在编译时采用不同内存分配方法。
   全局变量在main函数调用后，就开始分配，
   静态变量则是在main函数前就已经初始化了。
   局部变量则是在用户栈中动态分配的（还是建议看编译原理中的活动记录这一块）
   权重：中

====
13：全局变量与局部变量在内存中是否有区别，是什么区别？
        全局变量存储在静态数据库，局部变量存储在堆栈；
权重：中

====
b) 在ARM系统中，函数调用的时候，参数是通过哪种方式传递的?
答：用寄存器R0传递第一个参数，R1传递到第二个，一直到R3传递第四个参数。但是实际上有时可能传递的参数非常多，超过8个，或是参数中有浮点数之类，参数也会超过4个寄存器，对于超出的部份并不使用R4，而是使用堆栈的方式。
权重：较低
备注：每个函数能使用的栈大小是有上限的，如512K，所以最好不要传大块的结构体，多使用指针。

====
c) 中断(interrupt，如键盘中断)与异常(exception，如除零异常)有何区别？
答：
中断：中断是指来自CPU执行指令以外的事件发生后，处理机暂停正在运行的程序，转去执行处理该事件的程序的过程。
异常：异常是指源自CPU执行指令内部的事件发生后，处理机暂停正在运行的程序，转去执行该事件的过程。
区别：广义的中断包括中断和异常，统一称为中断。狭义的中断和异常的区别在于是否与正在执行的指令有关，中断可以被屏蔽，异常不能被屏蔽，一旦出现应立即处理。
权重：较低

====
重入是什么？如何保证函数可以重入。
    重入一般可以理解为一个函数在多线程下，同时被多次调用，前一个调用还没退出，下一个调用已经开始进行。例如操作系统在进程调度过程中，或者单片机、处理器等的中断的时候会发生重入的现象。
    一般浮点运算都是由专门的硬件来完成，举个例子假设有个硬件寄存器名字叫做FLOAT，用来计算和存放浮点数的中间运算结果
    假设有这么个函数
void fun()
{
    //...这个函数对FLOAT寄存器进行操作
}
    假如第一次执行，有个对浮点数操作运算的结果临时存在FLOAT寄存器中，而就在这时被中断了，而中断函数或者另一个进程也调用fun函数，这时第二次调用的fun函数在执行的过程中就会破坏第一次FLOAT寄存器中的结果，这样当返回到第一次fun函数的时候，结果就不正确了。
    想要函数能够重入，不要在函数内部使用static静态变量，不要操作硬件寄存器。可重入代表可被中断。
    

    问题1，如何编写可重入的函数？
    答：在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。
    
    问题2，如何将一个不可重入的函数改写成可重入的函数？
    答：把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的。
    1) 不要使用全局变量。因为别的代码很可能覆盖这些变量值。
    2) 在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”。
    3) 不能调用其它任何不可重入的函数。
    4) 谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。
    堆栈操作涉及内存分配，稍不留神就会造成益出导致覆盖其他任务的数据，所以，请谨慎使用堆栈！最好别用。

权重：中
备注：类似的思想体现在，在中断处理函数中不要操作浮点数，不要使用printf等IO函数，不操作全局变量，不使用同步、互斥、锁、信号量这些，不使用malloc、free。

====
9、若main（）函数带参数，参数个数最多是
A.0
B.1
C.2
D.3
参考答案：C
权重：较高
备注：定义形式 main(int argc, char* argv[])）
调用程序二进制文件时可以在后面加参数控制不同行为

====
10、C 语言中运算对象必须是整型的运算符是
A.%
B./
C.!
D.**
参考答案：A
权重：中

====
37、对语句 if else 与操作符 ? : 使用场合的比较。
答： ？:简短，可以多层嵌套，增加代码可读性，也很适合宏定义函数中用，还有显示高逼格。
    如() ? ( [] ? [] : []) :  ( [] ? [] : [])这样的写法可以省略三次if else，但是不影响理解代码的含义。
权重：较高
备注：实际使用时经常使用？：

====
32、如何在两个.c文件中引用对方的变量。
    这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。（这种方式非常不提倡，会让程序结构非常乱）
    还有一种就是初始化时注册回调函数，在b.c中调用a.c的注册函数，把自己变量的地址赋给a.c回调函数的指针中，实际工作中推荐这么用。
权重：低
备注：特别注意c语言中头文件不能相互包含，只能是线性包含，比如，所有的全局变量在a.c中定义，b.c包含a.h，不能a.c包含b.h，而b.c也包含a.h。

====
33、 如何让局部变量具有全局生命期。
    也可以这样问，如何在函数退出后保留函数中局部变量的值，不过这个知识点嵌入式应该掌握。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。
权重：中
备注：需要掌握，嵌入式经常用。

====
31、使用malloc之前需要做什么准备工作。
首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。
权重：较低
备注：嵌入式应该掌握malloc和free

====
2、 二维数组中的元素AA [ 3 ][ 7 ]的另外一种表示方法？
答：*(*(AA+3)+7;
权重：中

## memset

17、 如何初始化一个指针数组。
题目出的不好，题意不明确，而且方法有好几种。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。也可以用memset
权重：中

## 用宏定义写出swap（x，y）

用宏定义写出swap（x，y）

```
#define swap(x, y) 
x = x + y;
y = x - y;
x = x - y;
```

权重：高
备注：掌握宏定义函数，此题答案有误，还需把所有的x和y都加上括号，最好还要用上do while(0)====
9.写出float x 与“零值”比较的if语句。
      if(x > 0.000001 && x < -0.000001)
权重：高
备注：实际编程时要注意

====
12、已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：
#define NTBL (sizeof(table) / sizeof(table[0]))
权重：高
备注：实际工作经常使用

编写一个 C 函数，该函数在一个字符串中找到子字符串。
答：即手动实现string.h中的strstr函数，仿照它的函数名和形参返回值
char *strstr(const char *s1, const char *s2) // 在s1中查找s2，没找到返回NULL
{
    int n;

    if(*s2)
    { // 判断s2是否为空
        while(*s1) // 循环在s1中判断
        {
            for(n=0; *(s1+n)==*(s2+n); n++)
            {
                if(!*(s2+n+1)) // 如果s2下一个字节为字符串尾0x00，则所有字符串都已经找到
                    return (char*)s1;
            }
            s1++;
        }
        return NULL;
    }
    else
        return (char*)s1;

}
权重：较高
备注：考对指针的操作，实际工作中经常要对字符串进行各种操作，如置换、查找、拼接，有些在 库函数中找不到原型的就需要自己实现。
    string.h中的strstr函数已经实现了字符串查找功能

====
12、已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：
#define NTBL (sizeof(table) / sizeof(table[0]))
权重：高
备注：实际工作经常使用

====
14、二维数组空间的动态申请
可以使用c语言的malloc free或者c++的new delete
a.简单的，已经有一维，如
    char (*c)[5];
    c = new char[n][5]; //n为已定义的行数
b.二维的 int **p;
    p = new int *[m_row]; //创建行指针
    for (int i = 0; i < m_row; i++) //为每一行分配空间
       p[i] = new int[m_cols];
写到某一个函数中：
void getmemory(int ** &p, int m_row, int m_cols)
{
    p = new int*[m_row]; //创建行指针
    for (int i=0; i<m_row; i++) //为每一行分配空间
        p[i] = new int[m_cols];
 }
释放空间:
void deletememory(int **&p, int m_row)
{
     //释放每一行所分配的空间
     for(int i = 0; i < m_row; i++) 
         delete [] x[i]; //释放行指针
     delete [] x; 
     x = 0;
}
权重：中
备注：内存申请了在用完后一定要释放，切记。忘了释放程序跑起来出了错，要花费大量的时间来查找问题，得不偿失。
    对于多模块配合的情况可以发送者只管申请，接收者只管释放。

====
26、printf可以接受多个参数，为什么，请写出printf的原型。
答：使用可变参数技术，va_list va_start va_arg
int printf(const char *fmt, ...);
权重：中
备注：直接记住可变参数的原理。
    考核C语言可变参数，比如main函数就可以用可变参数，在应用程序被调用时可以用不同的参数动态的控制不同的程序运行策略

====
30、a+++++b所表示的是什么意思？有什么问题？
    这种写法坚决不提倡，写代码要有完好的编码规范！包括能用括号表示优先级就要用括号，使用规范命名等等。
    这个东西其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个team里，那么他基本会被打的半死
    最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是8。
权重：较低
备注：的确有公司出这个题，考察C语言所有操作符的优先级，其实不用记住，需要知道优先级的时候可以到网上去查

====
34、 对(-1.2345)取整是多少？
取整不是四舍五入，而是去掉尾巴。
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。
权重：高

====
35、 如何在C中为一个数组分配空间。
    题目出的不好，应该出的具体化一点，给出要分配的数组名称和大小。
    最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
    一种是栈的形式：char array[5]；即局部变量的分配，我们要明白的是，这种形式空间分配的大小可能会受操作系统的限制,比如一般arm会限制512K，windows会限制在2M；这是嵌入式应该掌握的知识点。因为你不能在函数内部定义大的数组，这会导致程序异常崩溃，浪费你大量的debug时间。
    一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大，只是一定要记得使用完之后释放。
权重：较高

====
1、 s[10]的另外一种表达方式是什么。
    前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。
权重：较低
备注：需要理解题意，s[10]代表已有数组中的一个元素，int s[10];才是定义数组。

===
2、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。
权重：高
备注：C语言基础

====
3、编写一个自己的完全C语言版本的memset函数，并且评价这个实现的性能和可移植性
理解了字符串结尾是’\0’，用while循环，将每个元素都赋给你想给的值。
权重：中
备注：理解字符串操作库函数，memset是将分配好的内存初始化为你想要的值，因为C语言分配好了内存后，内存里面的值是随机的，你往里面小范围放数据时就必须要全部初始化为0。

====
2、计算一个字节里（byte）里面有多少bit被置1 
答：
#include <stdio.h>
int comb(const int c)
{
    int count = 0;
    int i = 0;
    int cc = c;
    while(i++ < 8)
    {
        if((cc & 1) == 1)
        {
            count++;
        }
        cc = cc >> 1;
    }
    return count;
}
权重：中
备注：这是常规做法，还有一种更简单的做法

====
3.求函数返回值，假设输入x = 9999; 
int func(int x)
{ 
    int countx = 0; 
    while (x) 
    {
        countx++; 
        x = x & (x - 1); 
    } 
    return countx; 
} 
结果呢？
答：
知道了这是统计9999的二进制数值中有多少个1的函数，且有 
9999＝9×1024＋512＋256＋15
9×1024中含有1的个数为2； 
512中含有1的个数为1； 
256中含有1的个数为1； 
15中含有1的个数为4； 
故共有1的个数为8，结果为8。 
1000 - 1 = 0111，正好是原数取反。这就是原理。 
用这种方法来求1的个数是很效率很高的。 
不必去一个一个地移位。循环次数最少。
权重：较高

====
8.写一个内存拷贝函数,不用任何库函数.
答：
void* memcpy(void *pvTo, const void *pvFrom, size_t size)
{
    assert((pvTo != NULL) && (pvFrom != NULL));
    byte* pbTo = pvTo;
    byte* pbFrom = pbFrom;
    while (size-- > 0)
    {
       *pbTo++ = *pbFrom++;
    }
    return pvTo;
}
权重：高
备注：考超指针与赋值

====
编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案：
2分
void strcpy( char *strDest, char *strSrc )
{
　   while( (*strDest++ = * strSrc++) != '\0' );
} 
4分
void strcpy( char *strDest, const char *strSrc ) 
//将源字符串加const，表明其为输入参数，加2分
{
　   while( (*strDest++ = * strSrc++) != '\0' );
} 
7分
void strcpy(char *strDest, const char *strSrc) 
{
　  //对源地址和目的地址加非0断言，加3分
　  assert( (strDest != NULL) && (strSrc != NULL) );
　  while( (*strDest++ = * strSrc++) != '\0' );
} 
10分
//为了实现链式操作，将目的地址返回，加3分！
char * strcpy( char *strDest, const char *strSrc ) 
{
　 assert( (strDest != NULL) && (strSrc != NULL) );
　 char *address = strDest; 
　 while( (*strDest++ = * strSrc++) != '\0' ); 
　　 return address;
} 
(4)对strlen的掌握，它没有包括字符串末尾的'\0'。
权重：较高

====
写出一个10分的strlen函数，完美的版本为
int strlen( const char *str ) //输入参数const
{
    assert( strt != NULL ); //断言字符串地址非0

　   int len;
　   while( (*str++) != '\0' ) 
　   { 
　　      len++; 
　   }
　   return len;
}
权重：较高

====

5. 编写strcat函数(6分)
   已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc);
   其中strDest 是目的字符串，strSrc 是源字符串。
   （1）不调用C++/C 的字符串库函数，请编写函数 strcat
   答：
   VC源码：
   char * __cdecl strcat (char * dst, const char * src)
   {
    char * cp = dst;
    while( *cp )
        cp++; /* find end of dst */
    while( *cp++ = *src++ ) ; /* Copy src to end of dst */
    return( dst ); /* return dst */
   }
   （2）strcat能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？
   答：方便赋值给其他变量
   权重：较高
   备注：学习精简写法

====
13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。
     循环链表，用取余操作做
权重：中

====
3.在c语言库函数中将一个字符转换成整型的函数是atol()吗，这个函数的原型是什么？
函数名: atol 
功 能: 把字符串转换成长整型数 
用 法: long atol(const char *nptr); 
程序例: 
#include <stdlib.h> 
#include <stdio.h> 
int main(void) 
{ 
    long l;
    char *str = "98765432";

    l = atol(lstr);
    printf("string = %s integer = %ld\n", str, l);
    
    return(0); 

}
权重：高
备注：要知道<stdlib.h>的atoi、itoa等字符串转换函数

====
4.unsigned int intvert(unsigned int x,int p,int n)
实现对x的进行转换,p为起始转化位,n为需要转换的长度,假设起始点在右边.如x=0b0001 0001,p=4,n=3转换后x=0b0110 0001
答
unsigned int intvert(unsigned int x,int p,int n){
    unsigned int _t = 0;
    unsigned int _a = 1;
    for(int i = 0; i < n; ++i){
        _t |= _a;
        _a = _a << 1;
    }
    _t = _t << p;
    x ^= _t;

    return x;

}
权重：高
备注：会位操作

====

34、 对(-1.2345)取整是多少？
取整不是四舍五入，而是去掉尾巴。
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。
权重：高

====
26:写一语句实现x是否为2的若干次幂的判断。
参考答案：!(X)&(X-1)
权重：较高
备注：理解并记住

====
试题1：请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1
解答： 
int checkCPU()
{
    union w
    { 
        int a;
        char b;
    } c;
    c.a = 1;

    return (c.b == 1);

}
剖析：
　 　嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址 存放内容 
0x4000 0x34 
0x4001 0x12 
　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址 存放内容 
0x4000 0x12 
0x4001 0x34 
　　32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址 存放内容 
0x4000 0x78 
0x4001 0x56 
0x4002 0x34 
0x4003 0x12 
　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址 存放内容 
0x4000 0x12 
0x4001 0x34 
0x4002 0x56 
0x4003 0x78 
　　联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写
权重：高

16.有一个如下的结构体：
struct A{
    long a1;
    short a2;
    int a3;
    int *a4;
};
请问在64位编译器下用sizeof(struct A)计算出的大小是多少?(A)
A 24
B 28
C 16
D 18
解析：
32位编译器：32位系统下指针占用4字节
char ：1个字节
char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
long: 4个字节
long long: 8个字节
unsigned long: 4个字节
64位编译器：64位系统下指针占用8字节
char ：1个字节
char*(即指针变量): 8个字节
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
long: 8个字节
long long: 8个字节
unsigned long: 8个字节
Win64下：long 8字节、short 2字节、int 4字节、int* 8字节，C++中内存对齐，按最大长度对齐：8+（2+4+2（补齐2字节））+8 = 24字节
权重：高
备注：主要是了解32位和16位系统各种数据类型所占的存储空间

===

4. 写出嵌入式中经常使用的死循环有几种
   while (1) {};
   for(;;} 
   __loop
   goto loop;
   权重：高
   备注：写Linux驱动经常会用到goto

====

5. volatile 的含义，写出3种使用方式
   答：
   volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。
   一般说来，volatile用在如下的几个地方：
   (1)、中断服务程序中修改的供其它程序检测的变量需要加volatile；
   (2)、多任务环境下各任务间共享的标志应该加volatile；
   (3)、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义
   权重：高

====

6. 给定一整型变量a写两段代码：第一个设置a的bit3,第二个清除a的bit3
   答：
   #define BIT3 (0x1 << 3)
   static int a;
   void set_bit3(void)
   {
   a |= BIT3;
   }
   void clear_bit3(void)
   {
   a &= ~BIT3;
   }
   权重：高
   备注：写驱动经常用

====

7. 某工程中要设置一个绝对地址为0x67a9整形变量值为0xaa66，编译器是纯ANSI编译器。
   int *ptr;
   ptr = (int *)0x67a9;
   *ptr = 0xaa55;
   权重：高
   备注：掌握函数指针

====

8. 使用__interrupt定义一个ISR,评论代码有什么不妥
   
   __interrupt double compute_area (double radius)
   {
   double area = PI * radius * radius;
   printf(" Area = %f", area);
   return area;
   }
   1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
   2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
   3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
   4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
   不能传参数 不能有返回值 不能有打印语句 不应该使用浮点运算
   权重：高
   备注：写驱动时经常要写中断函数，没写好会有运行时错误

====
9.sizeof和strlen的区别?
答案：sizeof是运算符，在编译时即计算好了； 而strlen是函数，要在运行时才能计算。
还有对字符串来说，sizeof包含字符串结尾，strlen不包含
权重：高
备注：经常用

====
4 嵌入式系统相关问题
a) 对于整形变量A=0x12345678,请画出在little endian及big endian的方式下在内存中是如何存储的。
答：
little endian                big endian 刚好反过来
  高地址--〉 0x12      低地址--〉  0x12
                   0x34                          0x34
                   0x56                          0x56
  低地址--〉 0x78       高地址--〉 0x78
权重：较高
备注：很多CPU大端模式和小端模式是可以配置的

====
c) 中断(interrupt,如键盘中断)与异常(exception,如除零异常)有何区别?
异常：在产生时必须考虑与处理器的时钟同步，实践上，异常也称为同步中断。在处理器执行到由于编程失误而导致的错误指令时，或者在执行期间出现特殊情况(如缺页)，必须靠内核处理的时候，处理器就会产生一个异常。
所谓中断应该是指外部硬件产生的一个电信号，从cpu的中断引脚进入，打断cpu当前的运行；
所谓异常，是指软件运行中发生了一些必须作出处理的事件，cpu自动产生一个陷入来打断当前运行，转入异常处理流程。
权重：中

====
预处理器（Preprocessor）
1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
权重：高
备注：掌握宏定义

====
2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B))
这个测试是为下面的目的而设的：
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在  嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3) 懂得在宏中小心地把参数用括号括起来
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
        least = MIN(*p++, b);
权重：高
备注：掌握

====

3. 预处理器标识#error的目的是什么？
   如果你不知道答案，你是对的。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
   权重：中
   备注：有时候可以在头文件里用#error来判断是不是有需要传入的宏定义没有定义，如果是就用#error来退出编译，以便提示程序员修改

===
13、预处理器标识#error的目的是什么？
编译时就进行错误输出，比如必须的宏定义没有定义，必须的宏定义超出阈值
#error预处理指令的作用是，编译程序时，只要遇到#error就会生成一个编译错误提示消息，并停止编译。
指令用于报告编译时错误信息的；如果预处理方面有错误，那么就会打印#error指令后面的文本内容。
其语法格式为：
#error error-message
注意，宏串error-message不用双引号包围。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。系统所支持的error-message请查找相关信息获得！
权重：中

====
死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
   这个问题用几个解决方案。我首选的方案是：
   while(1)
   {
   }
   一些程序员更喜欢如下方案：
   for(;;)
   {
   }
   这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。
   第三个方案是用 goto
   Loop:
   ...
   goto Loop;
   应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
   权重：中

====
数据声明（Data declarations）

5. 用变量a给出下面的定义
   a) 一个整型数（An integer） 
   b)一个指向整型数的指针（ A pointer to an integer） 
   c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 
   d)一个有10个整型数的数组（ An array of 10 integers） 
   e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 
   f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 
   g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
   h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）
   答案是： 
   a) int a; // An integer 
   b) int *a; // A pointer to an integer 
   c) int **a; // A pointer to a pointer to an integer 
   d) int a[10]; // An array of 10 integers 
   e) int *a[10]; // An array of 10 pointers to integers 
   f) int (*a)[10]; // A pointer to an array of 10 integers 
   g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer 
   h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
   人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
   权重：高
   备注：不管你需不需要搜索才知道答案，反正工作中会用到

====
Static

6. 关键字static的作用是什么？
   这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
   1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
   2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
   3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
   大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
     static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
     static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
     static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
   权重：高
   备注：常用

====
Const
7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可 以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型 数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数 是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理 其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
权重：高
备注：常用

====
Volatile

8. 关键字volatile有什么含意?并给出三个不同的例子。
   一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
   1) 并行设备的硬件寄存器（如：状态寄存器）
   2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
   3) 多线程应用中被几个任务共享的变量
   回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
   假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
   1)一个参数既可以是const还可以是volatile吗？解释为什么。
   2); 一个指针可以是volatile 吗？解释为什么。
   3); 下面的函数有什么错误：
   int square(volatile int *ptr)
   {
        return *ptr * *ptr;
   }
   下面是答案：
   1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
   2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
   3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
   int square(volatile int *ptr) 
   {
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
   }
   由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
   long square(volatile int *ptr) 
   {
    int a;
    a = *ptr;
    return a * a;
   }
   权重：高
   备注：写驱动常用

====
位操作（Bit manipulation）

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
   对这个问题有三种基本的反应
   1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
   2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
   3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
   #define BIT3 (0x1 << 3)
   static int a;
   void set_bit3(void) 
   {
    a |= BIT3;
   }
   void clear_bit3(void) 
   {
    a &= ~BIT3;
   }
   一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
   权重：高
   备注：写驱动常用

====
访问固定的内存位置（Accessing fixed memory locations）

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
    这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
    int *ptr;
    ptr = (int *)0x67a9;
    *ptr = 0xaa55;
     A more obscure approach is: 
    一个较晦涩的方法是：
    *(int * const)(0x67a9) = 0xaa55;
    即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
    权重：高
    备注：常用

====
中断（Interrupts）

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
    __interrupt double compute_area (double radius) 
    {
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
    }
    这个函数有太多的错误了，以至让人不知从何说起了：
    1) ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
    2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
    3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
    4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
    权重：高
    备注：写驱动常用

代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式 计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
权重：中

====

13. 评价下面的代码片断：
    unsigned int zero = 0;
    unsigned int compzero = 0xFFFF; 
    /*1's complement of zero */
    对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
    unsigned int compzero = ~0;
    这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
    到 了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就 扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...
    权重：中

====
动态内存分配（Dynamic memory allocation）

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
    这 里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
    下面的代码片段的输出是什么，为什么？
    char *ptr;
    if ((ptr = (char *)malloc(0)) == NULL) 
    puts("Got a null pointer");
    else
    puts("Got a valid pointer");
    这 是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输 出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
    权重：较低

====
Typedef 
15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
权重：高
备注：常用typedef

====
晦涩的语法
16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。
权重：较低
备注：实际工作会用括号扩起来

====
14：写出float，bool，int 类型与零的比较，假设变量为X：
       Int ：    if（x == 0）
       Float：    if（x > 0.0000001 && x）
       Bool:      if(x == false)
权重：高

====
17：程序的局部变量存储在（栈）中，全局变量存储于（静态存储区），动态申请数据存储于（堆中）；
权重：较高

====
18：编写一个字符串复制函数：strcpy（const char *str，const char *str1）
void strcpy(const *char str, const chat *str1)
{
    if(*str1 == ’\0’) return;
    char *sp1, *sp2;
    sp1 = str;
    sp2 = str1;
    while(*sp2 != ’\0’)
    {
        *sp1 = sp2;
        sp1++;
        sp2++;
    }
}
权重：高

====
19:编写一个函数实现字符串翻转 void rechange（char *str）
void rechange（char *str）
{
    int len；
    char t；
    len = strlen（str）；
    for（int i = 0；len / 2；i++）
    {
        t = str;
        str = str[len - i - 1];
        str[len - i - 1] = t;
    }
}
权重：较高

====
20:编写一个函数实现字符串比较 int strcmp（char *str1，char *str2）,相等返回1，不相等返回0：
int strcmp（char *str1，char *str2）
{
    if（*str1 == ‘\0’ || *str2 == ’\0’） return;
    while(*str1 != ’\0’ && *str2 != ’\0’ && *str1 == *str2)
    {
        str1++；
        str2++；
    }
    if(*str1 == *str2)
        return 1;
    else return 0;
}
权重：高

====
一、 C语言基础
1、do{}while(); 和while(){};的区别？
答：do{}while();至少执行一次，while(){};可能一次也不会执行，前一个循环一遍再判断，后一个判断以后再循环 。
权重：高

====
3、 计算一个字节里（byte）里面有多少bit被置1
答：
int bit_set_counts_of_one_byte(char byte)
{
	int count = 0;
	while (byte) { // byte里面的1右移完之后会变为0
		if (byte & 1) {
			count++;
		}
		byte = byte >> 1;
	}
	return count;
}
或者：
for (; a; count ++) {
    a &= a - 1; // 一个二进制整数减1相当于把低位第一个1及之后的数取反，然后与原数相与就把低位第一个1清0了，从低到高等到所有的位都被清0，就会跳出循环。这种算法的效率跟1的个数有关，有多少1就循环多少次。老牛了。
}
权重：高

====
4、第12题:考查typedef类型定义,函数指针 
typedef int (*test) ( float * , float*) 
test tmp;  
tmp 的类型是？   
(a) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)        Pointer to function of having two arguments that is pointer to float 
(b) 整型 
(c) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型       Pointer to function having two argument that is pointer to float and return int 
(d) 以上都不是 
答案：C
权重：高

====
5、写出你所知道的C语言关键字 
答：bool char int long float double true false NULL short unsigned signed void
if else switch case continue default while do for goto return
static volatile inline define include auto register __interrupt extern
struct enum typedef union
其它重要函数：sizeof malloc free printf scanf memcpy memset strcmp strlen va_list va_start va_rag
权重：高

====
6、函数 int compare(int a, int b), 定义一个该函数的函数指针p:
答：
    int (*p)(int a, int b);
    p = compare;
或者 
    typedef int (*P_FUNC)(int a, int b);
    P_FUNC p = compare;
权重：高
备注：要掌握

====
15、16位short int 类型所能表示的数值下限与上限，如果使用printf的格式串”%d,%d”打印，其结果是__-32768 ，32767 ____；
这个题意义不大，不知道没什么稀奇，算一算或者网上查一查就行，知道存储的数据大概在什么数量级会溢出就行了。
备注：较高

====
16、如何定义Bool变量的TRUE和FALSE的值。
使用#define就可以：
#define TURE 1
#define FALSE 0
权重：高

====
17、switch()中不允许的数据类型是? 
答：实型 （即浮点型，因为switch是在集合中查找匹配，只能在整形中查找）
权重：较高

====
18、关于内存对齐的问题 
    答：编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能 地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问 ；然而，对齐的内存访问仅需要一次访问。
struct中的数据会进行字节对齐，有时候代码中需要手动取消字节对齐。
权重：高
备注：嵌入式应该掌握

====
24、内存对齐问题的原因?
 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据；
 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐，因为为了访问未对齐的内存，处理器需要做两次内存访问，
     而对齐的内存访问仅需要一次。
权重：高

====
20、有如下CAT_s结构体定义，
struct CAT_s{
  int ld; // 4  4
  char Color; // 1  1
  unsigned short Age; // 2+1  2+1
  char *Name; // 4  8
  void(*Jump)(void); // 4  8
} Garfield;
回答：
  1) 在一台64位的机器上，使用32位编译，Garfield变量占用多少内存空间？64位编译又是如何？
答：16字节（字节对齐） 24字节（字节对齐）
权重：高

====
  2) 使用32位编译情况下，给出一种判断所使用机器大小端的方法。
答：
方法一：
int tmp = 0x11223344
if (*(char *)tmp == 0x44) 小端模式
else 大端模式
方法二：
typedef union {
	int a;
	struct {
		char aa; // aa存放在低地址
		char bb;
		char cc
		char dd; // dd存放在高地址
	} b;
} MY_UNION;
MY_UNION tmp = 0x11223344;
if (tmp.b.aa == 0x44) 小端模式
else 大端模式
权重：高

====
22、C语言程序代码优化方法

  * 选择合适的算法和数据结构
  * 使用尽量小的数据类型
  * 使用自加、自减指令
  * 减少运算的强度
    求余运算（a=a%8改为a=a&7）
    平方运算（a=pow(a,2.0)改为a=a*a）
    用移位实现乘除法运算
  * 延时函数的自加改为自减
  * switch语句中根据发生频率来进行case排序
    权重：较高

====
23、宏和函数的优缺点？
 (1)、函数调用时，先求出实参表达式的值，然后带入形参。而使用带参数的宏只是进行简单的字符替换。
 (2)、函数调用是在程序运行时处理的，分配临时的内存单元；而宏展开则是在编译时进行的，在展开时并不分配内存单元，
   不进行值的传递处理，也没有“返回值”的概念。
 (3)、对函数中的实参和形参都要定义类型，二者的类型要求一致，应进行类型转换；而宏不存在类型问题，宏名无类型，
   它的参数也是无类型，只是一个符号代表，展开时带入指定的字符即可。宏定义时，字符串可以是任何类型的数据。
 (4)、调用函数只可得到一个返回值，而宏定义可以设法得到几个结果。
 (5)、使用宏次数多时，宏展开后源程序长，因为每次展开一次都使程序增长，而函数调用不使源程序变长。
 (6)、宏替换不占运行时间，只占编译时间；而函数调用则占运行时间（分配单元、保留现场、值传递、返回）。
权重：高

====
27、有定义char *str = “hello\n\0\n”,则strlen(str)的值是__6____；
(tip：’\0’即0x00为字符结束符标志，应该掌握) 
权重：高

====
28、完成宏定义，将int型变量a的第0位到第n位取反（右数最低位为第0位），其他位保持不变：
#define BIT_REVERSE(a,n)  ( (a)^ 1<<(n) )
权重：高
备注：掌握位的左移右移

====
29、枚举类型定义enum boolean {yes, no}; yes的数值是___0___；
权重：高
备注：必须知道enum默认从0、1、2往后赋值

====
39、头文件中的#ifndef/#define/#endif是干什么用的？ 
防止该头文件被重复引用
权重：高
备注：每个头文件都必须有，必须掌握。

====
试题4：为什么标准头文件都有类似以下的结构？
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus

extern "C" {
#endif 
/* */ 
#ifdef __cplusplus
}

#endif 
#endif /* __INCvxWorksh */ 

解答：
头文件中的编译宏
#ifndef　__INCvxWorksh
#define　__INCvxWorksh
#endif 
的作用是防止被重复引用。
作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为： 
void foo(int x, int y); 
该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是考这种机制来实现函数重载的。
为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。
权重：高

====
40、#include <filename.h>和#incldue "filename.h"有什么区别？ 
对于#include <filename.h>，编译器从标准头文件的路径开始搜索filename.h，在UNIX类的系统中通常是/usr/include。 
对于#include "filename.h"，编译器从包含该头文件的C源程序文件所在的路径开始搜索filename.h，如果没搜到再从标准头文件的路径开始搜索。 
权重：高
备注：养成好的编码习惯

====
43、已知char a[10]，问sizeof(a) strlen(a)各为多少
答：sizeof为10，strlen不确定，和存储的字符串相关，值为0-n。
权重：高

====
5、const与 ＃define相比有什么不同？ 
C++语言可以用const定义常量，也可以用#define定义常量，但是前者比后者有更多的优点： 
（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换中可能会产生意料不到的错误（边际效应） 
（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。在C++程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。 
常量的引进是在早期的C++版本中，当时标准C规范正在制定。那时，常量被看作一个好的思想而被包含在C中。但是，C中的const的意识是“一 个不能被改变的普通变量”。在C中，它总是占用内存，而且它的名字是全局符。C编译器不能把const看成是一个编译期间的常量。在C中，如果写： 
const bufsize = 100; 
char buf[bufsize]; 
尽管看起来好像做了一件合理的事情，但这将得到一个错误的结果。因为bufsize占用内存的某个地方，所以C编译器不知道它在编译时的值。在C语言中可以选择这样书写： 
const bufsize; 
这样写在C++中是不对的，而C编译器则把它作为一个声明，这个声明指明在别的地方有内存分配。因此C默认const是外部连接的，C++默认const是内部连接的。这样，如果在C++中想完成与C中同样的事情，必须用extern把内部连接改写外部连接： 
extern const bufsize; // declaration only 
这种方法也可用在C语言中。在C语言中使用限定符const不是很有用，即使是在常数表达式里（必须在编译期间被求出）想使用一个已命名的值，使用const也不是很有用的。C迫使程序员在预处理里使用#define。
权重：较高

====
6、编译和链接有什么不同？（如外部符号的处理）
 编译生成的是目标文件(object  *.o);
 编译过程中对于外部符号不做任何解释和处理。外部符号对应的就是“符号”
 链接生成的是可执行程序
 链接将会解释和处理外部符号。外部符号对应的是地址
权重：较高

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：
#define NTBL (sizeof(table)/sizeof(table[0]))
权重：高
备注：常用

====
3、将一个链表逆序 
LinkList *reverse(LinkList *head)
{
    LinkList *p1,*p2 = NULL,*p3 = NULL;
    if(head == NULL || head->next == NULL)
        return head;
    p1 = head->next;
    while(p1!=NULL)
    {
        p3 = p1->next;
        p1->next = p2;
        p2 = p1;
        p1 = p3;
    }
    head->next = p2;
    // head = p2;

    return head; 
}
权重：高
备注：常考

====
3、在一个字符串中找到可能的最长的子字符串（子字符串从前往后匹配最长的） 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *commanstring(char shortstring[], char longstring[])
{
    int i,j;
    char *substring = malloc(256);
    if(strstr(longstring,shortstring)!=NULL)
        return shortstring;
    for(i=strlen(shortstring)-1;i>0;i--)
    {
        for(j=0;j<=strlen(shortstring)-i;j++)
        {
            memcpy(substring,&shortstring[j],i);
            substring[i]='\0';
            if(strstr(longstring,substring)!=NULL)
                return substring;
        }
    }
    return NULL;
}
void main(void)
{
    char *str1 = "aocdfe";
    char *str2 = "pmcdfa";
    char *comman = NULL;
    if(strlen(str1)>strlen(str2))
        comman= commanstring(str2,str1);
    else
        comman = commanstring(str1,str2);
    printf("the longest comman string is:%s\n",comman);
}
权重：高
备注：常考

====
试题2：以下为Windows NT下的32位C++程序，请计算sizeof的值
void Func ( char str[100] )
{
    sizeof( str ) = ?
}
void *p = malloc( 100 );
sizeof ( p ) = ? 
解答：
sizeof( str ) = 4
sizeof ( p ) = 4 
剖析：
Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
数组名的本质如下：
(1) 数组名指代一种数据结构，这种数据结构就是数组；
例如：
char str[10];
cout << sizeof(str) << endl; 
　　输出结果为10，str指代数据结构char[10]。
(2) 数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
char str[10]; 
str++; //编译出错，提示str不是左值　 
(3) 数组名作为函数形参时，沦为普通指针。
Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。
权重：高
备注：理解

====





```c
#include <stdio.h>
int a = 0;
int b;
static char c;
int main(int argc, char *argv[])
{
    char d = 4;
    static short e;
    a++;//a = a + 1 所以a = 2
    b = 100;//给b赋值100
    c = (char)++a;
    e = (++d)++;
    printf("a=%d, b=%d, c=%d, d= %d, e=%d", a, b, c, d, e);
    return 0;
}
```

a) 写出程序输出

答：a = 2, b = 100, c = 2, d = 6, e = 5

b) 编译器如果安排各个变量(a,b,c,d)在内存中的布局(eg. stack,heap,data section,bss section), 最好用图形方式描述。

程序编译后，生成一个map，动态分配内存放到堆中，函数内变量放在栈中，全局未初始化变量放在bss中，代码code、全局常量放在text中，
bss段：
　　bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。
　　bss是英文Block Started by Symbol的简称。
　　bss段属于静态内存分配。 
data段：
　　数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。
　　数据段属于静态内存分配。
text段：
　　代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。
　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。
　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 
堆（heap）：
　　堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
　　当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
　　当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。
栈(stack)：
　　 栈又称堆栈，是用户存放程序临时创建的局部变量，
　　也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。
　　除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
　　由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。
　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 
一个程序本质上都是由 bss段、data段、text段三个组成的。
　　这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念。
　　而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。
    在采用段式内存管理的架构中（比如intel的80x86系统），bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，
　　一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。
    比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。
　　text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；
　　而bss段不在可执行文件中，由系统初始化。
权重：中
备注：系统移植开发需要手动配置堆栈大小，合理对内存的使用按照实际的使用进行分配。

---

13.下面这段代码的输出结果为：(A)
void change(int *a, int &b, int c)
{
    c = *a;
    b = 30;
    *a = 20;
}
int main()
{
    int a = 10, b = 20, c = 30;

    change(&a, b, c);
    printf(“%d,%d,%d,”, a, b, c);
    
    return 0;

}
A 20，30，30
B 10，20，30
C 20,30，10
D 10,30，30
解析：
该题考察函数传参问题。
1，指针传参 -> 将变量的地址直接传入函数，函数中可以对其值进行修改。
2，引用传参 -> 将变量的引用传入函数，效果和指针相同。
3，值传参 -> 在传参过程中，首先将c的值复制给函数c变量，然后在函数中修改的即是函数的c变量，然后函数返回时，系统自动释放变量c。而对main函数的c没有影响。
a为指针传递，b为引用传递，c为值传递。
*a = 20; b = 30; a和b的值确实发生了修改。而c只是将值复制到形参，在函数内的操作并不会影响c的实际值，因此c还是为原来的30.
权重：较低
备注：C语言实际使用只会用到指针传参

---

1. 写出函数执行的结果：
   void join(int x) //递归运算
   {
    x++;
    if (x >= 7) return;
    join(x);
    printf("%d", x); //注意别漏掉这个打印信息!
   }

int main()
{
	int x = 3,y = 0;

	join(x);
	printf("OK\n");
	while (--x)
	{
		for(y = 0; y < 4; y++)
		{
			printf("x = %d,y = %d\n", x, y);
			if (y >= 1) break;
			else continue;
		}
	}
	printf("over!");

}
654OK
x = 2,y = 0
x = 2,y = 1
x = 1,y = 0
x = 1,y = 1
over!
权重：较高
备注：看得懂代码

---

8、定义函数时，缺省函数的类型声明，则函数类型取缺省类型
A.void
B.char
C.float
D.int
参考答案：D

---

36、 下面是一个16x16的黑白图标：
static unsigned short stopwatch[] = { 0x07c6, 0x1ff7, 0x383b, 0x600c, 0x600c, 0xc006, 0xc006,
0xdf06, 0xc106, 0xc106, 0x610c, 0x610c, 0x3838, 0x1ff0, 0x07c0, 0x0000, }; 
如何修改声明，可以使之在源代码中形象地表现出图形的模样。 
答：用二进制字符串代替16进制。但是C语言不直接支持二进制表示，需要写一些中间函数，将0x07c6存储成0b0000011111000110（字符串），使用时再用自写函数转换一遍。
权重：中
备注：可用于点阵图显示

---

1、 请写出下列代码的输出内容
#include <stdio.h>
int main(void)
{
	int a, b, c, d;
	a = 10;
	b = a++; // b=10 a=11
	c = ++a; // c=12 a=12
	d = 10 * a++; // d=120 a=13
	printf(“b，c，d：%d，%d，%d”，b，c，d）;
	

	return 0;

} 
答：b,c,d:10,12,120。
权重：较高
备注：考察自增自减

----

约定:
1) 下面的测试题中，认为所有必须的头文件都已经正确的包含了
2)数据类型 
char 一个字节 1 byte
int 两个字节 2 byte (默认16位系统，认为整型是2个字节)
long int 四个字节 4 byte
float 四个字节4 byet
double 八个字节 8 byte
long double 十个字节 10 byte
pointer 两个字节 2 byte(默认16位系统,地址总线只有16位)

---

2、 第1题: 考查对volatile关键字的认识
#include <setjmp.h>
static jmp_buf buf;
main()
{
    volatile int b; // 该值每次从硬件中直接读取，不为了效率从缓存中读取上次的值

    b = 3;
    if (setjmp(buf) != 0) { // setjmp : 设置非局部跳转 /* setjmp.h */ 
        printf("%d ", b);
        exit(0);
    }
    b = 5;  
    longjmp(buf , 1);

}
请问，这段程序的输出是 (a) 3  (b) 5  (c) 0  (d)以上均不是 
答案b；
权重：较低

第1题: (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时，意味着 给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变; 该变量随时会被一个中断程序，或另一个进程
改变了.
volatile 不会被编译器优化影响，在longjump 后,它的值 是后面假定的变量值,b最后的值是5,所以5被打印出来.

setjmp : 设置非局部跳转 /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement following the one calling setjmp.Returns 0 when it is initially called.

Lonjjmp: 执行一个非局部跳转 /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.

Note: Test program without volatile qualifier (result may very)
更详细介绍，请参阅 C语言的setjmp和longjmp

---

3、第2题:考查类型转换
main(){
    struct node {
        int a;
        int b;
        int c;
    }; // 结构体的成员在内存中的地址是按照他们定义的位置顺序依次增长的
    struct node s = { 3, 5, 6 };
    struct node *pt = &s;
    printf("%d" ,  *(int*)pt);  
}
这段程序的输出是: (a) 3 (b) 5 (c) 6 (d) 7
答案：a
权重：高
备注：理解结构体和取址

第2题: (a)
结构题的成员在内存中的地址是按照他们定义的位置顺序依次增长的。如果一个结构体的指针被看成它的第一个成员的指针,那么该指针的确指向第一个成员

---

4、第3题:考查递归调用
int foo (int x, int n)
{
   int val;
   val = 1;

   if ( n > 0) {
       if (n%2 == 1) val = val *x; // 如果是奇数次幂, x(val)要先乘上一次
       val = val * foo(x*x, n / 2);
   }

   return val;
}
这段代码对x和n完成什么样的功能(操作)? (a) x^n (x的n次幂) (b) x*n(x与n的乘积) (c) n^x(n的x次幂) (d) 以上均不是
答案：a，用一两个数代进去算一下可以得出结果。
权重：中
备注：嵌入式中计算少用递归，堆栈太小会溢出。

第3题: (a)
这个程序的非递归版本 
int what ( int x , int n)
{
    int val;
    int product;
    product = 1;
    val = x;

    while (n > 0)
    {
        if (n%2 == 1) 
        product = product * val; /*如果是奇数次幂, x(val)要先乘上一次,; 偶数次幂,最后返回时才会到这里乘以1*/
        val = val * val; 
        n = n / 2; 
    }
    return product;

}
/* 用二元复乘策略 */
算法描述
(while n > 0) 
{
    if next most significant binary digit of n( power) is one
    then multiply accumulated product by current val , 
    reduce n(power) sequence by a factor of two using integer division .
    get next val by multiply current value of itself 
}

---

5、第4题:考查指针
void main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int *ptr =  (int *)(&a + 1); // &a取址后以a[0-4]整个数组为步进，a以a[0]也就是int为步进
    printf("%d %d" , *(a + 1), *(ptr - 1));
}
这段程序的输出是: (a) 2 2 (b) 2 1 (c) 2 5  (d) 以上均不是
答案：c
权重：较高
备注：需要知道数组取址后的涵义，因为实际中会用到
    之所以写成void main(void){} 而不写成main(){} 是要告诉别人你就是要用void，而不是你写代码时遗漏了

第4题: (c)
a的类型是一个整型数组,它有5个成员
&a的类型是一个整型数组的指针
所以&a + 1指向的地方等同于 a[6]

所以*(a+1) 等同于a[1]
ptr等同 a[6], ptr-1就等同与a[5]

---

6、第5题:考查多维数组与指针
void foo(int [][3]);
void main(void)
{
    int a [3][3]= { { 1,2,3}, {4,5,6}, {7,8,9} };
    foo(a);
    printf("%d", a[2][1]);
}
void foo(int b[][3])
{
   ++ b;
   b[1][1] = 9;
}
这段程序的输出是:  (a) 8 (b) 9 (c) 7  (d)以上均不对 
答案：b
权重：较高
备注：需要知道数组取址后的涵义，因为实际中会用到

第5题: (b)
题目自身就给了足够的提示
b[0][0] = 4
b[1][0] = 7

---

7、第6题目:考查逗号表达式
void main(void)
{
    int a, b, c, d;

    a = 3;
    b = 5;
    c = a, b;   // 逗号表达式的优先级最低
    d = (a, b); // 逗号表达式的值是最右边的值
    printf("c=%d", c);
    printf("d=%d", d);

}
这段程序的输出是:(a) c=3 d=3 (b) c=5 d=3 (c) c=3 d=5 (d) c=5 d=5
答案：c
权重：中
备注：逗号操作符在实际工作中会用到，用于简写代码

第6题: (c)
考查逗号表达式,逗号表达式的优先级是很低的，比赋值(=)的优先级低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..

E1, E2, ..., En
上面这个表示式的左右是,E1, E2,... En的值被分别计算出来，En计算出来的结构赋给整个逗号表达式 
c=a,b; / *yields c=a* /
d=(a,b); /* d =b */

---

8、第7题:考查指针数组 
void main(void) 
{
    int a[][3] = {1, 2, 3, 4, 5, 6};
    int (*ptr)[3] = a;  // 指针数组ptr为123，ptr+1为456，ptr+2为非法的不确定
    printf("%d %d ", (*ptr)[1], (*ptr)[2]);
    ++ptr;
    printf("%d %d", (*ptr)[1], (*ptr)[2]);
}  
这段程序的输出是:   (a) 2 3 5 6 (b) 2 3 4 5 (c) 4 5 0 0 (d) 以上均不对
答案：a
权重：较高
备注：指针和数组都是嵌入式中用得非常多的

第7题: (a)
ptr是一个数组的指针，该数组有3个int成员

---

9、第8题:考查函数指针 
int *f1(void) 
{
    int x =10;
    return (&x);    // 函数内的变量退出后会释放
}   
int *f2(void) 
{
   int *ptr;
   *ptr = 10;       // 指针指向常量
   return ptr;      // 函数内的常量指针也不要返回
}
int *f3(void) 
{
   int *ptr;
   ptr = (int *)malloc(sizeof(int)); // 分配的内存记得取消就可以了
   return ptr; 
}  
上面这3个函数哪一个最可能引起指针方面的问题   (a) 只有 f3 (b) 只有f1 and f3 (c) 只有f1 and f2 (d) f1 , f2 ,f3
答案：c
权重：较高
备注：malloc后一定要free释放，实际工作中用的多

第8题: (c)
f1显然有问题，它返回一个局部变量的指针，局部变量是保存在stack中的,退出函数后，局部变量就销毁了，保留其指针没有意义，因为其指向的stack空间可能被其他变量覆盖了
f2也有问题, ptr是局部变量，未初始化，它的值是未知的，*ptr不知道指向哪里了，直接给*ptr赋值可能会覆盖重要的系统变量，这就是通常说的野指针的一种

---

10、第9题:考查自加操作(++) 
void main(void) 
{
   int i = 3;
   int j;  
   j = sizeof(++i + ++i); // sizeof中的表达式编译器不计算，记住就行，这是算int大小的
   printf("i=%d j=%d", i, j); 
} 
这段程序的输出是: (a) i=4 j=2 (b) i=3 j=2 (c) i=3 j=4 (d) i=3 j=6
答案：b（16位cpu）
权重：较低

第9题: (b)
sizeof 操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.( ++i + ++ i )是不会执行的，所以
i 的值还是3

---

11、第10题:考查形式参数，实际参数，指针和数组 
void f1(int *, int);  
void f2(int *, int);  
void (*p[2]) (int *, int); // 函数指针数组
void main(void) 
{
   int a;
   int b;

   p[0] = f1;
   p[1] = f2;
   a = 3;
   b = 5;
   p[0](&a, b); 
   printf("%d\t %d\t", a, b); // 5 5
   p[1](&a, b); 
   printf("%d\t %d\t", a, b); 
}   
void f1(int *p, int q) 
{
   int tmp;
   tmp = *p; // 3
   *p = q; // a = 5
   q = tmp; 
}  
void f2(int* p, int q) 
{
   int tmp;
   tmp = *p;
   *p = q;
   q = tmp; 
}    
这段程序的输出是: (a) 5 5 5 5 (b) 3 5 3 5 (c) 5 3 5 3 (d) 3 3 3 3 
答案：a
权重：中

第10题: (a)
很显然选a.
f1交换*p 和 q的值，f1执行完后, *p 和 q的值的确交换了, 但 q的改变不会影响到 b的改变, *p 实际上就是 a 
所以执行f1后, a=b=5
这道题考查的知识范围很广,包括typedef自定义类型,函数指针,指针数组
void(*p[ 2 ]) (int *, int);
定义了一个函数指针的数组p,p有两个指针元素. 元素是函数的指针，函数指针指向的函数是一个带2个参数,返回void的函数，所带的两个参数是 指向整型的指针，和整型
p[ 0 ] = f1; p[ 1 ] = f2 contain address of function .function name without parenthesis represent address of function Value and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by value f1, f2 can not effect b

---

12、第11题:考查自减操作(--) 
void e(int);     
void main(void) 
{
   int a;
   a = 3;
   e(a); 
}   
void e(int n) 
{
   if (n > 0) {
       e(--n);
       printf("%d", n);
       e(--n);   
   } 
}  
这段程序的输出是:   (a) 0 1 2 0 (b) 0 1 2 1 (c) 1 2 0 1 (d) 0 2 1 1
答案：a
权重：中
备注：在纸上推演一下

第11题: (a)
考查--操作和递归调用,仔细分析一下就可以了

---

13、第13题:数组与指针的区别与联系 
void main(void) 
{
   char p;
   char buf[10] = {1, 2, 3, 4, 5, 6, 9, 8};
   p = (buf + 1)[5];
   printf("%d" , p); 
}  
这段程序的输出是:  (a) 5 (b) 6 (c) 9  (d) 以上都不对
答案：c
权重：高
备注：指针很重要，数组名也重要，数组名自增就是移到其中元素的下一位

第13题: (c)
考查什么时候数组就是指针.对某些类型T而言，如果一个表达式是 T[] (T的数组), 这个表达式的值实际上就是指向该数组的第一个元素的指针.所以(buf+1)[5]实际上就是*(buf +6)或者buf[6]

---

14、第14题: 考查指针数组的指针 
void f(char **);  
void main(void)
{
    char *argv[] = {"ab", "cd", "ef", "gh", "ij", "kl"}; // argv是指针数组
    f(argv); 
}   
void f(char **p) // p是指针数组，*p是一个字符串的指针，**p是字符串中第一个字符
{
    char *t; 
    t = (p += sizeof(int))[-1];
    printf("%s", t); 
}  
这段程序的输出是:  (a) ab (b) cd (c) ef(d) gh
答案：b
权重：较高
备注：这里的默认是16位系统，sizeof(int)是2，要理解p+2之后指向"ef"，再[-1]后再指向"cd"

第14题: (b)
sizeof(int)的值是2,所以p+=sizeof(int) 指向 argv[2],这点估计大家都没有什么疑问
(p+=sizeof(int))[-1] 指向 argv[1],能理解吗，因为(p+=sizeof(int))[-1] 就相当于 (p+=2)[-1] ,也就是(p+2-1)

---

15、第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样 
#include <stdarg.h> 
int ripple(int, ...);  
void main(void)
{
    int num;
    num = ripple(3, 5, 7); // 3不是第一个参数，3是参数的总个数，第一个参数为5
    printf("%d", num); 
}
int ripple(int n, ...) 
{
    int i, j;
    int k;  
    va_list p;  
    k = 0;
    j = 1;
    va_start(p, n);      
    for (; j < n; ++j) {        // 注：自己写代码时把j=1放到for表达式里，不要让人误以为你是代码写漏了
        i = va_arg(p, int);     // 第一次取出5，第二次取出7
        for (; i; i &= i-1)     // 循环次数为数字中有过少个1
            ++k;
    }
    return k; 
}  
这段程序的输出是:  (a) 7 (b) 6 (c) 5 (d) 3
答案：c
权重：较高
备注：实际工作中经常会用到，例如自定义不同级别的调试输出

第15题: (c)
在C编译器通常提供了一系列处理可变参数的宏，以屏蔽不同的硬件平台造成的差异，增加程序的可移植性。这些宏包括va_start、 va_arg和va_end等。 
采用ANSI标准形式时，参数个数可变的函数的原型声明是： 
type funcname(type para1, type para2, ...) 
这种形式至少需要一个普通的形式参数，后面的省略号不表示省略，而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器，对这个可变长参数的实现不一样 ，gcc4.x中是内置函数.
关于可变长参数,可参阅 
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html

程序分析
va_list p; /*定义一个变量 ,保存 函数参数列表 的指针*/
va_start( p , n); /*用va_start宏 初始化 变量p, 
    va_start宏的第2个参数n ,
    是一个固定的参数,
    必须是我们自己定义的变长函数的最后一个入栈的参数
    也就是调用的时候参数列表里的第1个参数*/
for (; j<n; ++j) /* j从1开始, 遍历所有可变参数 */
{
    i = va_arg( p , int);   /*va_arg取出当前的参数, 并认为取出的参数是一个整数(int) */
    for (; i; i &=i-1 )     /*判断取出的i是否为0*/
        ++k;                /* 如果i不为0, k自加, i与i-1进行与逻辑运算, 直到i 为0这是一个技巧，下面会谈到它的功能*/
}
当我们调用ripple函数时，传递给ripple函数的 参数列表的第一个参数n的值是3 .
va_start 初始化 p士气指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).
每次对 va_arg的调用，都将返回一个参数，并且把 p 指向下一个参数.
va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数
(; i; i&=i-1) k++ /* 计算i有多少bit被置1 */

5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c

举个例子，就很好理解了
令 i= 9 = 1001
i-1 = 1000 
(i-1) +1 = i
1000
+1
1 001
因为i与i-1的最右边的那位(最低位) 肯定是不同，如果i1,i-1肯定是0，反之亦然. i & i-1 这个运算，在二相补的数字系统中，将会 消除最右边的1位

---

16、第16题:考查静态变量的知识 
int counter (int i) 
{
    static int count = 0; // 函数内静态变量函数退出后值会保持，且不会再次初始化
    count = count + i;
    return (count); 
} 
void main(void)
{  
     int i, j;
     for (i = 0; i <= 5; i++)
         j = counter(i); // 0-5等加数列=3*（0+5）
}  
本程序执行到最后,j的值是:(a) 10 (b) 15 (c) 6 (d) 7
答案：b
权重：高
备注：静态变量必须掌握，用的多

第16题: (b)
答案是 (b)
这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,这与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2; /* count = count +i */
第四次调用 counter(3) count = 3+3;
第五次调用 counter(4) count = 6+4;
第六次调用 counter(5) count = 10+5;
命题人信息 Ashok K. Pathak a member ( Research Staff ) at Bharat Electronics Limited (CRL) , Ghaziabad. He has been developing embedded application for the past five years .Ashok holds a M.E in computer science and engineering . Ashok recently completed a book about' "Advanced Test in C and Embedded System Programming" , Published by BPB , ND . 

---

17、设
#define N 3
#define Y(n) ((N+1)*n)  // 注：小n本应该在周围放上小括号，自己写代码时要注意
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B Y(5+1) 传递过去的应该是6，而不是简单的把5+1给替换掉
权重：中
备注：宏定义函数应该把参数用括号括起来

---

18、下列转义字符中错误的是
A.′\000′
B.′\14′
C.′\x111′// 十六进制只有两个数
D.′\2′
参考答案：C error C2022: '273' : too big for character
权重：中

---

19、下面的代码输出是什么，为什么？ 
void foo(void)
{ 
    unsigned int a = 6;
    int b = -20;
    (a + b > 6) ? puts("> 6") : puts("<= 6");
}
权重：中
备注：测试是否懂得C语言中的整数自动转换原则。无符号整型问题的答案是输出是 “>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。

---

选择题
1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)+c计算结果不一致的是
A.(a+b)*c/2
B.(1/2)*(a+b)*c
C.(a+b)*c*1/2
D.c/2*(a+b)
参考答案：B，因为a,b,c三个变量都是浮点数，所以在B答案中其结果是0，因为在计算1/2是就是0，如果改成1/2.0就正确了。
权重：高
备注：自己写代码时要注意避免整数相除之后变成0

---

3:下述程序执行后的输出结果是
void main(void)
{
    int x = 'f';
    printf("%c\n", 'a' + (x -'a' + 1));
}
A.g
B.h
C.i
D.j
参考答案：A
权重：较高
备注：了解ASCII的存储规则

---

4:C语言中，下列运算符优先级最高的是
A.！
B.％
C.>>
D.==
参考答案：A
权重：中
备注：单目运算符优先级更高

---

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。
A.*a
B.a [ 0 ]
C.a
D.a++
参考答案：D
权重：中
备注：不能自加，只能加1，因为+1是加一个(int)大小地址偏移

---

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是
A.15
B.31
C.3
D.1
参考答案：C
权重：较高
备注：右移相当于除以2

---

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；
A.5
B.7
C.9
D.11
参考答案：B
权重：较高
备注：主要考宏定义函数需要给参数加上括号，不加会产生错误计算结果

---

10:下列各个错误中，哪一个不属于编译错误
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义
参考答案：A
权重：重
备注：编译时是否报错

---

11:下列程序段运行后， x 的值是( )
a = 1; b = 2; x = 0;
if (!(--a)) x--;
if (!b) x=7; else ++x;
A.0
B.3
C.6
D.7
参考答案：A
权重:中
备注：自增放在变量前面：先自加再使用；放在后面：先使用再自加

---

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个
A.非零整数
B.浮点数
C.0
D.字符
参考答案： A
权重：较高
备注：记住大多数string.h中的函数用法，常用的strlen strstr strcmp strcat strcpy...

---

18:设struct
{
    short a;
    char b;
    float c;
} cs;
则sizeof(cs)的值是
A.4
B.5
C.6
D.7
参考答案： D
权重：较高
备注：其实答案应该是8，因为一般都是默认有字节对齐，字节不对齐的情况需要显示声明。
需要了解如何将结构体按不同的字节对其，特别是使用在通讯链路中的数据

19:若变量已正确定义，表达式( j=3 ， j++ )的值是
A.3
B.4
C.5
D.0
参考答案：A
权重：较高
备注：理解逗号运算符

---

简答题
24:
void main(void)
{
    int c;

　　  while ((c = getchar()) != '\n')
　　  switch (c - '2')
    {
    case 0:
　　  case 1: putchar(c+4); break;
　　  case 2: putchar(c+4); break;
　　  case 3: putchar(c+3); break;
　　  default:putchar(c+2); break;
　　  }

　　  printf("\n");
}
运行时输入： 2473 ，输出结果：
参考答案：6897
权重：中

---

29:执行下述程序的输出结果是  ABCDEFCDEFEF  。
char b[]= "ABCDEF";
void main(void)
{
    char *bp;
    for (bp = b; *bp; bp += 2)
        printf("%s",bp);
    printf("\n");
}
权重：中

---

1.
#define pi 3.14
#define Area(R) pi*R*R //考察R应该加括号，不加括号会出错
void main(void)
{
    int r1 = 5, r2 = 2;
    double s = 0;
    s = Area(r1 - r2);
    printf("The area is %f",s);
}
求结果： The area is 3.700000
权重：中

---

2.函数 int compare(int a,int b),定义该函数的函数指针P
答：int(*p)(int, int);
p = compare;
权重：高
备注：需要掌握函数指针

---

4、将整数转换为字符串
答：
#include <stdio.h>
#include <string.h>
void reverse(char s[])
{ //字符串反转

    int c, i = 0, j;
    for(j = strlen(s) - 1; i < j; j--)
    {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
        i++;
    }
}
void IntegerToString(char s[], int n)
{
    int i = 0, sign;
    if((sign = n) < 0)  //如果是负数，先转成正数 
        n = -n;
    do //从个位开始变成字符,直到最高位,最后应该反转
    {
        s[i++] = n % 10 + '0';
    } while((n = n / 10) > 0);

    //如果是负数，补上负号
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';//字符串结束

    reverse(s);
}
void main(void)
{
    int m;
    char c[100];
    m = 215;
    IntegerToString(c, m);
    printf("integer = %d string = %s\n", m, c);
}
权重：较高

---

5、字符串转换为整数
答：
#include <stdio.h>
#include <string.h>
int Atoi(char str[])
{
    int i;
    int weight = 1; // 权重
    int rtn = 0; // 用作返回

    for(i = strlen(str) - 1; i >= 0; i--)
    {

        rtn += (str[i] - '0') * weight;
        weight *= 10; // 增重
    }

    return rtn;

}
void main(void)
{
    char str[32];

    printf("Input a string :");
    gets(str);
    printf("%d\n", Atoi(str));

}
权重：高
备注：知道‘0’字符可以直接也表示0所代表的ASCII码

---

6、将一个字符串逆序 
答： 
#include <stdio.h>
#include <string.h>
char *strconv(char *p)
{
    int length = strlen(p);
    char *ptr = p;
    char *ptr_1 = p + length -1;
    while(ptr < ptr_1)
    {
    char c = *ptr;
    *ptr = *ptr_1;
    *ptr_1 = c;
    ++ptr;
    --ptr_1;
    }
    return p;
}
int main(void)
{
    char str[] = "abcdef1234";
    char *p;
    p = strconv(str);
    printf("%s",p);
    return 1;
}
权重：高
备注：实际工作中经常需要对字符串进行各种操作

---

4.分析下面的程序，并且得出结果
struct s1 
{
    int i: 8; 
    int j: 4; 
    int a: 3; 
    double b; 
}; 
struct s2 
{ 
    int i: 8; 
    int j: 4; 
    double b; 
    int a: 3; 
}; 
printf("sizeof(s1)= %d\n", sizeof(s1)); 
printf("sizeof(s2)= %d\n", sizeof(s2)); 
result: 16, 24 
解析：
第一个struct s1 
{ 
    int i: 8; 
    int j: 4; 
    int a: 3; 
    double b; 
}; 
理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8 字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。 

1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：    
   struct bs   
   {   
    unsigned a:4   
    unsigned :0 /*空域*/   
    unsigned b:4 /*从下一单元开始存放*/   
    unsigned c:4   
   }   
   在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。 
2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位
3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：  
   struct k   
   {   
    int a:1   
    int :2 /*该2位不能使用*/   
    int b:3   
    int c:2   
   };   
   从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。
   权重：高
   备注：在通讯协议中对数据处理经常会精确到位。

---

5.在对齐为4的情况下 分析下面程序的结果
struct BBB 
{ 
    long num； 
    char *name; 
    short int data; 
    char ha; 
    short ba[5]; 
} *p; 
p = 0x1000000; 
p + 0x200 = ____; 
(Ulong)p + 0x200 = ____; 
(char*)p + 0x200 = ____; 
解答：假设在32位CPU上， 
sizeof(long) = 4 bytes 
sizeof(char *) = 4 bytes 
sizeof(short int) = sizeof(short) = 2 bytes 
sizeof(char) = 1 bytes 
由于是4字节对齐， 
sizeof(struct BBB) = sizeof(*p) 
= 4 + 4 + 2 + 1 + 1/*补齐*/ + 2*5 + 2/*补齐*/ = 24 bytes
p = 0x1000000; 
p + 0x200 = ____; 
= 0x1000000 + 0x200*24   指针加法，加出来的是指针类型的字节长度的整倍数。就是p偏移sizeof(p)*0x200.
(Ulong)p + 0x200 = ____;
= 0x1000000 + 0x200   经过ulong后，这已经不再是指针加法，而变成一个数值加法了
(char *)p + 0x200 = ____; 
= 0x1000000 + 0x200 * 1  结果类型是char*，这儿的1是char的数据类型是1字节
权重：高
备注：需要理解结构体的数据存储规则和对齐规则，知道怎么手动按1字节对齐、2字节对齐、4字节对齐

---

6.分析一下下面程序的输出结果
#include <iostream.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
typedef struct AA
{
    int b1:5;
    int b2:2;
} AA;
void main(void)
{
    AA aa;
    char cc[100];
    strcpy(cc, "0123456789abcdefghijklmnopqrstuvwxyz");
    memcpy(&aa, cc, sizeof(AA));
    cout << aa.b1 <<endl;
    cout << aa.b2 <<endl;
}
答案： -16和１
首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.
经过strcpy和memcpy后,aa的4个字节所存放的值是:
0,1,2,3的ASC码，即00110000,00110001,00110010,00110011
所以，最后一步：显示的是这４个字节的前５位，和之后的２位
分别为：10000,和01
因为int是有正负之分,所以是-16和1
权重：较高

---

7.改错：
#include <stdio.h>
int main(void) {
    int **p;
    int arr[100];
    p = &arr;
    return 0;
}
答案：
int **p; //二级指针
&arr; //得到的是指向第一维为100的数组的指针
应该这样写
#include <stdio.h>
int main(void)
{
    int **p, *q;
    int arr[100];
    q = arr;
    p = &q;
    return 0;
}
权重：高
备注：数组名是指向整个数组，对数组名取址，还是指向整个数组，采用+1运算时步进是一样的

---

10.写出运行结果
#include <stdio.h>
#include <string.h>

#define STRCPY(a, b) strcpy(a##_p, #b)
#define STRCPY1(a, b) strcpy(a##_p, b##_p)
int main(void)
{
    char var1_p[20];
    char var2_p[30];

    strcpy(var1_p, "aaaa");
    strcpy(var2_p, "bbbb");

    STRCPY1(var1, var2);
    STRCPY(var2, var1);

    printf("var1 = %s\n", var1_p);
    printf("var2 = %s\n", var2_p);

    return 0;
}
答案：var1 = bbbb
var2 = var1
宏中"#"和"##"的用法
权重：高
备注：需要知道宏定义中直接将变量名变成字符串#，和将两个变量名拼接成字符串的用法##，实际工作中会用
扩展阅读：
一、一般用法
我们使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起.
用法:
#include <cstdio>
#include <climits>
using namespace std;
#define STR(s) #s
#define CONS(a,b) int(a##e##b)
int main(void)
{
    printf(STR(vck)); // 输出字符串"vck"
    printf("%d\n", CONS(2,v3)); // 2e3 输出:2000
    return 0;
}
二、当宏参数是另一个宏的时候
需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开.
1, 非'#'和'##'的情况
#define TOW (2)
#define MUL(a,b) (a*b)
printf("%d*%d=%d\n", TOW, TOW, MUL(TOW,TOW));
这行的宏会被展开为：
printf("%d*%d=%d\n", (2), (2), ((2)*(2)));
MUL里的参数TOW会被展开为(2).
2, 当有'#'或'##'的时候
#define A (2)
#define STR(s) #s
#define CONS(a,b) int(a##e##b)
printf("int max: %s\n", STR(INT_MAX)); // INT_MAX #include<climits>
这行会被展开为：
printf("int max: %s\n", "INT_MAX");
printf("%s\n", CONS(A, A)); // compile error
这一行则是：
printf("%s\n", int(AeA));
A不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏.
加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数.
#define A (2)
#define _STR(s) #s
#define STR(s) _STR(s) // 转换宏
#define _CONS(a,b) int(a##e##b)
#define CONS(a,b) _CONS(a,b) // 转换宏
printf("int max: %s\n", STR(INT_MAX)); // INT_MAX,int型的最大值，为一个变量
#include<climits>
输出为: int max: 0x7fffffff
STR(INT_MAX) --> _STR(0x7fffffff) 然后再转换成字符串；
printf("%d\n", CONS(A, A));
输出为：200
CONS(A, A) --> _CONS((2), (2)) --> int((2)e(2))

---

1. 找错
   试题1：
   void test1(void)
   {
       char string[10];
       char *str1 = "0123456789";
       strcpy(string, str1);
   }
   test1: 字符串str1需要11个字节才能存放下(包括末尾的'\0')，而string只有10个字节的空间，strcpy会导致数组越界
   权重：高
   备注：常用

---

试题2：
void test2(void)
{
    char string[10], str1[10];
    for(i = 0; i < 10; i++)
    {
        str1[i] = 'a';
    }
    strcpy(string, str1);
}
test2: 如果面试者指出字符数组str1不能在数组内以‘\0’结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分
权重：高
备注：要时刻注意字符串应该以‘\0’也就是0x0来结尾

---

试题3：
void test3(char *str1)
{
    char string[10];
    if(strlen(str1) <= 10)
    {
        strcpy(string, str1);
    }
}
解答：
test3: if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计'\0'所占用的1个字节
剖析：
考查对基本功的掌握：
(1)字符串以'\0'结尾；
(2)对数组越界把握的敏感度；
(3)库函数strcpy的工作方式

---

找错
试题4：
void GetMemory( char *p )
{
    p = (char *) malloc( 100 );
}
void Test( void ) 
{
    char *str = NULL;
    GetMemory( str );
    strcpy( str, "hello world" );
    printf( str );
}
解答：
试题4传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完char *str = NULL;  GetMemory( str ); 后的str仍然为NULL；
权重：高
备注：形参不会改变实参

---

试题5：
char *GetMemory( void )
{ 
    char p[] = "hello world"; 
    return p; 
}

void Test( void )
{ 
    char *str = NULL; 
    str = GetMemory();
    printf( str ); 
}
试题5中 char p[] = "hello world";  return p; 的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
权重：高

---

试题6：
void GetMemory( char **p, int num )
{
    *p = (char *) malloc( num );
}

void Test( void )
{
    char *str = NULL;
    GetMemory( &str, 100 );
    strcpy( str, "hello" );
    printf( str ); 
}
试题6的GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num );后未判断内存是否申请成功，应加上：
if ( *p == NULL )
{
　...//进行申请内存失败处理
}
权重：高
备注：会用malloc和free

---

试题7：
void Test( void )
{
    char *str = (char *) malloc( 100 );
    strcpy( str, "hello" );
    free( str );
      //省略的其它语句
}
试题7存在与试题6同样的问题，在执行char *str = (char *) malloc(100); 后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：str = NULL; 试题6的Test函数中也未对malloc的内存进行释放。
剖析：
试题4～7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60的错误。但是要完全解答正确，却也绝非易事。
对内存操作的考查主要集中在：
(1) 指针的理解；
(2) 变量的生存期及作用范围；
(3) 良好的动态内存申请和释放习惯。
权重：高

---

再看看下面的一段程序有什么错误：
swap( int* p1, int* p2 )
{
    int *p;
　   *p = *p1;
　   *p1 = *p2;
　   *p2 = *p;
}
答：p未指向实际的存储空间，应该这样写：
swap( int* p1, int* p2 )
{
　   int p;
　   p = *p1;
　   *p1 = *p2;
　   *p2 = p;
}
权重：较高

---

15.
unsigned char *p1;
unsigned long *p2;
p1=(unsigned char *)0x801000;
p2=(unsigned long *)0x810000;
请问
p1+5=______;
p2+5=______;
答案：801005；810014。不要忘记了这个是16进制的数字，p2要加20变为16进制就是14
权重：高
备注：理解指针加法的步进

---

16、设有以下说明和定义：
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(too)+sizeof(max));的执行结果是：______
答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.
所以结果是 20 + 32 = 52.
当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20
权重：高
备注：理解结构体占用存储空间的逻辑

---

华为笔试题 
1.写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a的值(3分)
int a = 4;
(A)a += (a++); (B) a += (++a) ;(C) (a++) += a;(D) (++a) += (a++);
a = ?
答：C错误，左侧不是一个有效变量，不能赋值，可改为(++a) += a;
改后答案依次为9,10,10,11
权重：较低

---

2.某32位系统下, C++程序，请计算sizeof 的值(5分).
char str[] = “http://www.ibegroup.com/”
char *p = str ;
int n = 10;
请计算
sizeof (str ) = ？（1）
sizeof ( p ) = ？（2）
sizeof ( n ) = ？（3）
void Foo ( char str[100]){
    // 请计算
    sizeof( str ) = ？（4）// 形参是指针，是4个字节
}
void *p = malloc( 100 ); // p是指针
请计算
sizeof ( p ) = ？（5）
答：（1）25 （2）4 （3） 4 （4）4 （5）4
权重：高
备注：理解sizeof的规则

---

4. 回答下面的问题(6分)
   (1).
   void GetMemory(char **p, int num){
    *p = (char *)malloc(num);
   }
   void Test(void){
    char *str = NULL;
    GetMemory(&str, 100);
    strcpy(str, "hello");
    printf(str);
   }
   请问运行Test 函数会有什么样的结果？
   答：输出“hello”
   权重：中

---

(2). void Test(void){
    char *str = (char *) malloc(100);
    strcpy(str, “hello”);
    free(str);
    if(str != NULL){
        strcpy(str, “world”);
        printf(str);
    }
}
请问运行Test 函数会有什么样的结果？
答：输出“world”
权重：较低
备注：被释放的指针所拥有空间原理上是可以被使用的，只是如果修改了，而这块内存被已有的程序使用，可能程序跑飞。

---

(3). char *GetMemory(void){
    char p[] = "hello world";
    return p;
}
void Test(void){
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
请问运行Test 函数会有什么样的结果？
答：无效的指针，输出不确定
权重：高

---

20 int i=10, j=10, k=3; k*=i+j; k最后的值是？
答：60，此题考察优先级，实际写成： k *= (i + j);，赋值运算符优先级最低
权重：低
备注：实际编程中公司会要求多级运算必须加括号。

---

6、请写出下列代码的输出内容
#include<stdio.h>
void main(void)
{
    int a, b, c, d;
    a = 10;
    b = a++;
    c = ++a;
    d = 10 * a++;
    printf("b，c，d：%d，%d，%d"，b，c，d）;
    return 0;
} 
答：10，12，120
权重：高
备注：++a先加再使用，a++先使用再加

---

5、写出下列代码的输出内容
#include<stdio.h>
int inc(int a)
{
    return(++a);
}
int multi(int*a, int*b, int*c)
{
    return(*c = *a * *b);
}
typedef int(FUNC1)(int in);
typedef int(FUNC2) (int*, int*, int*);

void show(FUNC2 fun, int arg1, int *arg2)
{
    INC p = &inc;
    int temp = p(arg1);
    fun(&temp, &arg1, arg2);
    printf("%d\n", *arg2);
}
void main(void)
{
    int a;
    show(multi, 10, &a);
    return 0;
}
答：110
权重：中

---

7、请找出下面代码中的所有错误
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”
1、#include"string.h"	//1
2、main()	//2
3、{
4、 char*src="hello,world";
5、 char* dest=NULL;
6、 int len=strlen(src);
7、 dest=(char*)malloc(len);	//3，4
8、 char* d=dest;
9、 char* s=src[len];	
10、 while(len--!=0) 
11、 d++=s--;
12、 printf("%s",dest);
13、 return 0;
14、} 
答：
方法1：
int main(void)
{
    char *src = "hello,world";
    int len = strlen(src);
    char *dest = (char *)malloc(len + 1);    //要为\0分配一个空间
    char *d = dest;
    char *s = &src[len - 1];                //指向最后一个字符

    while(len-- != 0)
       *d++ = *s--;
    *d = 0;                                 //尾部要加\0
    printf("%s\n", dest);
    free(dest);                             // 使用完，应当释放空间，以免造成内存汇泄露
    
    return 0;

}
方法2：
#include <stdio.h>
#include <string.h>
void main(void)
{
    char str[] = "hello,world";
    int len = strlen(str);
    char t;

    for (int i = 0; i < len / 2; i++)
    {
        t = str[i];
        str[i] = str[len - i - 1]; str[len - i - 1] = t;
    }
    printf("%s", str);
    
    return 0;

}
权重：高
备注：找错题能看出有没有实际工作经验，知道哪些坑

---

1.请问以下代码有什么问题：
int main()
{
    char a;
    char *str=&a;
    strcpy(str,"hello");
    printf(str);
    return 0;
}
答：
没有为str分配内存空间，将会发生异常
问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。
权重：高

---

char *s = "AAA";
printf("%s", s);
s[0] = 'B';
printf("%s", s);
有什么错？
答：
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。
cosnt char* s="AAA";
然后又因为是常量，所以对是s[0]的赋值操作是不合法的。
权重：高

---

1.有以下表达式：
int a=248; b=4;int const c=21;const int *d=&a;
int *const e=&b;int const *f const =&a;
请问下列表达式哪些会被编译器禁止？为什么？
答：
*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;
*c const，禁止
*d const整数， 禁止
e = &a const指针 禁止
const *f const =&a; 禁止
权重：较高
备注：int *const是指针只读，存的整数可改，const int *是指针可改，存的整数只读

---

1：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针
答：(void *)ptr 和 (*(void**))ptr值是相同的
权重：较低

---

2：int main()
{
    int x = 3;
    printf("%d", x);

    return 1;

}
问函数既然不会被其它函数调用，为什么要返回1？
mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息
权重：低

---

2. 输出多少？并分析过程
   unsigned short A = 10;
   printf("~A = %u\n", ~A);

char c=128; 
printf("c=%d\n",c);
第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285
第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。
这两道题都是在考察二进制向int或uint转换时的最高位处理。
权重：低
备注：反码补码实际用到的时候再去查也可以

---

4.char a[10],strlen(a)为什么等于15？运行的结果
#include "stdio.h"
#include "string.h"
void main()
{
    char aa[10];

    printf("%d",strlen(aa));

}
答：
sizeof()和初始化没有关系，值为10；
strlen()和初始化有关，以‘\0’判断字符串结尾，结果为15只能说在不确定数据的内存中刚好第15个字节是0x0，也有可能没得出结果程序就崩溃了。
权重：中

---

1)给定结构struct A 
{
       char t:4;
       char k:4;
       unsigned short i:8;
       unsigned long m;
};问sizeof(A) = ?
答
给定结构struct A 
{
       char t:4; 4位
       char k:4; 4位
       unsigned short i:8; 8位      
       unsigned long m; // 偏移2字节保证4字节对齐
}; // 共8字节
权重：高

---

2)下面的函数实现在一个数上加一个数，有什么错误？请改正。
int add_n ( int n )
{
    static int i = 100;
    i += n;
    return i;
}
答：第二次调用时得不到正确的结果，问题出在 static上
权重：较低

---

3.int a,b,c 请写函数实现c=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题
答：
bool add (int a, int b,int *c)
{
    *c = a + b;
    return (a>0 && b>0 &&(*c<a || *c<b) || (a<0 && b<0 &&(*c>a || *c>b)));
}
权重：较低

---

4.分析输出是什么：
struct bit 
{
    int a:3; 
    int b:2; 
    int c:3; 
}; 
int main() 
{ 
    bit s; 
    char *c = (char *)&s; 
    cout << sizeof(bit) << endl;
    *c = 0x99;
    cout << s.a <<endl <<s.b<<endl<<s.c<<endl; 
    int a = -1;
    printf("%x",a);
   return 0; 
} 
输出为什么是
4
1
-1
-4
ffffffff
因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100
当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理 
b = -1;
当c为有符合数时, c = 100,即 c = 4,同理 b = 3
权重：中

位域 ：   
有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     
struct 位域结构名     
{ 位域列表 };    
其中位域列表的形式为： 类型说明符 位域名：位域长度     
例如：     
struct bs    
{    
    int a:8;    
    int b:2;    
    int c:6;    
};    
位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：     
struct bs    
{    
    int a:8;    
    int b:2;    
    int c:6;    
} data;    
说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：    

1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     
   struct bs    
   {    
    unsigned a:4    
    unsigned :0 /*空域*/    
    unsigned b:4 /*从下一单元开始存放*/    
    unsigned c:4    
   }    
   在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。    
2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。    
3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     
   struct k    
   {    
    int a:1    
    int :2 /*该2位不能使用*/    
    int b:3    
    int c:2    
   };    
   从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。    
   二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名:位域名 位域允许用各种格式输出。    
   main(){    
   struct bs    
   {    
    unsigned a:1;    
    unsigned b:3;    
    unsigned c:4;    
   } bit, *pbit;    
   bit.a=1;    
   bit.b=7;    
   bit.c=15;    

---

4.下面这个程序执行后会有什么错误或者效果:
#define MAX 255
int main()
{
   unsigned char A[MAX], i; //i被定义为unsigned char
   for (i = 0; i <= MAX; i++)
      A[i] = i;
}
解答：死循环加数组越界访问（C/C++不进行数组越界检查）
MAX=255 
数组A的下标范围为:0..MAX-1,这是其一..
其二.当i循环到255时,循环内执行:
  A[255]=255;
这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时,
由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
权重：高
备注：实际工作中也要注意要int i;

---

2.#define Max_CB 500
void LmiQueryCSmd(Struct MSgCB * pmsg)
{
    unsigned char ucCmdNum;
    ......
    for(ucCmdNum = 0; ucCmdNum < MAX_CB; UCCMDNUM++)
    {
        ......;
    }
}
答: 死循环,unsigned char的取值范围是0~255
权重：高

---

5.求结构体占内存大小
struct name1 {
   char  str;
   short x;
   int   num;
}
struct name2{
   char str;
   int num;
   short x;
}
sizeof(struct name1)=8,sizeof(struct name2)=12
在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。
权重：高
备注：理解结构体字节对齐

---

2. 写出程序输出结果
   void g(int**);
   int main()
   {
    int line[10], i;
    int *p = line; //p是地址的地址
    for (i = 0; i < 10; i++)
    {
        *p = i;
        g(&p); //数组对应的值加1
    }
    for (i = 0; i < 10; i++)
    printf("%d\n", line[i]);
    return 0;
   }

void g(int **p)
{
    (**p)++;
    (*p)++; // 无效
}
答：
输出：
1
2 
3 
4 
5 
6 
7 
8 
9 
10
权重：中

---

3. 写出程序运行结果
   int sum(int a)
   {
    auto int c = 0;
    static int b = 3;
    c += 1;
    b += 2;
    return(a + b + c);
   }

void main()
{
    int I;
    int a = 2;
    for(I = 0; I < 5; I++)
    {
        printf("%d,", sum(a));
    }
}
// static会保存上次结果
输出：8,10,12,14,16,
权重：较高

---

4.
int func(int a)
{
    int b;
    switch(a)
    {
        case 1: 30;
        case 2: 20;
        case 3: 16;
        default: 0
    }
    return b;
}
则func(1)=?
答：b定义后就没有赋值，返回不确定，如果将代码改为
    switch(a)
    {
        case 1: b = 30; // flow down
        case 2: b = 20; // flow down
        case 3: b = 16; // flow down
        default: b = 0
    }则最终返回0，因为没有break会顺延到最后一个。
权重：较高

---

5:
int a[3];
a[0] = 0; a[1] = 1; a[2] = 2;
int *p, *q;
p = a;
q = &a[2];
则a[q-p] = ?
答：a[2]
解释：指针一次移动一个int但计数为1
权重：高

---

1.前几天面试，有一题想不明白,请教大家！
  typedef struct 
  { 
     int a:2;
     int b:2;
     int c:1;
  } test;

  test t;
  t.a = 1;
  t.b = 3;
  t.c = 1;

  printf("%d",t.a);
  printf("%d",t.b);
  printf("%d",t.c);
答：
t.a为01,输出就是1
t.b为11，输出就是-1
t.c为1，输出也是-1
3个都是有符号数int嘛。
这是位扩展问题 
01
11
1
编译器进行符号扩展
权重：较高

---

1.分析,输出是什么？：
int arr[] = {6, 7, 8, 9, 10};
int *ptr = arr;
*(ptr++) += 123;
printf(“ %d %d ”, *ptr, *(++ptr));
输出：8 8
过程：对于*(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于printf(“ %d %d ”, *ptr, *(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8
权重：中

---

```c

```





4. C++:memset ,memcpy 和strcpy 的根本区别？ 
   答:#include "memory.h"
   memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为' '或''；例:char a[100];memset(a, '', sizeof(a)); 
   memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));注意如用sizeof(a)，会造成b的内存地址溢出。 
   strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝；例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，要注意a中的字符串长度（第一个'\0'之前）是否超过50位，如超过，则会造成b的内存地址溢出。
   权重：高
   备注：这都是常用的库函数

strcpy 
原型：extern char *strcpy(char *dest, char *src); 
{
    ASSERT((dest != NULL) && (src != NULL));
    char *address = dest;
    while((*dest++ = *src++) != ’\0’)
    continue;
    return dest;
}
功能：把src所指由NULL结束的字符串复制到dest所指的数组中。
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
返回指向dest的指针。
memcpy 
原型：extern void *memcpy(void *dest, void *src, unsigned int count);
{
    ASSERT((dest != NULL) && (src != NULL));
    ASSERT((dest > src+count) || (src > dest + count)); //防止内存重叠,也可以用restrict修饰指针
    Byte* bdest = (Byte*)dest;
    Byte* bsrc = (Byte*) src;
    while(count-- > 0)
        *bdest++ = **bsrc++;
    return dest;
}
功能：由src所指内存区域复制count个字节到dest所指内存区域。
说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针。
memset
原型：extern void *memset(void *buffer, char c, int count);
功能：把buffer所指内存区域的前count个字节设置成字符c。
说明：返回指向buffer的指针。










