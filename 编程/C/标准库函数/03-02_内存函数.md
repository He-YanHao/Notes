# 内存管理函数

## 申请内存函数 calloc() 和 malloc()

```c
void *calloc(int num, int size);
```

调用此函数会在内存中动态地分配 num 个长度为 size 的连续空间，单位为字节，并将每一个字节都初始化为 0。

该函数虽然是 ` void * ` 类型，但存在返回值，会返回一个指向分配内存的指针。这是因为 ` void * ` 类型表示未确定类型的指针。

> C、C++ 规定 ` void * ` 类型可以通过类型转换强制转换为任何其它类型的指针。

```c
void *malloc(int num);
```

在堆区分配一块指定大小的内存空间，单位为字节，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。

该函数也会返回一个指向分配内存的指针。



## 释放内存函数 free()

```c
void free(void *address);
```

该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。

**问：free() 怎么知道有多少字节需要释放？**

答：calloc()/malloc()/free() 的实现会在分配的时候记下每一块的大小, 所以在释放的时候就 不必再考虑了。

**问：我有个程序分配了大量的内存, 然后又释放了。但是从操作系统看, 内存的占用率却并没有回去。** 

答：多数 malloc/free 的实现并不把释放的内存返回操作系统, 而是留着供同一程 序的后续 malloc() 使用。



## 改变内存函数 realloc()

```c
void *realloc(void *address, int newsize);
```

该函数重新分配内存，把内存扩展到 **newsize**。



## 复制内存函数

- memcpy( ) 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。
- memmove( ) 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。











