# Python 四大数据结构对比：列表 vs 元组 vs 字典 vs 集合

以下是 Python 核心数据结构的详细对比，通过表格和示例展示它们的异同点：

## 📊 核心特性对比表

| 特性         | 列表(list)     | 元组(tuple)    | 字典(dict)                 | 集合(set)     |
| ------------ | -------------- | -------------- | -------------------------- | ------------- |
| **可变性**   | ✅ 可变         | ❌ 不可变       | ✅ 可变                     | ✅ 可变        |
| **有序性**   | ✅ 保持插入顺序 | ✅ 保持插入顺序 | ❌ 无序(Python 3.7+有序)    | ❌ 无序        |
| **元素要求** | 允许重复元素   | 允许重复元素   | 键必须唯一                 | 元素必须唯一  |
| **索引方式** | 数字索引 [0]   | 数字索引 [0]   | 键索引 ['key']             | ❌ 不支持索引  |
| **语法表示** | [1, 2, 3]      | (1, 2, 3)      | {'a':1, 'b':2}             | {1, 2, 3}     |
| **空对象**   | []             | ()             | {}                         | set()         |
| **元素类型** | 任意类型       | 任意类型       | 键：不可变类型<br>值：任意 | 不可变类型    |
| **内存占用** | 较高           | 较低           | 较高                       | 中等          |
| **查找效率** | O(n)           | O(n)           | O(1)                       | O(1)          |
| **主要用途** | 有序数据集合   | 固定数据记录   | 键值对映射                 | 去重/集合运算 |

## 🔍 详细解析

### 1. 可变性 (Mutability)
- **列表**：可动态修改（增删改元素）
  ```python
  fruits = ["苹果", "香蕉"]
  fruits.append("橙子")  # 添加元素
  fruits[0] = "芒果"     # 修改元素
  ```
  
- **元组**：创建后不可修改（安全的数据容器）
  ```python
  colors = ("红", "绿", "蓝")
  # colors[0] = "黄"  # 报错: TypeError
  ```
  
- **字典**：可修改键值对
  ```python
  user = {"name": "小明", "age": 20}
  user["age"] = 21      # 修改值
  user["city"] = "北京"  # 添加新键值对
  ```
  
- **集合**：可添加/删除元素，但元素本身不可变
  ```python
  primes = {2, 3, 5}
  primes.add(7)    # 添加元素
  primes.discard(3) # 删除元素
  ```

### 2. 元素唯一性
- **列表/元组**：允许重复元素
  ```python
  scores = [85, 90, 85]  # 有效
  ```
  
- **字典**：键必须唯一，值可重复
  ```python
  grades = {"数学": 90, "语文": 85, "数学": 95}  # 最后一个"数学"覆盖前一个
  ```
  
- **集合**：自动去重
  ```python
  unique_nums = {1, 2, 2, 3}  # 实际存储 {1, 2, 3}
  ```

### 3. 访问方式
- **列表/元组**：通过数字索引
  ```python
  fruits = ["苹果", "香蕉", "橙子"]
  print(fruits[1])  # 输出: 香蕉
  ```
  
- **字典**：通过键访问
  ```python
  capitals = {"中国": "北京", "日本": "东京"}
  print(capitals["中国"])  # 输出: 北京
  ```
  
- **集合**：不支持索引，只能遍历或检查成员
  ```python
  vowels = {'a', 'e', 'i'}
  'e' in vowels  # True
  # print(vowels[0])  # 报错: TypeError
  ```

### 4. 使用场景
- **列表**：需要保持顺序且可能修改的数据集合
  ```python
  # 购物车商品
  shopping_cart = ["牛奶", "面包", "鸡蛋"]
  shopping_cart.remove("面包")
  ```

- **元组**：不应更改的数据记录（如坐标、数据库记录）
  ```python
  # 地理坐标
  location = (39.9042, 116.4074)
  ```
  
- **字典**：键值对映射关系（如配置信息、对象属性）
  ```python
  # 学生信息
  student = {
      "id": "S001",
      "name": "张三",
      "courses": ["数学", "英语"]
  }
  ```
  
- **集合**：去重和集合运算
  ```python
  # 找出共同好友
  friends1 = {"小明", "小红", "小刚"}
  friends2 = {"小红", "小刚", "小芳"}
  common = friends1 & friends2  # {"小红", "小刚"}
  ```

### 5. 类型转换
数据结构间可相互转换：
```python
# 列表 → 集合（去重）
names = ["Alice", "Bob", "Alice"]
unique_names = set(names)  # {"Alice", "Bob"}

# 元组 → 字典（需特定格式）
pairs = [("a", 1), ("b", 2)]
dict(pairs)  # {'a': 1, 'b': 2}

# 字典 → 列表（获取键列表）
keys = list({"x":10, "y":20})  # ["x", "y"]
```

## 💡 选择指南
1. **需要有序集合且可能修改** → 列表
2. **需要不可变数据记录** → 元组
3. **需要键值对映射** → 字典
4. **需要去重或集合运算** → 集合

> **性能提示**：
> - 频繁成员检查：用集合 (O(1)) 替代列表 (O(n))
> - 只读操作：用元组替代列表节省内存
> - 键值查询：字典是最高效选择

理解这些数据结构的特性，能帮助你在Python编程中选择最合适的工具，提升代码效率和可读性。