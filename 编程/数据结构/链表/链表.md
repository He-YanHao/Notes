# 链表

## 链表基础介绍

链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。

链表线型数据串。

链表有一个头指针变量，它存放一个地址，该地址指向一个元素。

链表中每一个元素称为结点，每个结点都应包括两个部分，一为用户需要用的实际数据，二为下一个结点的地址。

最后一个元素，该元素不再指向其他元素，它称为 表尾，它的地址部分放一个 NULL（表示空地址）链表到此结束。

例如可以设计这样一个结构体类型：

```c
struct student
{
    int num;
    float score;
    struct student *next;
};
```

其中成员 num 和 score 用来存放结点中的有用数据（用户需要用到的数据），next 是指针类型成员，它指向 struct student 类型数据（这是 next 所在结构体类型）。

### 处理动态链表所需的函数

#### malloc()

```
void *malloc(unsigned int size);
```

作用是在内存的动态存储区中分配一个长度为 size 的连接空间。

此函数的返回值是一个指向分配空间起始地址的指针（基类型为 void）。

如果些函数未能成功地执行（例如内存空间不足）则返回空指针 NULL。

#### calloc()

```
void *calloc(unsigned n, unsigned size);
```

其作用是在内存的动态区存储中分配 n 个长度为 size 的连续空间。

函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。 

用 calloc 函数可以为一维数组开辟动态存储空间， n 为数组元素个数，每个元素长度为 size。

#### free()

```
void free(void *p);
```

其作用是释放由 p 指向的内存区，使这部分内存区能被其它变量使用， p 是最后一次调用 calloc 或 malloc 函数时返回的值。

free 函数无返回值。 

请注意：以前的C版本提供的 malloc 和 calloc 函数得到的是指向字符型数据的指针。ANSI C 提供的 malloc 和 calloc 函数规定为 void * 类型。

## 495

不可以这样申请链表。

```c
struct NODEPTR{
    char*item;
    NODEPTR next;
};
```

因为`NODEPTR`类型还未完成定义前不能使用。

可以(需要)这样申请。

```c
typedef struct node {
    char *item;
    struct node *next;
}node;
```

## 建立动态链表

所谓建立动态链表是指在程序执行过程中从无到有地建立起一个键表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。

流程包括：

- 新增节点
- 添加节点到链表末尾
- 删除节点
- 更改节点
- 删除链表



## 删除节点

```c

```



- 
- 

```c
//传入链表头地址的地址和要删的数据
//判断链表头地址是否为空
	//如果为空 直接退出
//判断链表第一个节点数据是否符合
	//如果符合将第二个节点指针赋予链表头
	//释放链表第一个节点
//判断链表后续节点数据是否符合
	//如果符合 
//
//
//
//
//
//
//

```



































