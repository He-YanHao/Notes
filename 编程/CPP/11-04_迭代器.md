# 迭代器 Iterators

好的，我们来深入探讨 C++ STL 的核心组件之一：**迭代器 (Iterators)**。它是 STL 实现“泛型编程”和“数据与操作分离”两大设计理念的关键粘合剂。

**迭代器是什么？**

你可以将迭代器想象成一个**智能指针**，它提供了一种**统一的方法来遍历和访问容器（如 `vector`, `list`, `map`）中的元素**，而**无需关心容器的底层数据结构**（是数组、链表、树还是哈希表）。

*   **类比指针：** 迭代器的许多操作（如解引用 `*it`、成员访问 `it->`、自增 `++it`、自减 `--it`）与操作原生指针访问数组元素非常相似。
*   **超越指针：** 迭代器比原生指针更抽象、更强大。它不仅适用于数组，还适用于所有 STL 容器（以及可以自定义支持迭代器的数据结构）。它还能表示“结束”位置（`container.end()`），这是原生指针不易直接表达的。

**迭代器的核心作用：**

1.  **连接容器与算法：** 这是迭代器最重要的作用！STL 算法（如 `sort`, `find`, `copy`）**不直接操作容器**，而是通过**迭代器**来指定要操作的**元素范围**（通常是一个半开区间 `[begin, end)`）。算法只要求迭代器提供特定的功能（如读取、写入、向前移动、随机访问等），而不关心迭代器背后是哪种容器。这实现了算法与数据结构的**解耦**。
2.  **统一的元素访问：** 无论容器内部如何组织元素（连续内存、链表节点、树节点），你都可以使用相同的迭代器语法（`*it`, `it->`, `++it`）来访问和操作元素。
3.  **遍历容器：** 迭代器是遍历容器元素的标准方式。通常使用循环：
    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};
    // 使用迭代器遍历
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    // 现代C++更常用基于范围的for循环 (底层也使用迭代器)
    for (int num : vec) {
        std::cout << num << " ";
    }
    ```

**迭代器的分类（Categories）**

迭代器不是单一类型，而是根据它们**支持的操作和能力**分为不同的类别。类别形成一个层次结构，能力更强的迭代器可以替代能力较弱的迭代器。理解这些类别对于正确使用算法至关重要，因为**算法会声明它们需要哪种最低类别的迭代器**。

以下是按功能**从弱到强**的迭代器分类：

1.  **输入迭代器 (InputIterator):**
    *   **功能：** 只读访问序列中的元素，**只能向前移动** (`++it`)。元素只能被读取一次（序列可能是单次遍历的，如从网络流或标准输入读取）。
    *   **支持操作：** `==`, `!=`, `++` (前缀和后缀), `*` (只能出现在赋值右侧), `->`。
    *   **典型应用：** 从 `std::cin` 读取数据的 `std::istream_iterator`。
    *   **算法示例：** `std::find`, `std::count`, `std::accumulate` (只读版本)。

2.  **输出迭代器 (OutputIterator):**
    *   **功能：** 只写访问序列中的元素，**只能向前移动** (`++it`)。元素只能被写入一次。
    *   **支持操作：** `++` (前缀和后缀), `*` (只能出现在赋值左侧)。
    *   **典型应用：** 向 `std::cout` 写入数据的 `std::ostream_iterator`；在容器尾部插入元素的 `std::back_inserter`；在容器前部插入元素的 `std::front_inserter`；在容器指定位置插入元素的 `std::inserter`。
    *   **算法示例：** `std::copy`, `std::transform` (输出结果时)。

3.  **前向迭代器 (ForwardIterator):**
    *   **功能：** **继承自输入迭代器**。支持读写（如果是非 const 迭代器）。**可以多次遍历序列**（元素可以被多次读写）。**只能向前移动** (`++it`)。
    *   **支持操作：** 输入迭代器的所有操作，并且支持多次遍历和读写（如果允许）。
    *   **典型容器：** `std::forward_list`（单向链表）的迭代器。
    *   **算法示例：** `std::adjacent_find`, `std::search`。

4.  **双向迭代器 (BidirectionalIterator):**
    *   **功能：** **继承自前向迭代器**。增加了**向后移动** (`--it`) 的能力。
    *   **支持操作：** 前向迭代器的所有操作 + `--` (前缀和后缀)。
    *   **典型容器：** `std::list`（双向链表）, `std::set`, `std::map`, `std::multiset`, `std::multimap` 的迭代器。
    *   **算法示例：** `std::reverse`（需要双向移动）, `std::reverse_copy`。

5.  **随机访问迭代器 (RandomAccessIterator):**
    *   **功能：** **继承自双向迭代器**。提供了**完整的“指针算术”功能**。可以直接跳转到序列中的任意位置，计算元素之间的距离，使用下标操作符。
    *   **支持操作：** 双向迭代器的所有操作 +
        *   `+ n`, `- n` (迭代器向前/后移动 n 个位置)
        *   `it += n`, `it -= n`
        *   `it1 - it2` (计算两个迭代器之间的距离)
        *   `<`, `>`, `<=`, `>=` (比较迭代器位置)
        *   `[]` (下标访问，等价于 `*(it + n)`)
    *   **典型容器：** `std::vector`, `std::deque`, `std::array`, 原生数组的指针。
    *   **算法示例：** `std::sort`, `std::binary_search`, `std::nth_element`（这些算法需要高效地跳转到任意位置）。

**迭代器的获取**

每个 STL 容器都提供了成员函数来获取迭代器：

*   **`begin()`:** 返回指向容器**第一个元素**的迭代器。
*   **`end()`:** 返回指向容器**最后一个元素之后位置**的迭代器（称为“尾后”迭代器）。**`end()` 指向的不是有效元素！** 它仅作为范围结束的标记。
*   **`cbegin()`, `cend()` (C++11):** 返回指向常量元素的迭代器 (`const_iterator`)，用于只读访问。
*   **`rbegin()`, `rend()`:** 返回**反向迭代器** (类型为 `reverse_iterator`)，用于从后向前遍历。
    *   `*rbegin()` 得到最后一个元素。
    *   `*rend()` 无效，`rend()` 指向第一个元素之前的位置。
*   **`crbegin()`, `crend()` (C++11):** 返回指向常量元素的反向迭代器 (`const_reverse_iterator`)。

**迭代器失效 (Iterator Invalidation)**

这是一个**极其重要且容易出错**的概念！

*   **定义：** 当容器发生某些修改操作（如插入、删除元素）时，**指向容器元素的迭代器可能会变得无效**。这意味着继续使用这些迭代器（解引用、移动等）会导致**未定义行为 (Undefined Behavior, UB)**，通常表现为程序崩溃或错误结果。
*   **原因：** 修改操作可能改变容器的内部结构：
    *   **`vector`, `string`, `deque`:** 插入/删除元素可能导致元素内存**重新分配**或**移动**，使所有指向元素的迭代器（包括指针、引用）**失效**。在 `vector` 中间插入/删除元素会使插入点/删除点**之后**的所有迭代器失效。
    *   **`list`, `forward_list`, `set`, `map`, ... (基于节点的容器):** 插入操作**通常不会**使其他迭代器失效（新节点是独立分配的）。删除操作**只会**使指向被删除元素的迭代器失效，其他迭代器仍然有效。
*   **如何避免：**
    1.  在修改容器后，**谨慎使用**之前保存的迭代器。最好假设它们可能失效。
    2.  仔细查阅容器操作的文档，了解哪些操作会导致哪些迭代器失效。
    3.  使用修改操作（如 `insert`, `erase`）的**返回值**（它们通常会返回一个新的、有效的迭代器，指向特定位置）。
    4.  使用**算法惯用法**（如 `erase-remove`）来安全删除元素。
        ```cpp
        std::vector<int> vec = {1, 2, 3, 2, 4, 2, 5};
        // 安全删除所有值为2的元素 (erase-remove惯用法)
        vec.erase(std::remove(vec.begin(), vec.end(), 2), vec.end());
        ```

**迭代器适配器 (Iterator Adapters)**

这些是特殊的迭代器，它们“包装”或“修改”另一个迭代器的行为，提供不同的接口或功能：

1.  **反向迭代器 (`reverse_iterator`):**
    *   通过 `rbegin()`, `rend()` 获得。
    *   将自增 `++` 操作解释为向后移动（朝向容器开头），自减 `--` 解释为向前移动（朝向容器结尾）。
    *   `*rbegin()` 得到 `*(end() - 1)`（最后一个有效元素）。
2.  **插入迭代器 (Insert Iterators):**
    *   将赋值操作 (`*it = value;`) 转换为容器的**插入操作**。
    *   **`back_inserter(container)`:** 创建 `std::back_insert_iterator`，调用 `container.push_back(value)`。
    *   **`front_inserter(container)`:** 创建 `std::front_insert_iterator`，调用 `container.push_front(value)` (要求容器支持 `push_front`)。
    *   **`inserter(container, pos)`:** 创建 `std::insert_iterator`，调用 `container.insert(pos, value)`，在指定位置 `pos` 之前插入。
    *   非常有用，允许像 `copy` 这样的算法直接“输出”到容器尾部/前部/指定位置：
        ```cpp
        std::list<int> source = {1, 2, 3};
        std::vector<int> dest;
        std::copy(source.begin(), source.end(), std::back_inserter(dest));
        // dest 现在为 {1, 2, 3}
        ```
3.  **流迭代器 (`istream_iterator`, `ostream_iterator`):**
    *   允许将输入/输出流当作序列来处理。
    *   `std::istream_iterator<T>`: 从输入流（如 `cin`）读取类型 `T` 的值。
    *   `std::ostream_iterator<T>`: 向输出流（如 `cout`）写入类型 `T` 的值，可指定分隔符。
        ```cpp
        // 从 cin 读取整数直到失败(如 EOF 或非数字)，复制到 vec
        std::vector<int> vec;
        std::copy(std::istream_iterator<int>(std::cin),
                 std::istream_iterator<int>(), // 默认构造表示"流结束"
                 std::back_inserter(vec));

        // 将 vec 的内容写入 cout, 每个元素后加空格
        std::copy(vec.begin(), vec.end(),
                 std::ostream_iterator<int>(std::cout, " "));
        ```

**迭代器特征 (Iterator Traits) - 高级主题**

*   位于 `<iterator>` 头文件中 (`std::iterator_traits<Iter>`).
*   它是一个模板类，用于**提取迭代器 `Iter` 的相关类型信息**，即使 `Iter` 是原生指针也能工作。
*   提取的类型包括：
    *   `difference_type`: 表示两个迭代器距离的类型（通常是 `ptrdiff_t`）。
    *   `value_type`: 迭代器指向的元素的类型。
    *   `pointer`: 指向元素的指针类型。
    *   `reference`: 元素的引用类型。
    *   `iterator_category`: 迭代器所属的类别（如 `std::random_access_iterator_tag`）。
*   **作用：** 算法和函数模板可以利用 `iterator_traits` 来编写通用的代码，这些代码能够根据迭代器的类型（特别是 `iterator_category` 和 `difference_type`）进行优化或选择不同的实现策略。

**总结：STL 迭代器的重要性**

1.  **泛型编程的基石：** 使算法独立于容器，极大地提高了代码复用性。
2.  **统一的访问接口：** 提供一致的方法遍历和操作不同数据结构的元素。
3.  **范围抽象：** 通过 `[begin, end)` 半开区间清晰地定义操作范围。
4.  **类型安全：** 比 C 风格指针更安全（模板编译时检查）。
5.  **强大的功能扩展：** 通过迭代器适配器支持反向遍历、流操作、插入语义等。

**掌握迭代器的关键点：**

*   理解不同**迭代器类别**及其支持的操作。
*   熟练使用 `begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()` 获取迭代器。
*   深刻理解并时刻警惕**迭代器失效**问题。
*   学会使用**插入迭代器** (`back_inserter`, `inserter`) 简化向容器添加元素的操作。
*   掌握**基于范围的 for 循环**（底层依赖迭代器）进行简洁遍历。
*   （高级）了解 `iterator_traits` 的作用。

迭代器是高效、优雅地使用 STL 的必备知识。理解了迭代器，你就掌握了连接 STL 容器与算法的桥梁，能够编写出更通用、更健壮的 C++ 代码。