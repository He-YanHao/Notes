# 指针

## 基础概念相同
```c
// C 语言
int x = 10;
int *ptr = &x;
printf("%d", *ptr); // 输出 10

// C++
int y = 20;
int *ptr2 = &y;
std::cout << *ptr2; // 输出 20
```

| 操作     | C/C++ 语法 | 功能             |
| -------- | ---------- | ---------------- |
| 取地址   | `&var`     | 获取变量地址     |
| 解引用   | `*ptr`     | 访问指针指向的值 |
| 指针运算 | `ptr++`    | 移动指针位置     |
| 数组访问 | `ptr[i]`   | 通过指针访问数组 |

## C++ 的增强与扩展

### 类型安全增强
```cpp
// C 语言（危险但允许）
void* p = malloc(sizeof(int));
double* dptr = p; // 无警告

// C++（类型严格检查）
void* p = malloc(sizeof(int));
double* dptr = static_cast<double*>(p); // 需要显式转换
// double* dptr = p; // 错误: 无效转换
```

`static_cast` 主要用于：

- **相关类型之间的转换**（如基类与派生类指针、数值类型转换）。
- **显式类型转换**（比 C 风格强制转换更安全，但仍需谨慎使用）。

### 显式转换

**`static_cast` - 静态类型转换**

在相关类型之间进行相对安全的转换。

- 常用于类层次结构中的向上转换（派生类→基类）
- 不能转换掉 `const` 或 `volatile` 属性
- 

**`dynamic_cast` - 动态类型转换**

在类层次结构中进行安全的向下转换（基类→派生类）

- 运行时类型检查（RTTI）
- 需要基类有虚函数（多态类型）
- 失败时返回 `nullptr`（指针）或抛出异常（引用）

案例：

```cpp
class Base { virtual void dummy() {} };
class Derived : public Base {};

Base* bp = new Derived;

// 安全向下转换
Derived* dp = dynamic_cast<Derived*>(bp);
if(dp) {
    // 转换成功
}

Base* realBase = new Base;
Derived* badPtr = dynamic_cast<Derived*>(realBase);  // 返回 nullptr
```





**`const_cast` - 常量性转换**

可以添加或移除 `const` 和 `volatile` 属性。

案例：

```cpp
// 移除 const 属性
int* ip = const_cast<int*>(cip);
// 添加 const 属性
const int* cip2 = const_cast<const int*>(ip);
```



**`reinterpret_cast` - 重新解释转换**

低级别的位模式重新解释。

- 最危险的转换
- 不进行任何类型检查
- 常用于指针↔整数、函数指针转换等底层操作



### 面向对象特性
```cpp
class Base {
public:
    virtual void show() { std::cout << "Base\n"; }
};

class Derived : public Base {
public:
    void show() override { std::cout << "Derived\n"; }
};

// 多态指针
Base* bptr = new Derived();
bptr->show(); // 输出 "Derived" (多态行为)
delete bptr;
```



## 功能对比表

| 特性             | C 指针 | C++ 指针  | 说明                          |
| ---------------- | ------ | --------- | ----------------------------- |
| 原始指针         | ✓      | ✓         | 基础功能相同                  |
| `void*` 隐式转换 | ✓      | ✗         | C++ 需要显式转换              |
| 智能指针         | ✗      | ✓         | `unique_ptr`, `shared_ptr` 等 |
| 成员指针         | ✗      | ✓         | 指向类成员的指针              |
| 函数指针         | ✓      | ✓         | 但 C++ 有更优替代方案         |
| 引用支持         | ✗      | ✓         | 提供更安全的别名              |
| 运算符重载       | ✗      | ✓         | 可自定义指针行为              |
| 内存管理         | 手动   | 手动+自动 | C++ 有 RAII 和智能指针        |
| 异常安全         | ✗      | ✓         | 结合异常处理机制              |
| 类型检查         | 弱     | 强        | C++ 有更严格的类型系统        |

## 安全实践对比

### 空指针处理
```c
// C 语言（传统方式）
int *ptr = NULL;
if (ptr != NULL) {
    *ptr = 10;
}

// C++（现代方式）
int *ptr = nullptr; // 更安全的空指针字面量
if (ptr) { // 自动转换为 bool
    *ptr = 20;
}

// C++17 可选更安全方式
std::optional<int*> safePtr = nullptr;
if (safePtr.has_value()) {
    *safePtr.value() = 30;
}
```

### 内存管理最佳实践
```c
// C 语言（手动管理）
int *arr = malloc(10 * sizeof(int));
if (arr) {
    // 使用数组
    free(arr); // 必须手动释放
}

// C++（RAII 原则）
{
    std::vector<int> vec(10); // 自动管理内存
    // 使用 vector
} // 自动释放内存

// 或使用智能指针
auto arr = std::make_unique<int[]>(10);
```

## 高级应用场景

### 函数指针 vs 函数对象 (C++)
```cpp
// C 风格函数指针
int (*cmp)(int, int) = [](int a, int b) { return a - b; };

// C++ 函数对象（更强大）
struct Comparator
{
    bool operator()(int a, int b) const
    {
        return a < b;
    }
};

std::sort(vec.begin(), vec.end(), Comparator());
```

### 指针与多态
```cpp
class Shape {
public:
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
    void draw() const override { /* 绘制圆形 */ }
};

// 使用基类指针管理派生类
Shape* shape = new Circle();
shape->draw(); // 多态调用
delete shape;
```
