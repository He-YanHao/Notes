# 函数重载详解

函数重载（Function Overloading）是 C++ 的核心特性之一，它允许在同一作用域内定义多个同名函数，这些函数通过不同的参数列表（参数类型、数量或顺序）进行区分。这个特性显著提高了代码的可读性和灵活性。

### 核心概念

1. **定义**：在同一作用域内创建多个同名函数
2. **区分依据**：参数列表必须不同（以下至少一项）
   - 参数类型不同
   - 参数数量不同
   - 参数顺序不同
3. **不依赖**：
   - 返回类型不同（不能仅靠返回类型重载）
   - 函数体不同

### 函数重载规则

| 规则类型     | 允许情况                                                     | 禁止情况                                                    |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 参数类型     | `void f(int)` 和 `void f(double)`                            | `void f(int)` 和 `int f(int)`                               |
| 参数数量     | `void g()` 和 `void g(int)`                                  | -                                                           |
| 参数顺序     | `void h(int, double)` 和 `void h(double, int)`               | -                                                           |
| const 修饰符 | 用于引用或指针时有效：`void k(const int&)` 和 `void k(int&)` | 用于值参数时无效：`void m(int)` 和 `void m(const int)`      |
| 默认参数     | 允许使用                                                     | 可能导致歧义：`void n(int a)` 和 `void n(int a, int b = 0)` |

### 函数重载解析过程

当调用重载函数时，编译器执行三步决策：

1. **名称查找**：找到所有同名函数
2. **可行性检查**：筛选参数匹配的函数
3. **最佳匹配选择**：
   - 精确匹配（类型完全相同）
   - 提升转换（char→int, float→double）
   - 标准转换（int→double, double→int）
   - 用户定义转换（类转换运算符）
   - 省略号匹配（`...`）

### 实际应用示例

#### 基础类型重载
```cpp
// 参数类型不同
void print(int value) {
    cout << "整数: " << value << endl;
}

void print(double value) {
    cout << "浮点数: " << value << endl;
}

// 参数数量不同
void log() {
    cout << "基础日志" << endl;
}

void log(const string& message) {
    cout << "消息: " << message << endl;
}
```

#### 类成员函数重载
```cpp
class Calculator {
public:
    // 参数类型不同
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    
    // 参数数量不同
    int multiply(int a) { return a * a; }
    int multiply(int a, int b) { return a * b; }
};

// 使用
Calculator calc;
calc.add(3, 4);       // 调用 int 版本
calc.add(2.5, 3.7);   // 调用 double 版本
calc.multiply(5);      // 调用单参数版本
```

#### const 修饰符重载
```cpp
class TextBuffer {
    string content;
public:
    // const 版本和非 const 版本
    char& at(size_t pos) { 
        return content[pos]; 
    }
    
    const char& at(size_t pos) const { 
        return content[pos]; 
    }
};

// 使用
TextBuffer buffer;
buffer.at(0) = 'A';  // 调用非 const 版本

const TextBuffer cbuf;
char c = cbuf.at(0); // 调用 const 版本
```

#### 高级应用：STL 风格重载
```cpp
class Vector {
    double x, y;
public:
    // 多种初始化方式
    Vector() : x(0), y(0) {}
    Vector(double val) : x(val), y(val) {}
    Vector(double x, double y) : x(x), y(y) {}
    
    // 不同类型运算
    Vector operator*(double scalar) const {
        return {x * scalar, y * scalar};
    }
    
    friend Vector operator*(double scalar, const Vector& v) {
        return v * scalar;
    }
};

// 使用
Vector v1;          // (0, 0)
Vector v2(5);       // (5, 5)
Vector v3(2, 3);    // (2, 3)
Vector v4 = 3 * v3; // (6, 9)
```

### 函数重载与模板结合

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

// 针对特定类型的重载
const char* max(const char* a, const char* b) {
    return (strcmp(a, b) > 0 ? a : b;
}

// 使用
cout << max(10, 15);        // 调用模板版本
cout << max("apple", "zoo"); // 调用 const char* 重载版本
```

### 常见陷阱与解决方案

1. **歧义调用**：
   ```cpp
   void process(float value);
   void process(double value);
   
   process(3.14); // 歧义：字面量3.14是double类型
   ```
   **解决**：显式类型转换 `process(static_cast<float>(3.14));`

2. **const 值参数**：
   ```cpp
   void handle(int value);
   void handle(const int value); // 无效重载
   ```
   **解决**：移除冗余 const

3. **默认参数冲突**：
   ```cpp
   void setup(int a, int b = 0);
   void setup(int a);
   ```
   **解决**：合并函数或修改参数列表

4. **继承中的隐藏**：
   ```cpp
   class Base {
   public:
       void func(int);
   };
   
   class Derived : public Base {
   public:
       void func(double); // 隐藏了Base::func(int)
   };
   ```
   **解决**：使用 `using Base::func;` 引入基类函数

### 最佳实践指南

1. **保持语义一致**：重载函数应执行逻辑相似的操作
2. **避免过度重载**：过多重载会降低代码可读性
3. **优先使用引用参数**：避免不必要的拷贝
4. **配合默认参数使用**：
   ```cpp
   // 优于多个重载
   void draw(int x, int y, int width = 100, int height = 100);
   ```
5. **提供清晰注释**：说明不同重载的用途
6. **单元测试覆盖**：确保所有重载都被正确测试

### 函数重载 vs 函数模板

| 特性         | 函数重载                     | 函数模板               |
| ------------ | ---------------------------- | ---------------------- |
| **代码生成** | 每个重载独立编译             | 按需实例化             |
| **适用场景** | 不同类型需要不同实现逻辑     | 通用算法，相同逻辑     |
| **类型转换** | 支持隐式转换                 | 严格类型匹配           |
| **可读性**   | 接口清晰但实现分散           | 单一定义但可能复杂     |
| **维护性**   | 添加新类型需修改多处         | 自动支持兼容类型       |
| **最佳实践** | 用于操作相似但实现不同的场景 | 用于通用算法和数据容器 |

### 总结

函数重载的核心价值：
1. **接口统一化**：相同概念的操作使用统一名称
   ```cpp
   display(image);  // 显示图片
   display(text);   // 显示文本
   ```
2. **类型安全性**：避免不安全的类型转换
3. **代码可读性**：`matrix.add(vector)` 比 `matrixAddVector()` 更自然
4. **扩展灵活性**：轻松支持新类型而不改变现有接口

正确使用函数重载可以：
- 创建更直观的 API
- 简化复杂接口
- 增强类型安全性
- 提高代码复用率

遵循"最小意外原则"：重载函数的行为应该符合开发者的直觉预期。当重载可能导致混淆时，优先选择不同的函数名称。