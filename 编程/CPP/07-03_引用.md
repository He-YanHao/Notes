# 引用 Reference

是一个已存在变量的别名（alias），它提供了一种安全、高效的方式间接访问变量。引用在语法上表现为直接操作原始变量，但底层通常通过指针实现。

## 核心特性
### 别名性质

引用不占用独立存储空间，它与原变量共享内存地址。

```cpp
int num = 10;
int &ref = num;  // ref 是 num 的引用
ref = 20;        // 修改 ref 即修改 num
cout << num;     // 输出 20
```

### 初始化即绑定

引用必须在声明时初始化，且**不能重新绑定**到其他变量。

```
int a = 5, b = 10;
int &r = a;     // ✅ 正确：初始化绑定
r = b;          // ❌ 错误：不是重新绑定，实际是 a = b（将 b 的值赋给 a）
```

### 无空引用

引用必须指向有效对象，不存在 `null` 引用（更安全）。

```cpp
int *ptr = nullptr;
int &ref = *ptr; // ❌ 运行时错误：解引用空指针
```

## 常见用途
#### 函数参数传递（避免拷贝）
```cpp
void swap(int &x, int &y) {
    int tmp = x;
    x = y;
    y = tmp;
}

int a = 3, b = 4;
swap(a, b); // a=4, b=3（直接修改实参）
```

#### 函数返回值（避免拷贝大对象）
```cpp
vector<int>& getLargeData() {
    static vector<int> data = {1, 2, 3};
    return data; // 返回引用而非拷贝
}

auto &vec = getLargeData(); // 高效获取数据
```

但是注意，需要`static`修饰，不然返回值被释放掉之后无法通过引用访问。

#### 范围 for 循环修改元素

```cpp
vector<int> nums = {1, 2, 3};
for (int &n : nums) {
    n *= 2; // 直接修改容器元素
}
// nums 变为 {2, 4, 6}
```

---

### 引用 vs 指针
| 特性         | 引用                     | 指针             |
| ------------ | ------------------------ | ---------------- |
| **初始化**   | 必须显式初始化           | 可以后初始化     |
| **重绑定**   | ✗ 不可改变指向           | ✓ 可改变指向     |
| **空值**     | ✗ 不能为空               | ✓ 可为 `nullptr` |
| **操作语法** | 直接使用（无解引用符号） | 需用 `*` 解引用  |
| **内存占用** | 通常不额外占用内存       | 占用指针大小内存 |

---

### 特殊引用类型
#### 常量引用 (`const &`)
- 避免意外修改
- 可绑定到临时对象（如字面量、表达式结果）
```cpp
void print(const string &s) {
    cout << s; // 安全读取
}

print("hello"); // ✅ 正确：绑定到临时 string 对象
```

#### 右值引用 (`&&`)
- C++11 引入，用于移动语义和完美转发
- 可绑定到即将销毁的临时对象
```cpp
void handle(string &&s) {
    // 可"窃取"s的资源（如内部指针）
}

handle(getTempString()); // 高效转移资源
```

---

### 注意事项
1. **不要返回局部变量的引用**
   ```cpp
   int& badFunc() {
       int x = 10;
       return x; // ❌ 危险：x 已被销毁
   }
   ```

2. **引用不是对象**
   - 不能定义引用的引用（但可通过 `typedef` 或模板间接实现）
   - 不能创建引用数组（但可创建数组的引用）
     ```cpp
     int arr[5] = {};
     int (&refArr)[5] = arr; // ✅ 数组的引用
     ```

---

### 底层实现
编译器通常将引用实现为**自动解引用的常量指针**：
```cpp
int num = 10;
int &ref = num;
// 近似等价于：
int *const ptr = &num;
*ptr = 20;  // 操作 *ptr 相当于操作 ref
```

---

### 最佳实践
1. 优先用 `const &` 传递函数参数（除非需要修改）
2. 使用引用减少大对象拷贝开销
3. 需要“重新指向”时改用指针
4. 警惕悬空引用（Dangling References）

> 引用是 C++ 高效编程的核心工具之一，合理使用可提升代码性能与可读性，同时避免指针的复杂性。