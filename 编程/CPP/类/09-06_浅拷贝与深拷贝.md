# 深拷贝与浅拷贝

## 浅拷贝 (Shallow Copy)

浅拷贝是简单的成员对成员的复制，编译器默认提供的拷贝构造函数和赋值运算符就是浅拷贝。

特点：
- 只复制指针的值（地址），而不复制指针指向的内容
- 原对象和新对象共享同一块内存
- 当其中一个对象被修改时，另一个对象也会受到影响
- 可能导致双重释放内存的问题

```cpp
class Shallow {
public:
    int* data;
    Shallow(int val) {
        data = new int(val);
    }
    // 使用编译器提供的默认拷贝构造函数（浅拷贝）
    ~Shallow() {
        delete data;
    }
};
```

## 深拷贝 (Deep Copy)

深拷贝会复制对象的所有成员，包括指针指向的动态分配的内存。

特点：
- 为新对象分配新的内存空间
- 复制原对象指针指向的实际数据
- 原对象和新对象完全独立
- 需要手动实现拷贝构造函数和赋值运算符

```cpp
class Deep {
public:
    int* data;
    Deep(int val) {
        data = new int(val);
    }
    // 自定义拷贝构造函数（深拷贝）
    Deep(const Deep& other) {
        data = new int(*other.data);
    }
    // 自定义赋值运算符（深拷贝）
    Deep& operator=(const Deep& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }
    ~Deep() {
        delete data;
    }
};
```

## 何时使用深拷贝

当类包含以下成员时，通常需要实现深拷贝：
- 指向动态分配内存的指针
- 文件句柄
- 网络连接
- 其他需要独占的资源

## 三法则 (Rule of Three)

如果一个类需要自定义以下任何一个，那么它通常需要全部三个：
1. 析构函数
2. 拷贝构造函数
3. 拷贝赋值运算符

在C++11及以后版本中，这扩展为"五法则"，增加了移动构造函数和移动赋值运算符。

## 现代C++的替代方案

为了避免手动管理深拷贝，可以考虑：
- 使用智能指针（如`std::unique_ptr`, `std::shared_ptr`）
- 使用容器类（如`std::vector`, `std::string`）
- 使用值语义而非指针语义

这些方法可以简化资源管理，减少深拷贝的实现需求。