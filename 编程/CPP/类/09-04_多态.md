# 多态 Polymorphism

## 基本介绍

**是什么？**

字面意思是“多种形态”。在 C++ 中，主要指通过**基类的指针或引用**来操作**派生类的对象**时，能够根据对象实际的派生类类型来调用正确的（派生类重写的）函数版本。

**如何实现：**

核心机制是**虚函数 (Virtual Functions)**。

*   在基类中，使用 `virtual` 关键字声明一个成员函数。
*   在派生类中，可以**覆盖 (override)** 这个虚函数（使用 `override` 关键字是好的实践，C++11 起）。

**作用：**

*   **接口统一：** 用基类指针/引用来处理不同派生类对象，编写更通用的代码。
*   **运行时绑定 (Late Binding / Dynamic Binding)：** 具体调用哪个函数是在程序运行时根据对象的实际类型决定的，而不是在编译时根据指针/引用的类型决定。

**例子：**

```cpp
class Animal {
public:// 公有成员函数 (接口)
    virtual void breathe() {
        std::cout << "它是Animal" << std::endl;
    }
};

// public 继承
class Dog : public Animal {
    public:
    void breathe() const override {
	//const：表示该成员函数不会修改对象的任何成员变量
    //override：明确表示此函数是重写基类的虚函数
	//重写必须签名匹配：
	//如果基类函数是 const 的，子类重写版本也必须是 const
	//如果基类函数不是 const 的，子类重写版本也不能是 const
        std::cout << "它是Dog" << std::endl;
    }
};

int main(int argc, char const *argv[])
{
    Dog MyDog;
    MyDog.breathe();
    return 0;
}

//输出：
//它是Dog
```



## 指针

```cpp
//野兽类 是父类
class Animal
{
public:
    virtual void speak() const
    { 
        std::cout << "Animal sound\n";
    }
    //
    virtual ~Animal() = default;
    //default生成默认构造或析构函数
};

//狗类 是野兽类的子类
class Dog : public Animal
{
public:
    void speak() const override
    {
        std::cout << "Woof!\n";
    }
};

//猫类 是野兽类的子类
class Cat : public Animal {
public:
    void speak() const override
    {
        std::cout << "Meow!\n";
    }
};

int main()
{
    Animal* animals[] = {new Dog(), new Cat()};
	//此处同时申请了两个指针，但同时子类的函数将父类覆盖掉了，可以将两个子对象的指针指向父项，直接调用父项的函数。    
    for (Animal* a : animals)
        //这是一个容器Animal，遍历一遍animals，每次成员为a。
    {
        a->speak(); // 多态调用
        delete a;
    }
}
```





## 构造函数与析构函数的虚函数

```cpp
class Base {
public:
    Base() { std::cout << "Base constructed\n"; }
    virtual ~Base() { // 关键：虚析构函数
        std::cout << "Base destroyed\n";
    }
};

class Derived : public Base {
public:
    Derived() { 
        data = new int[100]; // 分配资源
        std::cout << "Derived constructed\n"; 
    }
    // 子类析构函数自动成为虚函数（覆盖基类）
    ~Derived() {
        delete[] data; // 释放子类资源
        std::cout << "Derived destroyed\n";
    }
private:
    int* data;
};

int main() {
    Base* obj = new Derived(); // 基类指针指向派生类对象    
    // 正确调用派生类析构函数
    delete obj;
    return 0;
}
```

输出结果：

```cpp
Base constructed
//创建子类时首先创建父类，则自动调用父类构造函数。
Derived constructed
//然后调用子类构造函数
Derived destroyed
//子类先释放，调用子类析构函数。
Base destroyed
//父类随后释放，调用父类析构函数。
```



