# 运算符重载

运算符重载是 C++ 的核心特性之一，它允许我们为自定义类型（类或结构体）赋予与内置类型相似的运算符行为，使代码更直观、更接近自然表达。

## 核心概念

**关键字：** `operator`

**本质**：运算符重载是一种特殊形式的函数重载

**语法**：

```cpp
返回类型 operator运算符(参数列表) {
    // 实现逻辑
}
```

**限制**：

- 不能创建新运算符（如 `**`）
- 不能改变运算符优先级
- 至少一个操作数需为用户定义类型

**可重载的运算符类型**

- 算术运算符：`+`, `-`, `*`, `/`, `%`
- 关系运算符：`==`, `!=`, `<`, `>`, `<=`, `>=`
- 逻辑运算符：`&&`, `||`, `!`
- 位运算符：`&`, `|`, `^`, `~`, `<<`, `>>`
- 赋值运算符：`=`, `+=`, `-=`, 等
- 下标运算符：`[]`
- 函数调用运算符：`()`
- 流运算符：`<<`, `>>`
- 内存管理：`new`, `delete`

**不可重载的运算符**

- `.`（成员访问）
- `.*`（成员指针访问）
- `::`（作用域解析）
- `?:`（三元条件）
- `sizeof`
- `typeid`

## 重载方式对比

| 方式         | 成员函数重载           | 非成员函数重载       |
| ------------ | ---------------------- | -------------------- |
| **语法**     | `类内定义`             | `全局函数`           |
| **左操作数** | 必须是类对象           | 可以是任意类型       |
| **访问权限** | 可直接访问私有成员     | 通常需声明为友元     |
| **常见用途** | 赋值、下标、函数调用等 | 输入输出、算术运算等 |

## 常用运算符重载示例

### 算术运算符重载（+）

比如计算坐标，每个坐标包含`(x,y)`，坐标相加方式为 x + x ，y + y，但坐标一般为自定义的数据类型(类或结构体)，无法直接相加，可以通过重载运算符为其定制相加关系。

```cpp
class Vector {
public:
    double x, y;
    // 成员函数形式
    Vector operator+(const Vector& v) const {
        return {x + v.x, y + v.y};
    }
};

// 非成员函数形式（常声明为友元）
Vector operator+(const Vector& v1, const Vector& v2) {
    return {v1.x + v2.x, v1.y + v2.y};
}
```



### 流运算符重载（<<）



```cpp
#include <iostream>
#include <string>

class Person {
private:
    std::string name;
    int age;
public:
    Person(std::string n, int a) : name(n), age(a) {}
    // 声明友元函数（在类内部）
    friend std::ostream& operator<<(std::ostream& os, const Person& p);
};

// 实现友元函数（在类外部）
std::ostream& operator<<(std::ostream& os, const Person& p) {
    os << "Name: " << p.name << ", Age: " << p.age; // 直接访问私有成员
    return os;  // 返回流引用以支持链式调用
}

int main() {
    Person alice("Alice", 30);
    std::cout << alice << std::endl;  // 输出：Name: Alice, Age: 30    
    return 0;
}
```





# 还没看



#### 3. 比较运算符重载（==）

```cpp
class Date {
    int year, month, day;
public:
    bool operator==(const Date& other) const {
        return year == other.year 
            && month == other.month 
            && day == other.day;
    }
};
```

#### 4. 下标运算符重载（[]）
```cpp
class IntArray {
    int* data;
    size_t size;
public:
    int& operator[](size_t index) {
        if (index >= size) throw out_of_range("索引越界");
        return data[index];
    }
    
    // const版本
    const int& operator[](size_t index) const {
        // 同上...
    }
};

// 使用
IntArray arr(10);
arr[3] = 42;  // 像内置数组一样访问
```

#### 5. 函数调用运算符（()）
```cpp
class Multiplier {
public:
    int operator()(int a, int b) const {
        return a * b;
    }
};

// 使用
Multiplier mul;
cout << mul(6, 7);  // 输出: 42
```

#### 6. 自增/自减运算符（++/--）
```cpp
class Counter {
    int count;
public:
    // 前置++
    Counter& operator++() {
        ++count;
        return *this;
    }
    
    // 后置++（int参数仅用于区分）
    Counter operator++(int) {
        Counter temp = *this;
        ++count;
        return temp;
    }
};
```

### 高级应用场景

#### 1. 智能指针运算符重载
```cpp
class SmartPtr {
    Resource* ptr;
public:
    Resource* operator->() { return ptr; }
    Resource& operator*() { return *ptr; }
};

// 使用
SmartPtr ptr(new Resource);
ptr->method();  // 像普通指针一样使用
```

#### 2. 类型转换运算符
```cpp
class Rational {
    int num, den;
public:
    operator double() const { 
        return static_cast<double>(num) / den; 
    }
};

// 使用
Rational r(3, 4);
double d = r;  // 自动转换为0.75
```

#### 3. 复合赋值运算符
```cpp
class BigInt {
    // ...
public:
    BigInt& operator+=(const BigInt& other) {
        // 实现加法逻辑
        return *this;
    }
};

// 使用
BigInt a, b;
a += b;  // 高效复合赋值
```

### 最佳实践与注意事项

1. **保持语义一致性**：
   - `operator+` 不应执行减法操作
   - `operator==` 应与 `operator!=` 行为一致

2. **效率优先**：
   ```cpp
   // 返回引用避免拷贝
   Vector& operator+=(const Vector& v) {
       x += v.x;
       y += v.y;
       return *this;
   }
   ```

3. **处理特殊边界**：
   ```cpp
   // 防止自赋值
   Vector& operator=(const Vector& other) {
       if (this != &other) {
           x = other.x;
           y = other.y;
       }
       return *this;
   }
   ```

4. **提供完整运算符集**：
   - 实现 `+` 时也应实现 `+=`
   - 实现 `==` 时提供 `!=`
   - 实现 `<` 时提供 `>`, `<=`, `>=`

5. **避免隐式转换陷阱**：
   ```cpp
   explicit operator bool() const {  // 使用explicit防止意外转换
       return isValid();
   }
   ```

### 运算符重载决策表

| 运算符  | 推荐形式   | 返回类型      | 注意事项      |
| ------- | ---------- | ------------- | ------------- |
| `+ - *` | 非成员函数 | 新对象        | 保持对称性    |
| `= +=`  | 成员函数   | 引用          | 处理自赋值    |
| `== !=` | 非成员函数 | bool          | 成对实现      |
| `<< >>` | 非成员友元 | 流引用        | 修改流状态    |
| `[]`    | 成员函数   | 引用          | 提供const版本 |
| `->`    | 成员函数   | 指针/智能指针 | 可链式调用    |
| `()`    | 成员函数   | 任意类型      | 创建函数对象  |

### 总结

运算符重载让用户自定义类型拥有与内置类型一致的操作体验：
- 提升代码可读性（`a + b` vs `a.add(b)`）
- 增强类型抽象能力
- 支持模板元编程
- 实现领域特定语言（DSL）

遵循"做该做的事"原则：
- 保持运算符的直观语义
- 优先实现复合赋值运算符（如 `+=`）
- 通过非成员函数支持左右操作数的对称性
- 为资源管理类提供完整的运算符集

正确使用运算符重载能让代码更优雅、更高效，但滥用会导致代码晦涩难懂。始终以提升代码清晰度和维护性为目标。