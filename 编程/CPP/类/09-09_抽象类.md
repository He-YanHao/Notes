# C++ 抽象类详解

抽象类是 C++ 中实现接口和抽象概念的核心机制，它通过纯虚函数定义了一组必须由派生类实现的接口规范。抽象类不能被实例化，其主要目的是为派生类提供一个通用的接口框架。

## 抽象类的定义

抽象类通过声明**至少一个纯虚函数**来定义：

```cpp
class AbstractClass {
public:
    // 纯虚函数 (pure virtual function)
    virtual void pureVirtualFunction() = 0;
    
    // 虚函数 (可以有默认实现)
    virtual void virtualFunction() {
        // 默认实现
    }
    
    // 普通成员函数
    void concreteFunction() {
        // 具体实现
    }

    // 虚析构函数 (必须!)
    virtual ~AbstractClass() = default;
};
```

## 关键特性

### 纯虚函数 (Pure Virtual Functions)
- 使用 `= 0` 语法声明
- **没有默认实现**（但可以在类外提供实现）
- 强制派生类必须重写

```cpp
virtual void mustImplement() const = 0;  // 纯虚函数
```

### 不能实例化
```cpp
AbstractClass obj;  // 错误：抽象类不能被实例化
```

### 派生类必须实现所有纯虚函数
```cpp
class ConcreteClass : public AbstractClass {
public:
    // 必须实现所有纯虚函数
    void pureVirtualFunction() override {
        // 具体实现
    }
};
```

## 抽象类的用途

### 定义接口规范
```cpp
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
};

class Circle : public Drawable {
public:
    void draw() const override {
        std::cout << "Drawing circle\n";
    }
};

class Square : public Drawable {
public:
    void draw() const override {
        std::cout << "Drawing square\n";
    }
};
```

### 提供部分实现
```cpp
class DatabaseAccess {
public:
    virtual void connect() = 0;
    virtual void disconnect() = 0;
    
    void executeQuery(const std::string& query) {
        connect();
        std::cout << "Executing: " << query << "\n";
        disconnect();
    }
    
    virtual ~DatabaseAccess() = default;
};
```

### 实现多态行为
```cpp
void render(const std::vector<Drawable*>& objects) {
    for (auto obj : objects) {
        obj->draw();  // 多态调用
    }
}
```

## 抽象类 vs 接口

在 C++ 中，接口通常用**纯抽象类**实现（所有函数都是纯虚函数）：

| 特性     | 抽象类       | 接口 (纯抽象类)  |
| -------- | ------------ | ---------------- |
| 纯虚函数 | 至少一个     | 所有函数都是纯虚 |
| 成员变量 | 可以有       | 通常只有常量     |
| 非虚函数 | 可以有       | 没有             |
| 构造函数 | 可以有       | 可以有           |
| 使用场景 | 提供部分实现 | 定义纯粹接口     |

```cpp
// 接口示例 (纯抽象类)
class Serializable {
public:
    virtual std::string toJson() const = 0;
    virtual void fromJson(const std::string& json) = 0;
    virtual ~Serializable() = default;
};
```

## 高级用法

### 纯虚函数的实现
纯虚函数可以在类外提供实现，供派生类显式调用：

```cpp
class Abstract {
public:
    virtual void pureVirtual() = 0;
};

// 提供纯虚函数的实现
void Abstract::pureVirtual() {
    std::cout << "Default implementation\n";
}

class Concrete : public Abstract {
public:
    void pureVirtual() override {
        Abstract::pureVirtual();  // 调用基类实现
        std::cout << "Extended implementation\n";
    }
};
```

### 2. 多继承中的抽象类
```cpp
class InputDevice {
public:
    virtual void readInput() = 0;
    virtual ~InputDevice() = default;
};

class OutputDevice {
public:
    virtual void display() = 0;
    virtual ~OutputDevice() = default;
};

class TouchScreen : public InputDevice, public OutputDevice {
public:
    void readInput() override {
        std::cout << "Reading touch input\n";
    }
    
    void display() override {
        std::cout << "Displaying content\n";
    }
};
```

### 3. 抽象类作为策略模式的基础
```cpp
class SortingStrategy {
public:
    virtual void sort(std::vector<int>& data) = 0;
    virtual ~SortingStrategy() = default;
};

class QuickSort : public SortingStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Quick sorting...\n";
        // 具体实现
    }
};

class MergeSort : public SortingStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Merge sorting...\n";
        // 具体实现
    }
};
```

## 设计原则

### 1. 开闭原则 (Open/Closed Principle)
抽象类允许扩展（新派生类）而不修改现有代码

### 2. 依赖倒置原则 (Dependency Inversion Principle)
高层模块不应依赖低层模块，二者都应依赖抽象

```cpp
// 高层模块依赖抽象
class ReportGenerator {
public:
    ReportGenerator(DatabaseAccess& db) : db(db) {}
    
    void generate() {
        db.executeQuery("SELECT * FROM data");
    }
    
private:
    DatabaseAccess& db;
};
```

### 3. 接口隔离原则 (Interface Segregation Principle)
创建特定于客户端的细粒度接口

## 最佳实践

1. **总是声明虚析构函数**
   ```cpp
   virtual ~AbstractClass() = default;
   ```

2. **使用 `override` 关键字**
   ```cpp
   void draw() const override { ... }
   ```

3. **避免在抽象类中包含状态**
   优先使用纯虚函数而非成员变量

4. **考虑使用 `final` 防止进一步派生**
   ```cpp
   class Concrete final : public Abstract { ... };
   ```

5. **工厂模式创建对象**
   ```cpp
   class ShapeFactory {
   public:
       static std::unique_ptr<Shape> createShape(ShapeType type);
   };
   ```

## 抽象类的优势

1. **强制接口实现**：确保派生类符合规范
2. **多态支持**：实现运行时多态行为
3. **代码复用**：通过部分实现减少重复代码
4. **解耦合**：降低模块间的依赖关系
5. **扩展性**：容易添加新的派生类实现

## 总结

C++ 抽象类是面向对象设计中的强大工具：
- 通过纯虚函数定义必须实现的接口
- 不能被实例化，只能作为基类
- 支持提供部分实现（非纯虚函数）
- 是实现多态、接口隔离和依赖倒置的关键
- 虚析构函数是必需的
- 是设计模式（如策略、工厂、观察者）的基础

正确使用抽象类可以创建更灵活、可维护和可扩展的系统架构，它们是定义通用接口和实现多态行为的理想选择。