# 继承 Inheritance

## 基本介绍

**是什么？**

允许一个类（称为派生类或子类）基于另一个类（称为基类或父类）来创建新类。派生类继承基类的属性和方法。

**作用：**

*   **代码重用：** 避免重复编写基类已有的代码。
*   **建立层次关系：** 模拟现实世界“是一个(Is-A)”的关系（例如，`ElectricCar` *是一个* `Car`）。
*   **实现多态的基础。**

**类型：** `public`, `protected`, `private` 继承（最常用的是 `public` 继承）。

**标准格式：**

```cpp
class BaseClass {
    // 基类成员
};

class DerivedClass : 继承方式 BaseClass {
    // 派生类成员
};
```

- 继承方式：public protected private
- 默认继承方式为 **private**

## 三种继承方式对比

| 继承方式  | 基类 public 成员         | 基类 protected 成员      | 基类 private 成员 |
| :-------- | :----------------------- | :----------------------- | :---------------- |
| public    | 在派生类中保持 public    | 在派生类中保持 protected | 不可访问          |
| protected | 在派生类中变为 protected | 在派生类中保持 protected | 不可访问          |
| private   | 在派生类中变为 private   | 在派生类中变为 private   | 不可访问          |

- **案例**：

  ```cpp
  class Animal {
  public:// 公有成员函数 (接口)
      void breathe() {}
  protected:// 受保护成员 (派生类可以访问)
      void move() {}
  private:// 私有成员变量 (实现细节)
      void digest() {}
  };
  
  // public 继承
  class Dog : public Animal {
      // breathe() 保持 public
      // move() 保持 protected
      // digest() 不可访问
  };
  
  // protected 继承
  class Cat : protected Animal {
      // breathe() 变为 protected
      // move() 保持 protected
      // digest() 不可访问
  };
  
  // private 继承
  class Bird : private Animal {
      // breathe() 变为 private
      // move() 变为 private
      // digest() 不可访问
  };
  ```

## 同名成员处理方式

```cpp
class Animal {
public:// 公有成员函数 (接口)
	int age = 10;
protected:// 受保护成员 (派生类可以访问)
private:// 私有成员变量 (实现细节)
};

// public 继承
class Dog : public Animal {
	int age = 20;
};

Dog MyDog;
//访问的是Dog类
MyDog.age;
//访问的是Animal类
MyDog.Animal::age;
```

## 多重继承

一个类可以同时从两个或多个基类继承。这是 C++ 区别于许多其他面向对象编程语言（如 Java 和 C#）的一个重要特性。

基本语法：

```cpp
class Derived : public Base1, public Base2, ... {
    // 派生类成员
};
```

额外介绍：

基类的构造函数按**继承声明顺序**调用，而不是按初始化列表顺序。

当多个基类有同名成员时，需要通过作用域解析符指定。

### 菱形继承



# 没看

## 问题（钻石问题）


```cpp
    A
   / \
  B   C
   \ /
    D
```

这是多继承中最著名的挑战：

问题描述：

```cpp
class A {
public:
    int value;
};

class B : public A {};
class C : public A {};
class D : public B, public C {};

int main() {
    D d;
    d.value = 10;  // 错误：歧义，不知道是B::value还是C::value
}
```

解决方案：虚继承（virtual inheritance）

```cpp
class A {
public:
    int value;
};

class B : virtual public A {};  // 虚继承
class C : virtual public A {};  // 虚继承
class D : public B, public C {};
```

这会导致

```cpp
D d;
d.value = 10;  // 现在只有一个共享的A子对象
d.B::value = 5; // 仍然可以访问，但指向同一个内存位置
d.C::value = 8; // 同上，最终值会是8

//d.A::value d.B::value d.C::value指向同一块内存
```





## 多继承的最佳实践

1. **优先使用组合而非多继承**：大多数情况下，组合更安全、更灵活

2. **使用接口类**：多继承最适合用于纯虚类（接口）

   cpp

   ```
   class Printable {
   public:
       virtual void print() const = 0;
   };
   
   class Serializable {
   public:
       virtual std::string serialize() const = 0;
   };
   
   class Document : public Printable, public Serializable {
       // 实现两个接口
   };
   ```

3. **避免菱形继承**：除非必要且理解虚继承的机制

4. **明确解决歧义**：使用作用域解析符消除同名冲突

## 多继承的优缺点

**优点**：

- 更灵活地组合功能
- 支持接口继承模式
- 更精确地建模现实世界关系

**缺点**：

- 增加代码复杂性
- 可能导致菱形继承问题
- 对象布局更复杂（影响内存布局和性能）
- 其他语言不支持，影响可移植性

## 结论

C++ 支持多继承，允许一个类同时继承多个基类。虽然这提供了强大的表达能力，但也带来了额外的复杂性，特别是菱形继承问题。在大多数情况下，优先考虑组合或接口继承（使用纯虚基类），并在确实需要多继承时谨慎使用虚继承解决菱形继承问题。















