# 排序及相关操作 Sorting and Related Operations



## sort

```cpp
std::sort(vec.begin(), vec.end(), Comparator());
```

- `std::sort( );`

  - **作用**：标准库中的排序算法
  - **功能**：对指定范围内的元素进行排序
  - **头文件**：`#include <algorithm>`

- `vec.begin(), vec.end()`

  - **作用**：定义排序范围
  - **含义**：
    - `vec.begin()`：指向容器第一个元素的迭代器
    - `vec.end()`：指向容器最后一个元素**之后**的迭代器
  - **范围**：`[begin, end)` - 左闭右开区间

- `Comparator()`

  - `Comparator()` 必须是一个**可调用对象**，且满足
  - 接受两个参数（同容器元素类型）
  - 返回 `bool` 值
  - 满足**严格弱序**关系：

  - 自反性：`comp(a, a) == false`
  - 反对称性：若 `comp(a, b) == true`，则 `comp(b, a) == false`
  - 传递性：若 `comp(a, b)` 和 `comp(b, c)`，则 `comp(a, c)`

```cpp
struct Ascending {
    bool operator()(int a, int b) const {
        return a < b; // 升序排序
    }
};

struct Descending {
    bool operator()(int a, int b) const {
        return a > b; // 降序排序
    }
};

int num[] = {51,5,48,546,97,1,3,64,97,654,94,94};
// 使用
std::sort(std::begin(num), std::end(num), Ascending());
```





# 保留





*   这些算法通常需要随机访问迭代器（如 `vector`, `deque`, `array` 的迭代器）。
*   **常用算法：**
    *   `sort`：对范围进行**不稳定**排序（通常基于快速排序的混合实现，平均 O(n log n)，最坏 O(n²)）。
    *   `stable_sort`：对范围进行**稳定**排序（相等元素的相对顺序保持不变，通常基于归并排序，O(n log n) 或 O(n log² n)）。
    *   `partial_sort`：部分排序，使前 n 个元素是整个范围内最小的 n 个元素并按序排列，后面元素无序。
    *   `partial_sort_copy`：部分排序并将结果复制到目标范围。
    *   `nth_element`：部分排序，使得第 n 个位置的元素处于其最终排序后应在的位置，其前面的元素都不大于它，后面的元素都不小于它（不保证前后部分内部有序）。
    *   `is_sorted` (C++11)：检查范围是否已排序。
    *   `is_sorted_until` (C++11)：查找范围中第一个破坏有序性的元素。
    *   **二分搜索操作 (在已排序范围上使用，效率 O(log n))：**
        *   `lower_bound`：查找第一个**不小于**给定值的元素位置。
        *   `upper_bound`：查找第一个**大于**给定值的元素位置。
        *   `equal_range`：返回一个迭代器对 `[lower_bound, upper_bound)`，表示等于给定值的子范围。
        *   `binary_search`：检查范围中是否存在等于给定值的元素（返回 bool）。
    *   **合并操作 (操作已排序序列)：**
        *   `merge`：合并两个已排序序列到一个新的有序序列。
        *   `inplace_merge`：原地合并同一个序列中两个连续的有序子序列。