# C++ STL `std::set` 详解

`std::set` 是 C++ STL 中一个重要的**关联容器**，它存储**唯一键（key）** 的集合，并按照特定排序准则自动排序。其内部通常使用**红黑树**（自平衡二叉查找树）实现。

## 核心特性

1. **唯一键值**：每个元素在集合中都是唯一的（不允许重复）
2. **自动排序**：元素在插入时自动按排序准则排序（默认升序）
3. **高效查找**：基于红黑树实现，查找时间复杂度为 **O(log n)**
4. **不可修改键值**：元素值不能被直接修改（会破坏排序）
5. **双向迭代器**：支持正向和反向遍历

```mermaid
graph TD
    A[std::set] --> B[唯一键值]
    A --> C[自动排序]
    A --> D[红黑树实现]
    A --> E[高效查找 O(log n)]
    A --> F[双向迭代器]
```

## 基本操作

### 头文件与声明
```cpp
#include <set>

// 基本声明
std::set<int> mySet;

// 自定义排序
struct CaseInsensitiveCompare {
    bool operator()(const std::string& a, const std::string& b) const {
        return std::lexicographical_compare(
            a.begin(), a.end(), b.begin(), b.end(),
            [](char c1, char c2) { 
                return std::tolower(c1) < std::tolower(c2); 
            });
    }
};

std::set<std::string, CaseInsensitiveCompare> caseInsensitiveSet;
```

### 常用操作
```cpp
// 插入元素
std::set<int> s;
s.insert(10);
s.insert({5, 15, 8, 12});  // 插入多个元素

// 删除元素
s.erase(8);                 // 删除值为8的元素
auto it = s.find(10);
if (it != s.end()) {
    s.erase(it);            // 通过迭代器删除
}

// 查找元素
if (s.find(12) != s.end()) {
    std::cout << "12 found in set\n";
}

// 检查存在性
if (s.count(5) > 0) {       // 返回1表示存在
    std::cout << "5 exists\n";
}

// 获取大小
std::cout << "Size: " << s.size() << "\n";
```

## 内部实现原理

`std::set` 通常基于**红黑树**实现，具有以下特点：
- 每个节点包含键值、颜色标记（红/黑）和子节点指针
- 自动保持平衡，确保最长路径不超过最短路径的2倍
- 插入/删除/查找操作时间复杂度均为 O(log n)

```plaintext
         [BLACK: 10]
        /          \
[RED: 5]         [RED: 15]
     \             /
   [BLACK: 8] [BLACK: 12]
```

## 时间复杂度对比

| 操作         | `std::set` | `std::vector` | `std::unordered_set` |
| ------------ | ---------- | ------------- | -------------------- |
| **插入**     | O(log n)   | O(n)          | O(1) 平均            |
| **删除**     | O(log n)   | O(n)          | O(1) 平均            |
| **查找**     | O(log n)   | O(n)          | O(1) 平均            |
| **范围查询** | 优秀       | 差            | 差                   |
| **有序遍历** | 支持       | 需要排序      | 不支持               |

## 特殊操作与算法

### 边界查找
```cpp
std::set<int> s = {5, 10, 15, 20, 25};

// 第一个不小于10的元素
auto lower = s.lower_bound(10);  // 指向10

// 第一个大于15的元素
auto upper = s.upper_bound(15);  // 指向20

// 等于范围 [10, 10]
auto range = s.equal_range(10);  
// range.first → 10, range.second → 15
```

### 集合操作
```cpp
std::set<int> a = {1, 2, 3, 4};
std::set<int> b = {3, 4, 5, 6};
std::set<int> result;

// 并集
std::set_union(a.begin(), a.end(), 
               b.begin(), b.end(),
               std::inserter(result, result.begin()));
// result = {1,2,3,4,5,6}

// 交集
std::set_intersection(a.begin(), a.end(), 
                     b.begin(), b.end(),
                     std::inserter(result, result.begin()));
// result = {3,4}

// 差集 (a - b)
std::set_difference(a.begin(), a.end(), 
                   b.begin(), b.end(),
                   std::inserter(result, result.begin()));
// result = {1,2}
```

## 迭代器特性

- **双向迭代器**：支持 `++` 和 `--` 操作
- **稳定性**：插入操作不会使迭代器失效（删除只影响被删除元素的迭代器）
- **常迭代器**：`const_iterator` 防止修改键值
- **反向迭代器**：`rbegin()` 和 `rend()` 支持反向遍历

```cpp
// 正向遍历
for (auto it = s.begin(); it != s.end(); ++it) {
    std::cout << *it << " ";
}

// 反向遍历
for (auto rit = s.rbegin(); rit != s.rend(); ++rit) {
    std::cout << *rit << " ";
}
```

## 自定义类型使用

要使用自定义类型作为 `set` 的键，需要提供比较函数：

```cpp
struct Person {
    std::string name;
    int age;
};

// 方法1: 重载 operator<
bool operator<(const Person& a, const Person& b) {
    return a.age < b.age;  // 按年龄排序
}

// 方法2: 使用函数对象
struct PersonCompare {
    bool operator()(const Person& a, const Person& b) const {
        return a.name < b.name;  // 按姓名排序
    }
};

std::set<Person> ageSet;  // 使用operator<
std::set<Person, PersonCompare> nameSet;  // 使用自定义比较器
```

## 与 map/multiset 的比较

| 特性           | `std::set`   | `std::map`         | `std::multiset`    |
| -------------- | ------------ | ------------------ | ------------------ |
| **存储内容**   | 单个键值     | 键值对 (key-value) | 单个键值（可重复） |
| **元素唯一性** | 唯一         | 键唯一             | 允许重复键值       |
| **访问元素**   | 直接访问键值 | 通过键访问值       | 直接访问键值       |
| **典型用途**   | 唯一值集合   | 字典/映射表        | 可重复值集合       |

## 使用场景

1. **需要有序唯一元素的集合**
   - 用户ID管理
   - 唯一标识符存储

2. **需要高效查找和插入**
   - 字典实现
   - 白名单/黑名单系统

3. **需要范围查询**
   - 成绩分级系统
   - 价格区间查询

4. **需要有序遍历**
   - 按顺序处理任务
   - 生成有序报告

## 性能优化技巧

1. **使用 emplace 避免拷贝**
   ```cpp
   // 优于 insert(Person("Alice", 30))
   mySet.emplace("Alice", 30);
   ```

2. **利用位置提示提高插入效率**
   ```cpp
   auto hint = mySet.lower_bound(25);
   mySet.insert(hint, 22);  // 在25附近插入
   ```

3. **批量操作**
   ```cpp
   std::vector<int> values = {15, 20, 25, 30};
   mySet.insert(values.begin(), values.end());
   ```

4. **自定义轻量比较器**
   ```cpp
   struct LightweightCompare {
       bool operator()(const BigObject& a, const BigObject& b) const {
           return a.id < b.id;  // 避免复制大对象
       }
   };
   ```

## 示例：学生成绩系统

```cpp
#include <set>
#include <string>
#include <iostream>

struct Student {
    int id;
    std::string name;
    int score;
};

bool operator<(const Student& a, const Student& b) {
    return a.score > b.score;  // 按成绩降序
}

int main() {
    std::set<Student> gradebook = {
        {101, "Alice", 85},
        {102, "Bob", 92},
        {103, "Charlie", 78}
    };

    // 添加新学生
    gradebook.insert({104, "Diana", 88});

    // 查找90分以上的学生
    auto top = gradebook.lower_bound(Student{0, "", 90});
    
    std::cout << "Top students:\n";
    for (auto it = gradebook.begin(); it != top; ++it) {
        std::cout << it->name << ": " << it->score << "\n";
    }

    // 更新学生成绩（需删除再插入）
    auto it = gradebook.find(Student{0, "Bob", 0});
    if (it != gradebook.end()) {
        Student updated = *it;
        updated.score = 95;
        gradebook.erase(it);
        gradebook.insert(updated);
    }
}
```

## 总结

`std::set` 的核心优势：
- **自动排序**：元素始终保持有序状态
- **高效查找**：对数时间复杂度的查找操作
- **元素唯一性**：自动处理重复值
- **迭代器稳定性**：插入操作不影响现有迭代器

**最佳使用场景**：
- 需要维护有序唯一集合
- 需要频繁查找操作
- 需要范围查询或有序遍历
- 键值不可修改的场景

**替代方案考虑**：
- 需要键值对 → `std::map`
- 允许重复元素 → `std::multiset`
- 不要求有序 → `std::unordered_set`
- 需要频繁修改值 → `std::vector` + `std::sort`