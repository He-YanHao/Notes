# C++ STL 关联容器详解

关联容器是 C++ STL 的核心组件，用于**存储键值对或键的集合**，并基于键进行**高效查找**。与顺序容器不同，关联容器不维护元素的插入顺序，而是根据键的特定顺序或哈希值组织元素。

## 关联容器分类概览

| **容器**                  | **键唯一性** | **存储内容** | **底层实现** | **排序方式** | **查找复杂度** |
| ------------------------- | ------------ | ------------ | ------------ | ------------ | -------------- |
| `std::set`                | 唯一         | 键           | 红黑树       | 有序         | O(log n)       |
| `std::map`                | 唯一         | 键值对       | 红黑树       | 有序         | O(log n)       |
| `std::multiset`           | 允许重复     | 键           | 红黑树       | 有序         | O(log n)       |
| `std::multimap`           | 允许重复     | 键值对       | 红黑树       | 有序         | O(log n)       |
| `std::unordered_set`      | 唯一         | 键           | 哈希表       | 无序         | O(1) 平均      |
| `std::unordered_map`      | 唯一         | 键值对       | 哈希表       | 无序         | O(1) 平均      |
| `std::unordered_multiset` | 允许重复     | 键           | 哈希表       | 无序         | O(1) 平均      |
| `std::unordered_multimap` | 允许重复     | 键值对       | 哈希表       | 无序         | O(1) 平均      |

## 有序关联容器（基于红黑树）

### 1. `std::set`
- **特点**：存储唯一键的有序集合
- **操作**：
  ```cpp
  #include <set>
  std::set<int> s = {3, 1, 4, 1, 5}; // {1, 3, 4, 5}
  
  s.insert(2);       // 插入元素
  s.erase(4);        // 删除元素
  if (s.find(3) != s.end()) { /* 存在 */ }
  int count = s.count(5); // 1（存在）或0（不存在）
  ```

### 2. `std::map`
- **特点**：存储唯一键的有序键值对
- **操作**：
  ```cpp
  #include <map>
  std::map<std::string, int> ages;
  ages["Alice"] = 30;      // 插入或修改
  ages.insert({"Bob", 25}); // 插入
  
  auto it = ages.find("Alice");
  if (it != ages.end()) {
      std::cout << it->first << ": " << it->second;
  }
  
  ages.erase("Bob"); // 删除
  ```

### 3. `std::multiset` 和 `std::multimap`
- 允许键重复
- 操作类似 set/map，但 count() 可能返回大于1的值
- equal_range() 获取键的所有元素范围：
  ```cpp
  std::multimap<std::string, int> scores;
  scores.insert({"Alice", 90});
  scores.insert({"Alice", 85});
  
  auto range = scores.equal_range("Alice");
  for (auto it = range.first; it != range.second; ++it) {
      std::cout << it->second << " "; // 90 85
  }
  ```

## 无序关联容器（基于哈希表）

### 1. `std::unordered_set` 和 `std::unordered_map`
- **特点**：哈希表实现，平均O(1)查找
- **操作**：
  ```cpp
  #include <unordered_map>
  std::unordered_map<std::string, int> phonebook;
  phonebook["Alice"] = 123456;
  
  // 自定义哈希函数
  struct MyHash {
      size_t operator()(const MyClass& obj) const {
          return std::hash<int>()(obj.id);
      }
  };
  
  std::unordered_set<MyClass, MyHash> customSet;
  ```

### 2. 哈希容器性能优化
```cpp
std::unordered_map<std::string, int> map;

// 1. 预分配桶
map.reserve(1000); // 减少rehash次数

// 2. 设置负载因子
map.max_load_factor(0.7); // 默认1.0

// 3. 自定义高效哈希
struct StringHash {
    size_t operator()(const std::string& s) const {
        return std::hash<std::string_view>()(std::string_view(s));
    }
};
```

## 关联容器核心操作对比

### 通用操作
```cpp
// 插入
c.insert(value); 

// 删除
c.erase(key);     // 按键删除
c.erase(iterator); // 按迭代器删除

// 查找
auto it = c.find(key);
if (it != c.end()) { /* 找到 */ }

// 计数
size_t n = c.count(key); // 存在数量

// 范围查找（有序容器）
auto lower = c.lower_bound(key); // 第一个不小于key的元素
auto upper = c.upper_bound(key); // 第一个大于key的元素
auto range = c.equal_range(key); // [lower_bound, upper_bound)
```

### 特殊操作
| **操作**         | 有序容器 | 无序容器      | 说明                    |
| ---------------- | -------- | ------------- | ----------------------- |
| `operator[]`     | map      | unordered_map | 访问或插入元素（仅map） |
| `at()`           | map      | unordered_map | 带边界检查访问          |
| `bucket_count()` | ❌        | ✅             | 返回桶数量              |
| `load_factor()`  | ❌        | ✅             | 当前负载因子            |
| `rehash(n)`      | ❌        | ✅             | 设置桶数量              |

## 容器选择指南

### 何时选择有序容器
1. 需要元素有序遍历
2. 需要范围查询（如查找10-20之间的值）
3. 内存敏感场景（哈希表有额外开销）
4. 键类型无高效哈希函数
5. 需要稳定性能（哈希表最坏情况O(n)）

### 何时选择无序容器
1. 需要最高查找性能
2. 不需要有序遍历
3. 有高质量哈希函数
4. 内存充足
5. 接受最坏情况性能波动

## 性能对比

| **操作** | 有序容器     | 无序容器（平均） | 无序容器（最坏） |
| -------- | ------------ | ---------------- | ---------------- |
| 插入     | O(log n)     | O(1)             | O(n)             |
| 删除     | O(log n)     | O(1)             | O(n)             |
| 查找     | O(log n)     | O(1)             | O(n)             |
| 范围查询 | O(log n + k) | O(n)             | O(n)             |
| 内存占用 | 较低         | 较高（桶+链表）  | 较高             |

## 自定义键类型

### 有序容器要求
```cpp
struct MyKey {
    int id;
    std::string name;
    
    // 方法1：重载 operator<
    bool operator<(const MyKey& other) const {
        return std::tie(id, name) < std::tie(other.id, other.name);
    }
};

// 方法2：自定义比较器
struct KeyCompare {
    bool operator()(const MyKey& a, const MyKey& b) const {
        return a.name < b.name; // 按name排序
    }
};

std::set<MyKey> set1; // 使用 operator<
std::set<MyKey, KeyCompare> set2; // 使用自定义比较
```

### 无序容器要求
```cpp
struct MyKey {
    int id;
    std::string name;
    
    // 相等比较
    bool operator==(const MyKey& other) const {
        return id == other.id && name == other.name;
    }
};

// 自定义哈希
struct KeyHash {
    std::size_t operator()(const MyKey& k) const {
        return std::hash<int>()(k.id) ^ 
               (std::hash<std::string>()(k.name) << 1);
    }
};

std::unordered_set<MyKey, KeyHash> uset;
```

## 最佳实践

### 1. 透明比较器（C++14）
```cpp
std::set<std::string> set1;
set1.find("Hello"); // 创建临时string对象

// 使用透明比较器避免临时对象
std::set<std::string, std::less<>> set2; 
set2.find("Hello"); // 直接使用字符串字面量
```

### 2. 高效插入
```cpp
std::map<int, std::string> map;

// 低效：先构造临时对象，再复制
map.insert(std::make_pair(1, "one"));

// 高效：直接构造
map.emplace(1, "one");
```

### 3. 节点操作（C++17）
```cpp
std::set<int> set1 = {1, 2, 3};
std::set<int> set2;

// 移动节点而非复制
auto node = set1.extract(2);
set2.insert(std::move(node));
```

### 4. 合并容器（C++17）
```cpp
std::map<int, std::string> map1 = {{1, "a"}, {2, "b"}};
std::map<int, std::string> map2 = {{2, "c"}, {3, "d"}};

map1.merge(map2);
// map1: {1:"a", 2:"b", 3:"d"}
// map2: {2:"c"}（冲突键保留在源容器）
```

## 使用场景示例

### 1. 单词计数器（unordered_map）
```cpp
std::unordered_map<std::string, size_t> word_count;
std::string word;

while (std::cin >> word) {
    ++word_count[word]; // 不存在会自动插入
}

for (const auto& [word, count] : word_count) {
    std::cout << word << ": " << count << "\n";
}
```

### 2. 电话簿查询（map）
```cpp
std::map<std::string, std::string> phonebook = {
    {"Alice", "123-4567"},
    {"Bob", "234-5678"},
    {"Charlie", "345-6789"}
};

// 查找名字以A-C开头的联系人
auto low = phonebook.lower_bound("A");
auto high = phonebook.upper_bound("C");

for (auto it = low; it != high; ++it) {
    std::cout << it->first << ": " << it->second << "\n";
}
```

### 3. 多值字典（multimap）
```cpp
std::multimap<std::string, std::string> authors = {
    {"Bjarne", "C++ Programming"},
    {"Bjarne", "Tour of C++"},
    {"Scott", "Effective C++"}
};

// 获取特定作者的所有书籍
auto range = authors.equal_range("Bjarne");
for (auto it = range.first; it != range.second; ++it) {
    std::cout << it->second << "\n";
}
```

## 总结

### 有序关联容器
- **实现**：红黑树（自平衡二叉搜索树）
- **优点**：有序遍历、范围查询、内存效率高
- **缺点**：查找O(log n) 较哈希表慢
- **适用**：需要有序数据、范围查询、内存敏感场景

### 无序关联容器
- **实现**：哈希表（桶数组+链表/开放寻址）
- **优点**：平均O(1)查找插入
- **缺点**：最坏O(n)、内存开销大、无序
- **适用**：高性能查找、不需要有序遍历

### 最佳实践
1. 默认情况下：需要有序 → map/set；需要高性能 → unordered_map/unordered_set
2. 键类型：提供高质量哈希函数（无序容器）或严格弱序比较（有序容器）
3. 性能优化：预分配桶（无序容器）、使用emplace/透明比较器
4. 新特性：利用C++17的节点操作和合并功能减少拷贝

关联容器为键值数据提供了高效存储和访问机制，合理选择容器类型和优化策略可显著提升程序性能。