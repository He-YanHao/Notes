# C++ STL 顺序容器详解

顺序容器是 C++ STL 的核心组件，用于**存储元素的线性序列**，并维护元素的插入顺序。以下是 C++ 中主要顺序容器的全面介绍：

## 顺序容器概览

| **容器**            | **底层结构** | **访问方式**  | **插入/删除效率**    | **内存布局** | **迭代器类型** |
| ------------------- | ------------ | ------------- | -------------------- | ------------ | -------------- |
| `std::vector`       | 动态数组     | 随机访问 O(1) | 尾部 O(1)，其他 O(n) | 连续内存     | 随机访问       |
| `std::deque`        | 分块数组     | 随机访问 O(1) | 头尾 O(1)，中间 O(n) | 分段连续     | 随机访问       |
| `std::list`         | 双向链表     | 顺序访问 O(n) | 任意位置 O(1)        | 非连续       | 双向           |
| `std::forward_list` | 单向链表     | 顺序访问 O(n) | 任意位置 O(1)        | 非连续       | 前向           |
| `std::array`        | 固定数组     | 随机访问 O(1) | 不支持               | 连续内存     | 随机访问       |
| `std::string`       | 动态字符数组 | 随机访问 O(1) | 尾部 O(1)，其他 O(n) | 连续内存     | 随机访问       |

## 核心特性对比

### 1. `std::vector`
- **数据结构**：动态数组
- **特点**：
  - 连续内存存储
  - 尾部插入/删除高效（均摊 O(1)）
  - 随机访问高效 O(1)
  - 中间插入/删除代价高 O(n)
- **最佳场景**：
  - 需要随机访问
  - 主要在尾部操作
  - 需要连续内存

```cpp
#include <vector>
std::vector<int> vec = {1, 2, 3};
vec.push_back(4);  // 尾部插入：O(1)
int val = vec[2];  // 随机访问：O(1)
vec.insert(vec.begin() + 1, 5); // 中间插入：O(n)
```

### 2. `std::deque` (双端队列)
- **数据结构**：分块数组
- **特点**：
  - 头尾插入/删除高效 O(1)
  - 随机访问高效 O(1)
  - 内存分段连续
  - 中间插入/删除代价高 O(n)
- **最佳场景**：
  - 需要高效双端操作
  - 需要随机访问
  - 避免vector扩容成本

```cpp
#include <deque>
std::deque<int> dq = {2, 3};
dq.push_front(1);  // 头部插入：O(1)
dq.push_back(4);   // 尾部插入：O(1)
int val = dq[1];   // 随机访问：O(1)
```

### 3. `std::list` (双向链表)
- **数据结构**：双向链表
- **特点**：
  - 任意位置插入/删除高效 O(1)
  - 迭代器稳定（插入/删除不影响其他迭代器）
  - 不支持随机访问
  - 额外内存开销（每个元素两个指针）
- **最佳场景**：
  - 高频任意位置插入/删除
  - 需要稳定迭代器
  - 大型对象存储

```cpp
#include <list>
std::list<int> lst = {1, 3};
auto it = std::next(lst.begin());
lst.insert(it, 2);  // 任意位置插入：O(1)
lst.erase(it);      // 任意位置删除：O(1)
```

### 4. `std::forward_list` (单向链表)
- **数据结构**：单向链表
- **特点**：
  - 最小内存开销（每个元素一个指针）
  - 仅支持前向遍历
  - 无size()方法（C++11起）
  - 特殊插入接口（insert_after）
- **最佳场景**：
  - 内存敏感场景
  - 只需前向遍历
  - 高频插入/删除

```cpp
#include <forward_list>
std::forward_list<int> flist = {1, 3};
auto it = flist.begin();
flist.insert_after(it, 2);  // 在第一个元素后插入
```

### 5. `std::array` (固定数组)
- **数据结构**：固定大小数组
- **特点**：
  - 编译时确定大小
  - 栈上分配内存
  - 无动态扩容
  - 接口类似vector
- **最佳场景**：
  - 固定大小集合
  - 替代原生数组
  - 性能敏感场景

```cpp
#include <array>
std::array<int, 3> arr = {1, 2, 3};
int val = arr.at(1);  // 带边界检查的访问
```

### 6. `std::string` (字符串)
- **数据结构**：动态字符数组
- **特点**：
  - 专为文本设计
  - 支持短字符串优化(SSO)
  - 提供字符串专用操作
  - 连续内存存储
- **最佳场景**：
  - 文本处理
  - 字符串操作
  - 需要C风格接口

```cpp
#include <string>
std::string str = "Hello";
str += " World!";  // 字符串连接
auto substr = str.substr(0, 5);  // 子串操作
```

## 性能对比分析

### 时间复杂度总结
| **操作**      | vector | deque | list | forward_list | array | string |
| ------------- | ------ | ----- | ---- | ------------ | ----- | ------ |
| 随机访问      | O(1)   | O(1)  | O(n) | O(n)         | O(1)  | O(1)   |
| 头部插入/删除 | O(n)   | O(1)  | O(1) | O(1)         | -     | O(n)   |
| 尾部插入/删除 | O(1)*  | O(1)  | O(1) | O(n)         | -     | O(1)*  |
| 中间插入/删除 | O(n)   | O(n)  | O(1) | O(1)         | -     | O(n)   |
| 查找          | O(n)   | O(n)  | O(n) | O(n)         | O(n)  | O(n)   |

> *注：vector和string的尾部操作在未扩容时为O(1)，扩容时为O(n)

### 内存使用对比
| **特性**     | vector | deque | list | forward_list | array | string |
| ------------ | ------ | ----- | ---- | ------------ | ----- | ------ |
| 额外内存开销 | 低     | 中    | 高   | 中           | 无    | 低     |
| 内存连续性   | 连续   | 分段  | 不   | 不           | 连续  | 连续   |
| 空间局部性   | 优     | 良    | 差   | 差           | 优    | 优     |
| 短序列优化   | 无     | 无    | 无   | 无           | -     | SSO    |

## 容器选择指南

### 根据需求选择容器
1. **需要随机访问** → `vector`, `deque`, `array`, `string`
2. **需要高效头部操作** → `deque`, `list`, `forward_list`
3. **需要高效任意位置插入** → `list`, `forward_list`
4. **内存敏感** → `vector`, `array`, `forward_list`
5. **需要稳定迭代器** → `list`, `forward_list`
6. **固定大小** → `array`
7. **文本处理** → `string`

### 性能优化技巧
1. **预分配内存**：
   ```cpp
   std::vector<int> vec;
   vec.reserve(1000); // 避免多次扩容
   ```

2. **使用emplace避免拷贝**：
   ```cpp
   std::vector<std::string> vec;
   vec.emplace_back("Hello"); // 直接构造，避免临时对象
   ```

3. **利用移动语义**：
   ```cpp
   std::string largeStr = getLargeString();
   vec.push_back(std::move(largeStr)); // 移动而非拷贝
   ```

4. **批量操作**：
   ```cpp
   std::vector<int> data;
   data.insert(data.end(), {1, 2, 3, 4, 5}); // 批量插入
   ```

## 通用操作接口

所有顺序容器支持以下操作：
```cpp
// 创建与初始化
std::vector<int> v1;                  // 空容器
std::vector<int> v2(10);              // 10个默认初始化元素
std::vector<int> v3(10, 42);          // 10个值为42的元素
std::vector<int> v4 = {1, 2, 3};      // 列表初始化
std::vector<int> v5(v4.begin(), v4.end()); // 范围初始化

// 大小操作
if (!v.empty()) { /* 非空 */ }        // 检查是否为空
size_t size = v.size();               // 元素数量
v.resize(20);                         // 调整大小

// 访问元素
int first = v.front();                // 第一个元素
int last = v.back();                  // 最后一个元素
int third = v[2];                     // 下标访问（无检查）
int safe = v.at(2);                   // 带边界检查访问

// 迭代器
for (auto it = v.begin(); it != v.end(); ++it) { /* 遍历 */ }
for (auto rit = v.rbegin(); rit != v.rend(); ++rit) { /* 反向遍历 */ }

// 修改容器
v.push_back(42);                      // 尾部添加
v.pop_back();                         // 尾部删除
auto it = v.insert(v.begin() + 2, 7); // 指定位置插入
it = v.erase(v.begin() + 1);          // 删除指定位置
v.clear();                            // 清空容器
```

## 特殊操作

### 1. 链表特有操作
```cpp
std::list<int> lst;
// 元素转移
lst.splice(lst.begin(), otherList); // 转移整个链表
lst.splice(it, otherList, otherIt); // 转移单个元素

// 链表排序
lst.sort(); // 成员函数，优于std::sort

// 链表合并
lst.merge(otherList); // 合并已排序链表

// 元素移除
lst.remove(42); // 删除所有值为42的元素
lst.remove_if([](int x) { return x % 2 == 0; }); // 删除偶数
```

### 2. 字符串特有操作
```cpp
std::string str = "Hello World";
// 子串操作
auto sub = str.substr(6, 5); // "World"

// 查找操作
size_t pos = str.find("World"); // 6
pos = str.find_first_of("aeiou"); // 1 ('e')

// 数值转换
int num = std::stoi("42");
double d = std::stod("3.14");
std::string numStr = std::to_string(42);

// 字符串修改
str.replace(6, 5, "C++"); // "Hello C++"
str.append("!!!");        // "Hello C++!!!"
```

## 迭代器失效规则

| **容器**          | **导致失效的操作**          | **安全操作**                   |
| ----------------- | --------------------------- | ------------------------------ |
| `vector`/`string` | 插入/删除（除尾部外）、扩容 | 尾部插入、只读访问             |
| `deque`           | 中间插入/删除、映射表重组   | 头尾操作（除非导致映射表重组） |
| `list`            | 删除当前元素                | 所有插入操作                   |
| `forward_list`    | 删除当前元素                | 所有插入操作                   |
| `array`           | 无                          | 所有操作                       |

## 最佳实践总结

1. **默认选择**：优先考虑`std::vector`，除非有特殊需求
2. **文本处理**：总是使用`std::string`而非`vector<char>`
3. **固定大小**：使用`std::array`替代原生数组
4. **双端操作**：需要高效头尾操作时选择`std::deque`
5. **高频插入**：频繁在任意位置插入/删除时使用`std::list`
6. **内存优化**：内存敏感场景考虑`std::forward_list`

## 性能敏感场景建议

1. **游戏开发**：
   - 实体存储 → `std::vector`（ECS架构）
   - 粒子系统 → `std::vector`（连续内存）
   - 事件队列 → `std::deque`

2. **金融系统**：
   - 实时数据流 → `std::deque`
   - 订单簿管理 → `std::vector`（预分配）
   - 交易历史 → `std::list`（稳定迭代器）

3. **嵌入式系统**：
   - 固定缓冲区 → `std::array`
   - 内存敏感列表 → `std::forward_list`
   - 只读数据 → `std::array`或`std::vector`（const）

4. **数据处理**：
   - 大规模数据集 → `std::vector`（连续内存）
   - 中间结果处理 → `std::deque`
   - 复杂结构操作 → `std::list`

通过理解不同顺序容器的特性和适用场景，您可以根据具体需求选择最合适的容器，从而编写出高效、可维护的 C++ 代码。