# C++ STL `std::stack` 详解

`std::stack` 是 C++ STL 中的**容器适配器**（container adapter），它提供了栈（LIFO - Last In First Out）数据结构的实现。栈是一种后进先出的数据结构，只允许在顶部进行插入和删除操作。

## 核心特性

1. **LIFO（后进先出）原则**：
   - 最后压入的元素最先弹出
   - 只能访问栈顶元素

2. **基于其他容器实现**：
   - 默认使用 `std::deque` 作为底层容器
   - 也可选择 `std::list` 或 `std::vector`

3. **有限的操作接口**：
   - 只提供栈相关的操作
   - 不支持迭代器或随机访问

4. **高效的操作**：
   - 所有操作时间复杂度 O(1)

## 基本操作

### 头文件与声明
```cpp
#include <stack>

// 默认使用 deque 作为底层容器
std::stack<int> stack1;

// 显式指定底层容器
std::stack<std::string, std::list<std::string>> stack2;
std::stack<double, std::vector<double>> stack3;
```

### 核心操作
| **操作**      | **描述**                 | **时间复杂度** |
| ------------- | ------------------------ | -------------- |
| `push(value)` | 将元素压入栈顶           | O(1)           |
| `pop()`       | 移除栈顶元素             | O(1)           |
| `top()`       | 访问栈顶元素（返回引用） | O(1)           |
| `empty()`     | 检查栈是否为空           | O(1)           |
| `size()`      | 返回栈中元素数量         | O(1)           |

## 内部实现原理

`std::stack` 是容器适配器，它封装了底层容器并限制其操作：

```cpp
template <class T, class Container = deque<T>>
class stack {
public:
    // 接口函数
    void push(const T& value) { c.push_back(value); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
    // ...
private:
    Container c; // 底层容器
};
```

### 底层容器要求
1. 必须支持 `push_back()` 和 `pop_back()`
2. 必须支持 `back()` 访问最后一个元素
3. 必须支持 `size()` 和 `empty()`

### 支持的底层容器
| **容器**      | **适用性** | **特点**                               |
| ------------- | ---------- | -------------------------------------- |
| `std::deque`  | ✅ 默认     | 平衡性好，两端操作高效                 |
| `std::list`   | ✅ 适用     | 所有操作 O(1)，内存不连续              |
| `std::vector` | ✅ 适用     | 内存连续，但 `pop_back()` 后不释放内存 |

## 使用示例

### 基本操作
```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;
    
    // 压入元素
    s.push(10);
    s.push(20);
    s.push(30);
    
    // 访问栈顶
    std::cout << "Top element: " << s.top() << std::endl; // 30
    
    // 弹出元素
    s.pop(); // 移除30
    std::cout << "Top after pop: " << s.top() << std::endl; // 20
    
    // 检查栈状态
    std::cout << "Size: " << s.size() << std::endl; // 2
    std::cout << "Empty? " << (s.empty() ? "Yes" : "No") << std::endl; // No
    
    // 遍历栈（通过弹出元素）
    while (!s.empty()) {
        std::cout << s.top() << " ";
        s.pop();
    }
    // 输出: 20 10
}
```

### 括号匹配算法
```cpp
bool isValidParentheses(const std::string& str) {
    std::stack<char> s;
    
    for (char c : str) {
        if (c == '(' || c == '[' || c == '{') {
            s.push(c);
        } else {
            if (s.empty()) return false;
            
            char top = s.top();
            s.pop();
            
            if ((c == ')' && top != '(') ||
                (c == ']' && top != '[') ||
                (c == '}' && top != '{')) {
                return false;
            }
        }
    }
    
    return s.empty();
}

// 测试
std::cout << isValidParentheses("({[]})"); // true
std::cout << isValidParentheses("({[}])"); // false
```

## 底层容器选择对比

| **特性**         | `std::deque`（默认） | `std::list`        | `std::vector`      |
| ---------------- | -------------------- | ------------------ | ------------------ |
| **内存连续性**   | ❌ 分块存储           | ❌ 节点离散         | ✅ 连续内存         |
| **扩容成本**     | 低（分配新块）       | 低（分配新节点）   | 高（重新分配复制） |
| **额外开销**     | 中（索引表开销）     | 高（每个元素指针） | 低                 |
| **pop_back()后** | 释放内存块           | 立即释放节点       | 不释放内存         |
| **推荐场景**     | 通用场景             | 频繁小规模操作     | 需要内存连续性     |

## 高级用法

### 自定义栈实现
```cpp
template <typename T>
class SafeStack {
private:
    std::stack<T> s;
    std::mutex mtx;
    
public:
    void push(const T& value) {
        std::lock_guard<std::mutex> lock(mtx);
        s.push(value);
    }
    
    bool try_pop(T& value) {
        std::lock_guard<std::mutex> lock(mtx);
        if (s.empty()) return false;
        value = s.top();
        s.pop();
        return true;
    }
    
    // 其他方法...
};
```

### 栈与递归转换
```cpp
// 递归实现的阶乘
int factorial_recursive(int n) {
    if (n == 0) return 1;
    return n * factorial_recursive(n - 1);
}

// 使用栈实现的阶乘
int factorial_stack(int n) {
    std::stack<int> s;
    while (n > 0) {
        s.push(n--);
    }
    
    int result = 1;
    while (!s.empty()) {
        result *= s.top();
        s.pop();
    }
    return result;
}
```

## 性能注意事项

1. **异常安全**：
   - `push()` 操作提供强异常保证（底层容器需支持）
   - `pop()` 不返回元素值，避免异常传播

2. **底层容器选择**：
   - 小规模数据：三种容器性能差异不大
   - 大规模数据：`std::deque` 通常是最佳选择
   - 内存敏感场景：考虑 `std::vector`

3. **访问限制**：
   - 只能访问栈顶元素
   - 如需访问其他元素，应选择其他容器

## 使用场景

1. **算法应用**：
   - 括号匹配检查
   - 表达式求值（后缀表达式）
   - 函数调用栈模拟
   - 回溯算法（如迷宫求解）

2. **系统设计**：
   - 撤销（Undo）操作管理
   - 浏览器历史记录
   - 递归函数转迭代实现

3. **数据处理**：
   - 数据反转（通过弹出顺序）
   - 深度优先搜索（DFS）
   - 语法解析

## 常见错误

1. **空栈操作**：
   ```cpp
   std::stack<int> s;
   s.pop();  // 未定义行为！
   int top = s.top();  // 未定义行为！
   ```

2. **错误使用迭代器**：
   ```cpp
   // 错误！stack 不提供迭代器
   for (auto it = s.begin(); it != s.end(); ++it) 
   ```

3. **误用底层容器**：
   ```cpp
   // 错误：forward_list 不支持 push_back/pop_back
   std::stack<int, std::forward_list<int>> invalid_stack;
   ```

## 最佳实践

1. **总是检查空栈**：
   ```cpp
   if (!stack.empty()) {
       auto value = stack.top();
       stack.pop();
       // 处理 value
   }
   ```

2. **使用 emplace 避免复制**：
   ```cpp
   std::stack<std::string> s;
   s.emplace("Hello, World!");  // 直接在栈上构造
   ```

3. **选择合适底层容器**：
   ```cpp
   // 需要频繁释放内存
   std::stack<int, std::list<int>> memory_sensitive_stack;
   
   // 需要内存连续性
   std::stack<char, std::vector<char>> contiguous_stack;
   ```

## 与其他容器的比较

| **特性**       | `std::stack`     | `std::queue`     | `std::deque` |
| -------------- | ---------------- | ---------------- | ------------ |
| **数据结构**   | LIFO（后进先出） | FIFO（先进先出） | 双端队列     |
| **插入位置**   | 仅顶部           | 仅尾部           | 两端         |
| **删除位置**   | 仅顶部           | 仅头部           | 两端         |
| **访问限制**   | 仅顶部元素       | 仅头部/尾部元素  | 任意元素     |
| **迭代器支持** | ❌ 不支持         | ❌ 不支持         | ✅ 支持       |

## 总结

`std::stack` 是 C++ STL 中实现栈数据结构的容器适配器：

**核心价值**：
- 提供简洁的 LIFO 操作接口
- 基于底层容器实现，灵活选择存储策略
- 所有操作时间复杂度 O(1)

**最佳实践**：
1. 默认使用 `std::deque` 作为底层容器
2. 操作前检查栈是否为空
3. 使用 `emplace` 替代 `push` 避免复制开销
4. 适用于算法问题（括号匹配、DFS）和系统设计（撤销操作）

**适用场景**：
- 需要后进先出语义的场合
- 算法中需要临时存储和回溯
- 需要限制数据访问顺序的应用

**替代方案**：
- 需要双端操作 → `std::deque`
- 需要随机访问 → `std::vector`
- 需要先进先出 → `std::queue`