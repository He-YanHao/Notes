# C++ STL 容器适配器详解

容器适配器是 C++ STL 中的一类特殊组件，它们**基于现有的顺序容器构建**，提供**特定数据结构接口**，同时**限制底层容器的功能**。容器适配器不是独立的容器，而是通过封装现有容器来实现特定的数据结构行为。

## 三大容器适配器概览

| **适配器**            | **数据结构** | **底层容器**     | **核心操作**                 | **典型应用场景**                    |
| --------------------- | ------------ | ---------------- | ---------------------------- | ----------------------------------- |
| `std::stack`          | LIFO（栈）   | `deque`（默认）  | `push()`, `pop()`, `top()`   | 函数调用栈、括号匹配、DFS           |
| `std::queue`          | FIFO（队列） | `deque`（默认）  | `push()`, `pop()`, `front()` | BFS、消息队列、缓冲系统             |
| `std::priority_queue` | 优先队列     | `vector`（默认） | `push()`, `pop()`, `top()`   | 任务调度、Dijkstra算法、Huffman编码 |

## 核心特性

1. **接口限制**：
   - 只暴露特定数据结构所需的操作
   - 隐藏底层容器的完整功能集

2. **底层容器依赖**：
   - 基于现有顺序容器实现
   - 可指定不同的底层容器

3. **无迭代器支持**：
   - 不能直接遍历元素
   - 只能通过特定接口访问元素

4. **高效操作**：
   - 所有操作时间复杂度 O(1)（优先队列插入/删除为 O(log n)）

## 底层容器要求对比

| **适配器**            | **必需操作**                                      | **支持容器**              | **默认容器** |
| --------------------- | ------------------------------------------------- | ------------------------- | ------------ |
| `std::stack`          | `push_back()`, `pop_back()`, `back()`             | `deque`, `list`, `vector` | `deque`      |
| `std::queue`          | `push_back()`, `pop_front()`, `front()`, `back()` | `deque`, `list`           | `deque`      |
| `std::priority_queue` | `push_back()`, `pop_back()`, `front()`            | `vector`, `deque`         | `vector`     |

> ⚠️ 注意：`queue` 不能使用 `vector` 作为底层容器，因为 `vector` 没有 `pop_front()` 操作

## 详细解析

### 1. `std::stack`（栈适配器）

**实现原理**：
```cpp
template <typename T, typename Container = deque<T>>
class stack {
protected:
    Container c; // 底层容器
public:
    void push(const T& value) { c.push_back(value); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
    // ...
};
```

**使用示例**：
```cpp
#include <stack>
#include <vector>

// 使用默认deque
std::stack<int> s1; 

// 指定vector作为底层容器
std::stack<int, std::vector<int>> s2; 

s1.push(10);
s1.push(20);
s1.push(30);

std::cout << s1.top(); // 30
s1.pop(); // 移除30
std::cout << s1.top(); // 20
```

### 2. `std::queue`（队列适配器）

**实现原理**：
```cpp
template <typename T, typename Container = deque<T>>
class queue {
protected:
    Container c; // 底层容器
public:
    void push(const T& value) { c.push_back(value); }
    void pop() { c.pop_front(); }
    T& front() { return c.front(); }
    T& back() { return c.back(); }
    // ...
};
```

**使用示例**：
```cpp
#include <queue>
#include <list>

// 使用list作为底层容器
std::queue<std::string, std::list<std::string>> q;

q.push("First");
q.push("Second");
q.push("Third");

std::cout << q.front(); // "First"
q.pop(); // 移除"First"
std::cout << q.front(); // "Second"
```

### 3. `std::priority_queue`（优先队列适配器）

**实现原理**：
- 基于最大堆（默认）数据结构
- 使用随机访问容器（通常为vector）存储元素
- 通过堆算法维护元素优先级

```cpp
template <typename T, 
          typename Container = vector<T>,
          typename Compare = less<typename Container::value_type>>
class priority_queue {
protected:
    Container c;       // 底层容器
    Compare comp;      // 比较函数对象
public:
    void push(const T& value) {
        c.push_back(value);
        std::push_heap(c.begin(), c.end(), comp);
    }
    
    void pop() {
        std::pop_heap(c.begin(), c.end(), comp);
        c.pop_back();
    }
    
    const T& top() const { return c.front(); }
    // ...
};
```

**使用示例**：
```cpp
#include <queue>
#include <functional> // 用于greater

// 默认最大堆
std::priority_queue<int> maxHeap;
maxHeap.push(30);
maxHeap.push(10);
maxHeap.push(50);
std::cout << maxHeap.top(); // 50

// 最小堆
std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
minHeap.push(30);
minHeap.push(10);
minHeap.push(50);
std::cout << minHeap.top(); // 10

// 自定义优先级
struct Task {
    int priority;
    std::string name;
    bool operator<(const Task& other) const {
        return priority < other.priority;
    }
};

std::priority_queue<Task> taskQueue;
taskQueue.push({3, "Low priority"});
taskQueue.push({9, "High priority"});
std::cout << taskQueue.top().name; // "High priority"
```

## 容器适配器 vs 独立容器

| **特性**       | 容器适配器           | 独立容器（vector/list等） |
| -------------- | -------------------- | ------------------------- |
| **实现方式**   | 基于现有容器封装     | 独立实现数据结构          |
| **接口**       | 受限，仅暴露特定操作 | 完整容器接口              |
| **迭代器支持** | ❌ 无                 | ✅ 有                      |
| **内存管理**   | 依赖底层容器         | 自主管理                  |
| **灵活性**     | 较低，特定数据结构   | 较高，多功能操作          |
| **性能**       | 与底层容器相同       | 取决于具体实现            |

## 高级用法与技巧

### 1. 自定义底层容器
```cpp
// 使用list作为stack底层容器
std::stack<int, std::list<int>> customStack;

// 使用deque作为priority_queue底层容器
std::priority_queue<int, std::deque<int>> customPQ;
```

### 2. 透明比较器（C++14）
```cpp
// 避免创建临时对象
std::priority_queue<std::string, 
                    std::vector<std::string>,
                    std::greater<>> minHeapTransparent;
minHeapTransparent.push("Apple");
minHeapTransparent.push("Banana");
// 直接使用字符串字面量比较
auto it = minHeapTransparent.find("Apple"); 
```

### 3. 自定义比较函数
```cpp
// 使用lambda自定义比较规则
auto cmp = [](const Person& a, const Person& b) {
    return a.age > b.age; // 年龄小的优先级高
};

std::priority_queue<Person, 
                    std::vector<Person>,
                    decltype(cmp)> ageQueue(cmp);
```

### 4. 适配器组合
```cpp
// 使用栈实现队列
template <typename T>
class QueueFromStacks {
private:
    std::stack<T> input, output;
public:
    void push(T value) {
        input.push(value);
    }
    
    void pop() {
        if (output.empty()) {
            while (!input.empty()) {
                output.push(input.top());
                input.pop();
            }
        }
        output.pop();
    }
    
    T& front() {
        if (output.empty()) {
            while (!input.empty()) {
                output.push(input.top());
                input.pop();
            }
        }
        return output.top();
    }
};
```

## 性能注意事项

1. **`priority_queue` 的堆操作**：
   - `push()`：O(log n)（堆插入）
   - `pop()`：O(log n)（堆删除）
   - `top()`：O(1)

2. **底层容器影响**：
   - `stack` 使用 `vector`：尾部操作高效，但扩容可能影响性能
   - `queue` 使用 `list`：频繁小规模操作更优
   - `priority_queue` 使用 `deque`：减少内存重新分配

3. **内存局部性**：
   - `vector` 提供最佳缓存友好性
   - `list` 内存分散，缓存效率低

## 使用场景指南

| **场景**                 | **推荐适配器**   | **原因**                 |
| ------------------------ | ---------------- | ------------------------ |
| 函数调用栈               | `stack`          | LIFO 特性匹配            |
| BFS算法                  | `queue`          | FIFO 特性匹配            |
| 任务调度系统             | `priority_queue` | 按优先级处理任务         |
| 语法解析（括号匹配）     | `stack`          | 需要回溯最近元素         |
| 消息队列系统             | `queue`          | 先进先出处理消息         |
| 实时数据处理             | `priority_queue` | 按重要性处理数据         |
| 缓存系统（LRU实现）      | `list` + 适配器  | 需要高效插入删除         |
| 表达式求值（后缀表达式） | `stack`          | 操作数和运算符的临时存储 |

## 最佳实践

1. **默认容器选择**：
   - `stack`：默认 `deque`（平衡性好）
   - `queue`：默认 `deque`（高效双端操作）
   - `priority_queue`：默认 `vector`（缓存友好）

2. **元素访问安全**：
   ```cpp
   // 总是检查空状态
   if (!myStack.empty()) {
       auto value = myStack.top();
       myStack.pop();
   }
   ```

3. **使用 emplace 避免拷贝**：
   ```cpp
   std::stack<std::pair<int, std::string>> s;
   s.emplace(42, "Answer"); // 直接构造，避免临时对象
   ```

4. **自定义类型支持**：
   ```cpp
   // priority_queue需要比较运算符
   struct Point {
       int x, y;
       bool operator<(const Point& p) const {
           return x*x + y*y < p.x*p.x + p.y*p.y; // 距原点距离
       }
   };
   
   std::priority_queue<Point> points;
   ```

## 常见错误

1. **空适配器操作**：
   ```cpp
   std::stack<int> s;
   s.pop(); // 未定义行为
   ```

2. **错误底层容器**：
   ```cpp
   // 错误：vector不支持pop_front
   std::queue<int, std::vector<int>> invalidQueue;
   ```

3. **迭代器误用**：
   ```cpp
   std::queue<int> q;
   // 错误：queue没有begin()
   for (auto it = q.begin(); it != q.end(); ++it)
   ```

4. **优先级队列比较方向**：
   ```cpp
   // 注意：默认是最大堆，使用less
   // 若要最小堆，需使用greater
   std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
   ```

## 总结

容器适配器是 STL 中实现特定数据结构的强大工具：

1. **核心价值**：
   - 提供标准化的栈、队列、优先队列实现
   - 基于现有容器，减少重复实现
   - 简化特定数据结构的接口

2. **选择指南**：
   - 后进先出 → `stack`
   - 先进先出 → `queue`
   - 优先级处理 → `priority_queue`

3. **性能优化**：
   - 根据场景选择底层容器
   - 使用 `emplace` 避免拷贝
   - 为 `priority_queue` 提供高效比较器

4. **适用场景**：
   - 算法实现（DFS/BFS）
   - 系统设计（任务调度/消息队列）
   - 数据处理（优先级处理）

容器适配器通过限制接口提供特定语义，使代码更清晰、更安全，是 C++ 程序员工具箱中不可或缺的组成部分。