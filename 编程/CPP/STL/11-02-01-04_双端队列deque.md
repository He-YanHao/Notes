`std::deque`（双端队列，Double-Ended Queue）是 C++ STL 中一种重要的**顺序容器**，它结合了 `std::vector` 和 `std::list` 的优势，支持在**头部和尾部高效插入/删除元素**，同时提供随机访问能力。

---

### **核心特性**
1. **双端操作高效**  
   - 在头部 (`push_front()`, `pop_front()`) 和尾部 (`push_back()`, `pop_front()`) 插入/删除元素的时间复杂度为 **O(1)**。
   - 优于 `std::vector`（头部操作 O(n)），但略慢于 `std::list`（任意位置 O(1)）。

2. **随机访问支持**  
   - 通过 `operator[]` 或 `at()` 访问元素的时间复杂度为 **O(1)**（类似 `std::vector`）。
   - 优于 `std::list`（随机访问 O(n)）。

3. **非连续内存布局**  
   - 由多个固定大小的内存块（称为 "chunks" 或 "blocks"）组成，通过中央映射表（索引数组）管理。
   - 内存动态扩展时只需分配新块，无需整体复制（避免 `std::vector` 的扩容代价）。

---

### **内部实现原理**
```plaintext
  ┌─────┬─────┬─────┐      ┌───────────┐
  │ Chunk1 │ Chunk2 │ ...  │  Map Table│
  ├─────┼─────┼─────┤      └───────────┘
  │ [0,1]│ [4,5]│     │         │
  │ [2,3]│ [6,7]│     │◀───索引指针数组
  └─────┴─────┴─────┘
```
- **分块存储**：元素分布在多个等大小的内存块中。
- **映射表（Map Table）**：一个动态数组，存储指向每个内存块的指针。
- **扩容策略**：当两端空间不足时，分配新块并更新映射表（复杂度 O(1)）。

---

### **关键操作复杂度**
| **操作**                   | **时间复杂度** | **说明**                           |
| -------------------------- | -------------- | ---------------------------------- |
| `push_front()/pop_front()` | O(1)           | 头部操作                           |
| `push_back()/pop_back()`   | O(1)           | 尾部操作                           |
| `operator[]`, `at()`       | O(1)           | 随机访问                           |
| 中间插入/删除 (`insert()`) | O(n)           | 需移动元素（性能低于 `std::list`） |
| 迭代器递增/递减            | O(1)           | 支持随机访问迭代器                 |

---

### **与 Vector/List 的对比**
| **特性**       | `std::deque`          | `std::vector`     | `std::list`    |
| -------------- | --------------------- | ----------------- | -------------- |
| **头部插入**   | ✅ **O(1)**            | ❌ O(n)            | ✅ **O(1)**     |
| **尾部插入**   | ✅ **O(1)**            | ✅ **O(1)** (均摊) | ✅ **O(1)**     |
| **中间插入**   | ❌ O(n)                | ❌ O(n)            | ✅ **O(1)**     |
| **随机访问**   | ✅ **O(1)**            | ✅ **O(1)**        | ❌ O(n)         |
| **内存连续性** | ❌ 分块存储            | ✅ 连续存储        | ❌ 节点离散存储 |
| **迭代器失效** | 部分操作失效 (见下表) | 多数操作失效      | 仅删除元素失效 |

---

### **迭代器失效规则**
| **操作**                       | **失效情况**                     |
| ------------------------------ | -------------------------------- |
| `push_front()/push_back()`     | **不失效**（除非映射表重建）     |
| `pop_front()/pop_back()`       | 仅指向被删元素的迭代器失效       |
| `insert()` 在中间              | **所有迭代器失效**（需移动元素） |
| `resize()` / `shrink_to_fit()` | **可能失效**（映射表重组）       |

> 📌 注意：`std::deque` 的迭代器是 **随机访问迭代器**（与 `std::vector` 同级别）。

---

### **适用场景**
1. **需要高效双端操作的队列**  
   - 任务调度系统、滑动窗口算法。
2. **随机访问 + 动态扩展**  
   - 替代 `std::vector` 当频繁在头部插入时（如实时数据流）。
3. **避免 vector 扩容成本**  
   - 存储超大型数据集（分块分配减少内存压力）。

---

### **代码示例**
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> dq = {2, 3, 4};

    // 头部插入
    dq.push_front(1);      // dq: [1, 2, 3, 4]
    dq.push_back(5);       // dq: [1, 2, 3, 4, 5]

    // 随机访问
    std::cout << dq[2];    // 输出: 3

    // 删除头部和尾部
    dq.pop_front();        // dq: [2, 3, 4, 5]
    dq.pop_back();         // dq: [2, 3, 4]

    // 中间插入（代价较高）
    dq.insert(dq.begin() + 1, 99);  // dq: [2, 99, 3, 4]

    // 遍历
    for (auto it = dq.begin(); it != dq.end(); ++it) {
        std::cout << *it << " ";  // 输出: 2 99 3 4
    }
}
```

---

### **性能注意事项**
1. **中间操作性能差**  
   避免在 `deque` 中间频繁插入/删除（优先选 `std::list`）。
2. **内存局部性较差**  
   分块存储导致遍历速度略慢于 `std::vector`（CPU 缓存不友好）。
3. **没有 `capacity()` 概念**  
   无法预留内存（但可通过构造参数指定块大小）。

---

### **总结**
`std::deque` 是以下场景的理想选择：
- **高频双端操作** + **随机访问**需求  
- 避免 `std::vector` 扩容成本  
- 无法接受 `std::list` 的 O(n) 随机访问  

在需要中间插入时，优先考虑 `std::list`；需要极致遍历性能时，选择 `std::vector`。