# C++ STL `std::queue` 详解

`std::queue` 是 C++ STL 中的**容器适配器**（container adapter），它提供了队列（FIFO - First In First Out）数据结构的实现。队列是一种先进先出的数据结构，只允许在尾部添加元素，在头部移除元素。

## 核心特性

1. **FIFO（先进先出）原则**：
   - 最先插入的元素最先被移除
   - 只允许在尾部添加元素（入队）
   - 只允许在头部移除元素（出队）

2. **基于其他容器实现**：
   - 默认使用 `std::deque` 作为底层容器
   - 也可选择 `std::list`

3. **有限的操作接口**：
   - 只提供队列相关的操作
   - 不支持迭代器或随机访问

4. **高效的操作**：
   - 所有操作时间复杂度 O(1)

## 基本操作

### 头文件与声明
```cpp
#include <queue>

// 默认使用 deque 作为底层容器
std::queue<int> q1;

// 显式指定底层容器
std::queue<std::string, std::list<std::string>> q2;
```

### 核心操作
| **操作**      | **描述**                     | **时间复杂度** |
| ------------- | ---------------------------- | -------------- |
| `push(value)` | 在队列尾部添加元素           | O(1)           |
| `pop()`       | 移除队列头部元素             | O(1)           |
| `front()`     | 访问队列头部元素（返回引用） | O(1)           |
| `back()`      | 访问队列尾部元素（返回引用） | O(1)           |
| `empty()`     | 检查队列是否为空             | O(1)           |
| `size()`      | 返回队列中元素数量           | O(1)           |

## 内部实现原理

`std::queue` 是容器适配器，它封装了底层容器并限制其操作：

```cpp
template <class T, class Container = deque<T>>
class queue {
public:
    // 接口函数
    void push(const T& value) { c.push_back(value); }
    void pop() { c.pop_front(); }
    T& front() { return c.front(); }
    T& back() { return c.back(); }
    // ...
private:
    Container c; // 底层容器
};
```

### 底层容器要求
1. 必须支持 `push_back()` 和 `pop_front()`
2. 必须支持 `front()` 和 `back()` 访问元素
3. 必须支持 `size()` 和 `empty()`

### 支持的底层容器
| **容器**      | **适用性** | **特点**                  |
| ------------- | ---------- | ------------------------- |
| `std::deque`  | ✅ 默认     | 平衡性好，两端操作高效    |
| `std::list`   | ✅ 适用     | 所有操作 O(1)，内存不连续 |
| `std::vector` | ❌ 不适用   | 不支持高效的 pop_front()  |

## 使用示例

### 基本操作
```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<std::string> q;
    
    // 入队操作
    q.push("Alice");
    q.push("Bob");
    q.push("Charlie");
    
    // 访问队首和队尾
    std::cout << "Front: " << q.front() << std::endl; // Alice
    std::cout << "Back: " << q.back() << std::endl;   // Charlie
    
    // 出队操作
    q.pop(); // 移除Alice
    std::cout << "Front after pop: " << q.front() << std::endl; // Bob
    
    // 检查队列状态
    std::cout << "Size: " << q.size() << std::endl; // 2
    std::cout << "Empty? " << (q.empty() ? "Yes" : "No") << std::endl; // No
    
    // 遍历队列（通过出队）
    while (!q.empty()) {
        std::cout << q.front() << " ";
        q.pop();
    }
    // 输出: Bob Charlie
}
```

### 广度优先搜索（BFS）示例
```cpp
#include <iostream>
#include <queue>
#include <vector>

void BFS(const std::vector<std::vector<int>>& graph, int start) {
    std::vector<bool> visited(graph.size(), false);
    std::queue<int> q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int current = q.front();
        q.pop();
        std::cout << "Visited: " << current << std::endl;
        
        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    // 图结构：邻接表
    std::vector<std::vector<int>> graph = {
        {1, 2},    // 节点0的邻居
        {0, 3, 4}, // 节点1的邻居
        {0, 5},    // 节点2的邻居
        {1},       // 节点3的邻居
        {1},       // 节点4的邻居
        {2}        // 节点5的邻居
    };
    
    BFS(graph, 0);
}
```

## 底层容器选择对比

| **特性**        | `std::deque`（默认） | `std::list`        |
| --------------- | -------------------- | ------------------ |
| **内存连续性**  | ❌ 分块存储           | ❌ 节点离散         |
| **扩容成本**    | 低（分配新块）       | 低（分配新节点）   |
| **额外开销**    | 中（索引表开销）     | 高（每个元素指针） |
| **pop_front()** | O(1)                 | O(1)               |
| **推荐场景**    | 通用场景             | 频繁小规模操作     |

## 高级用法

### 线程安全队列
```cpp
#include <queue>
#include <mutex>
#include <condition_variable>

template <typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    mutable std::mutex mtx;
    std::condition_variable cv;
    
public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mtx);
        queue.push(std::move(value));
        cv.notify_one();
    }
    
    bool try_pop(T& value) {
        std::lock_guard<std::mutex> lock(mtx);
        if (queue.empty()) return false;
        value = std::move(queue.front());
        queue.pop();
        return true;
    }
    
    void wait_and_pop(T& value) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this]{ return !queue.empty(); });
        value = std::move(queue.front());
        queue.pop();
    }
    
    bool empty() const {
        std::lock_guard<std::mutex> lock(mtx);
        return queue.empty();
    }
};
```

### 优先级队列模拟
```cpp
#include <queue>
#include <iostream>

// 使用priority_queue模拟带优先级的队列
struct Task {
    int priority;
    std::string description;
    
    // 重载<运算符用于优先级比较
    bool operator<(const Task& other) const {
        return priority < other.priority; // 值越大优先级越高
    }
};

int main() {
    std::priority_queue<Task> taskQueue;
    
    taskQueue.push({3, "Fix critical bug"});
    taskQueue.push({1, "Write documentation"});
    taskQueue.push({5, "Server down emergency"});
    
    while (!taskQueue.empty()) {
        Task task = taskQueue.top();
        taskQueue.pop();
        std::cout << "Processing: " << task.description 
                  << " (Priority: " << task.priority << ")\n";
    }
    // 输出:
    // Processing: Server down emergency (Priority: 5)
    // Processing: Fix critical bug (Priority: 3)
    // Processing: Write documentation (Priority: 1)
}
```

## 性能注意事项

1. **异常安全**：
   - `push()` 操作提供强异常保证（底层容器需支持）
   - `pop()` 不返回元素值，避免异常传播

2. **底层容器选择**：
   - 默认 `std::deque` 在大多数情况下性能最佳
   - `std::list` 在元素较大时可能更优（避免内存碎片）

3. **访问限制**：
   - 只能访问队头和队尾元素
   - 如需访问中间元素，应选择其他容器

## 使用场景

1. **算法应用**：
   - 广度优先搜索（BFS）
   - 缓冲区和管道处理
   - 任务调度系统

2. **系统设计**：
   - 消息队列系统
   - 请求处理队列
   - 打印任务管理

3. **数据处理**：
   - 数据流处理
   - 事件驱动系统
   - 生产者-消费者模式

## 常见错误

1. **空队列操作**：
   ```cpp
   std::queue<int> q;
   q.pop();       // 未定义行为！
   int front = q.front(); // 未定义行为！
   ```

2. **错误使用迭代器**：
   ```cpp
   // 错误！queue 不提供迭代器
   for (auto it = q.begin(); it != q.end(); ++it) 
   ```

3. **误用底层容器**：
   ```cpp
   // 错误：vector 不支持 pop_front()
   std::queue<int, std::vector<int>> invalid_queue;
   ```

## 最佳实践

1. **总是检查空队列**：
   ```cpp
   if (!q.empty()) {
       auto value = q.front();
       q.pop();
       // 处理 value
   }
   ```

2. **使用 emplace 避免复制**：
   ```cpp
   std::queue<std::string> q;
   q.emplace("Hello, World!");  // 直接在队列中构造
   ```

3. **选择合适底层容器**：
   ```cpp
   // 元素较大时使用 list
   struct LargeData { /* ... */ };
   std::queue<LargeData, std::list<LargeData>> large_queue;
   ```

## 与其他容器的比较

| **特性**       | `std::queue`     | `std::stack`     | `std::deque` |
| -------------- | ---------------- | ---------------- | ------------ |
| **数据结构**   | FIFO（先进先出） | LIFO（后进先出） | 双端队列     |
| **插入位置**   | 仅尾部           | 仅顶部           | 两端         |
| **删除位置**   | 仅头部           | 仅顶部           | 两端         |
| **访问位置**   | 头部和尾部       | 仅顶部           | 任意元素     |
| **迭代器支持** | ❌ 不支持         | ❌ 不支持         | ✅ 支持       |

## 总结

`std::queue` 是 C++ STL 中实现队列数据结构的容器适配器：

**核心价值**：
- 提供简洁的 FIFO 操作接口
- 基于底层容器实现，灵活选择存储策略
- 所有操作时间复杂度 O(1)

**最佳实践**：
1. 默认使用 `std::deque` 作为底层容器
2. 操作前检查队列是否为空
3. 使用 `emplace` 替代 `push` 避免复制开销
4. 适用于算法问题（BFS）和系统设计（消息队列）

**适用场景**：
- 需要先进先出语义的场合
- 算法中需要按顺序处理元素
- 消息传递和任务调度系统

**替代方案**：
- 需要双端操作 → `std::deque`
- 需要随机访问 → `std::vector`
- 需要后进先出 → `std::stack`