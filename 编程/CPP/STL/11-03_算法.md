# STL 算法

好的，我们来深入探讨 C++ STL 算法的精髓。STL 算法是标准模板库中最强大、最实用的部分之一，它们提供了一套**泛型、高效**的预定义操作，用于处理序列（通常由迭代器定义的范围）中的元素。

**核心思想：**

1.  **泛型性：** 算法通过**迭代器**操作数据，不依赖于具体的容器类型。只要容器提供了满足算法要求的迭代器（输入、前向、双向、随机访问），算法就能工作。
2.  **数据与操作分离：** 算法专注于“做什么”（排序、查找、修改等），而容器专注于“如何存储数据”。迭代器是连接两者的桥梁。
3.  **效率：** 大多数 STL 算法都经过精心设计和优化，具有最优或接近最优的时间复杂度（如 O(n), O(n log n), O(1) 等）。

**关键头文件：** `<algorithm>` (绝大多数算法), `<numeric>` (数值计算算法), `<functional>` (函数对象/谓词)。

**STL 算法的主要分类：**

以下是按照常见功能对算法进行的分类，并列举代表性算法：

1.  **非修改序列操作 (Non-modifying Sequence Operations):**
    *   只读取序列中的元素，**不修改**元素的值或顺序。
    *   **常用算法：**
        *   `all_of`, `any_of`, `none_of` (C++11)：检查范围中是否所有/任一/无元素满足谓词。
        *   `for_each`：对范围中的每个元素应用一个函数（常被 C++11 范围 for 循环替代，但仍有其用途）。
        *   `count`, `count_if`：计算等于特定值或满足谓词的元素个数。
        *   `find`, `find_if`, `find_if_not` (C++11)：查找第一个等于特定值或满足（或不满足）谓词的元素。
        *   `find_first_of`：在第一个范围中查找与第二个范围中任一元素相等的第一个元素。
        *   `adjacent_find`：查找第一对相邻且相等（或满足二元谓词）的元素。
        *   `search`：在序列 A 中查找序列 B 第一次出现的位置（子序列匹配）。
        *   `search_n`：查找连续 n 个等于特定值或满足谓词的元素。
        *   `mismatch`：比较两个序列，返回第一对不相等的元素的位置。
        *   `equal`：判断两个序列是否相等（或在二元谓词意义下等价）。
        *   `is_sorted` (C++11)：检查序列是否已排序。
        *   `is_sorted_until` (C++11)：查找序列中第一个破坏有序性的元素。
        *   `is_heap`, `is_heap_until` (C++11)：检查序列是否为堆/查找第一个破坏堆结构的元素。

2.  **修改序列操作 (Modifying Sequence Operations):**
    *   会**修改**序列中元素的值或顺序。
    *   **常用算法：**
        *   `copy`, `copy_if` (C++11), `copy_n` (C++11)：复制元素到另一个位置（`copy_if` 带条件）。
        *   `copy_backward`：从后向前复制（用于处理重叠区域）。
        *   `move` (C++11), `move_backward` (C++11)：移动元素（转移所有权，源元素状态有效但未指定）。
        *   `swap_ranges`：交换两个范围中的元素。
        *   `transform`：对范围中的每个元素应用一元或二元操作，并将结果（可能转换类型）输出到目标位置。
        *   `replace`, `replace_if`：将等于特定值或满足谓词的元素替换为新值。
        *   `replace_copy`, `replace_copy_if`：复制序列，同时替换满足条件的元素值。
        *   `fill`, `fill_n`：将范围中的所有元素或前 n 个元素设置为特定值。
        *   `generate`, `generate_n`：用生成器函数的结果填充范围。
        *   `remove`, `remove_if`：**移除**等于特定值或满足谓词的元素（注意：不是物理删除，而是将不满足条件的元素移动到前面，返回新的逻辑结尾迭代器。通常配合 `erase` 使用：`v.erase(remove_if(...), v.end())`。这就是著名的 **"Erase-Remove" 惯用法**）。
        *   `remove_copy`, `remove_copy_if`：复制序列，同时忽略（不复制）满足条件的元素。
        *   `unique`：**移除**连续重复的元素（只保留每组重复元素的第一个）。通常也需要配合 `erase` (`v.erase(unique(...), v.end())`)。
        *   `unique_copy`：复制序列，跳过连续重复的元素。
        *   `reverse`：反转序列中元素的顺序。
        *   `reverse_copy`：将序列反转后复制到目标位置。
        *   `rotate`：循环移动序列中的元素（例如，将 `[A, B, C, D, E]` 旋转，使 `C` 成为第一个元素，得到 `[C, D, E, A, B]`）。
        *   `rotate_copy`：旋转序列并将结果复制到目标位置。
        *   `shuffle` (C++11)：使用随机数生成器随机重排序列中的元素（替代已弃用的 `random_shuffle`）。
        *   `sample` (C++17)：从序列中随机抽取 n 个元素（无放回抽样）。

3.  **排序及相关操作 (Sorting and Related Operations):**
    *   这些算法通常需要随机访问迭代器（如 `vector`, `deque`, `array` 的迭代器）。
    *   **常用算法：**
        *   `sort`：对范围进行**不稳定**排序（通常基于快速排序的混合实现，平均 O(n log n)，最坏 O(n²)）。
        *   `stable_sort`：对范围进行**稳定**排序（相等元素的相对顺序保持不变，通常基于归并排序，O(n log n) 或 O(n log² n)）。
        *   `partial_sort`：部分排序，使前 n 个元素是整个范围内最小的 n 个元素并按序排列，后面元素无序。
        *   `partial_sort_copy`：部分排序并将结果复制到目标范围。
        *   `nth_element`：部分排序，使得第 n 个位置的元素处于其最终排序后应在的位置，其前面的元素都不大于它，后面的元素都不小于它（不保证前后部分内部有序）。
        *   `is_sorted` (C++11)：检查范围是否已排序。
        *   `is_sorted_until` (C++11)：查找范围中第一个破坏有序性的元素。
        *   **二分搜索操作 (在已排序范围上使用，效率 O(log n))：**
            *   `lower_bound`：查找第一个**不小于**给定值的元素位置。
            *   `upper_bound`：查找第一个**大于**给定值的元素位置。
            *   `equal_range`：返回一个迭代器对 `[lower_bound, upper_bound)`，表示等于给定值的子范围。
            *   `binary_search`：检查范围中是否存在等于给定值的元素（返回 bool）。
        *   **合并操作 (操作已排序序列)：**
            *   `merge`：合并两个已排序序列到一个新的有序序列。
            *   `inplace_merge`：原地合并同一个序列中两个连续的有序子序列。

4.  **堆操作 (Heap Operations):**
    *   堆是一种特殊的二叉树结构（通常是最大堆），`priority_queue` 适配器底层使用堆。
    *   **常用算法：**
        *   `make_heap`：将随机访问迭代器范围转换为一个堆。
        *   `push_heap`：假设范围 `[first, last-1)` 是一个堆，将 `*(last-1)` 元素加入堆中，使 `[first, last)` 成为堆。
        *   `pop_heap`：假设范围 `[first, last)` 是一个堆，将最大元素（堆顶，即 `*first`）移动到 `*(last-1)`，并将 `[first, last-1)` 重新调整为堆。
        *   `sort_heap`：将一个堆转换为有序序列（升序）。
        *   `is_heap` (C++11)：检查范围是否为堆。
        *   `is_heap_until` (C++11)：查找范围中第一个破坏堆结构的元素。

5.  **最小/最大操作 (Min/Max Operations):**
    *   **常用算法：**
        *   `min`, `max`：返回两个值中的较小者/较大者。
        *   `minmax` (C++11)：返回两个值中的较小者和较大者（一个 `pair`）。
        *   `min_element`, `max_element`：返回范围中最小/最大元素的位置。
        *   `minmax_element` (C++11)：返回范围中最小元素和最大元素的位置（一个 `pair`）。
        *   `clamp` (C++17)：将值夹在给定的下限和上限之间 `clamp(v, lo, hi)` -> 如果 `v < lo` 返回 `lo`；如果 `v > hi` 返回 `hi`；否则返回 `v`）。

6.  **数值操作 (Numeric Operations) - 主要在 `<numeric>` 中：**
    *   这些算法通常也遍历序列。
    *   **常用算法：**
        *   `iota` (C++11)：用连续递增的值填充序列（`v[0]=start, v[1]=start+1, ...`）。
        *   `accumulate`：计算序列元素的累积总和（或应用二元操作符的累积结果，如累乘）。`accumulate(v.begin(), v.end(), init, op)`。
        *   `inner_product`：计算两个序列的内积（点积）或应用自定义操作模拟内积。
        *   `adjacent_difference`：计算序列中相邻元素的差（或应用二元操作符的结果），并将结果存储到另一个序列。
        *   `partial_sum`：计算序列元素的部分和（或应用二元操作符的累积结果），并将结果存储到另一个序列。`result[i] = v[0] + v[1] + ... + v[i]`。
        *   `reduce` (C++17)：类似 `accumulate`，但允许并行和无序计算（可能更快）。
        *   `transform_reduce` (C++17)：结合 `transform` 和 `reduce`，先变换元素再归约，允许并行。

**使用 STL 算法的关键要素：**

1.  **迭代器范围：** 几乎所有算法都作用于由两个迭代器定义的半开区间 `[first, last)`。
2.  **谓词 (Predicates)：**
    *   返回 `bool` 值的可调用对象（函数、函数指针、函数对象、Lambda 表达式）。
    *   用于指定条件（如 `find_if`, `count_if`, `remove_if`）或比较规则（如 `sort`）。
    *   **一元谓词 (Unary Predicate):** 接受一个参数（元素值）。
    *   **二元谓词 (Binary Predicate):** 接受两个参数（通常用于比较两个元素）。
3.  **函数对象 (Functors) / Lambda 表达式：**
    *   用于定制算法的行为（操作逻辑、比较规则）。
    *   Lambda 表达式 (C++11) 是在算法调用点定义匿名函数的简洁方式，极大地提高了代码可读性和便利性。例如：
        ```cpp
        std::sort(v.begin(), v.end(), [](const Person& a, const Person& b) {
            return a.age < b.age; // 按年龄升序排序
        });
        ```
4.  **输出迭代器：** 一些算法（如 `copy`, `transform`, `remove_copy`）需要一个输出迭代器来指定结果存储的位置（如 `back_inserter(v)` 用于在容器 `v` 尾部插入）。

**重要特性与技巧：**

*   **算法复杂性：** 每个算法都有标准规定的复杂度保证（如线性 O(n)、对数 O(log n)、线性对数 O(n log n) 等）。了解这些对性能至关重要。
*   **稳定性：** 排序算法中，“稳定”意味着相等元素的相对顺序在排序后保持不变 (`stable_sort` 是稳定的，`sort` 通常不稳定)。
*   **原地操作 vs. 复制操作：** 许多算法有“原地”版本（如 `sort`, `remove`, `replace`）和“复制”版本（如 `sort_copy`, `remove_copy`, `replace_copy`）。后者不修改原序列，而是将结果输出到新位置。
*   **"Erase-Remove" 惯用法：** 用于真正删除容器中满足条件的元素。
    ```cpp
    std::vector<int> v = {1, 2, 3, 2, 4, 2, 5};
    // 移除所有值为2的元素
    v.erase(std::remove(v.begin(), v.end(), 2), v.end());
    // 或者使用 remove_if
    v.erase(std::remove_if(v.begin(), v.end(), [](int i){ return i % 2 == 0; }), v.end()); // 移除所有偶数
    ```
*   **使用 Lambda 表达式：** 这是现代 C++ 中使用 STL 算法最自然、最强大的方式，避免了单独定义命名函数或函数对象的麻烦。

**总结：**

STL 算法是 C++ 高效编程的利器。它们提供了一套标准化、类型安全、高效且泛型的操作，涵盖了从简单的遍历、查找、计数到复杂的排序、堆操作、数值计算等广泛需求。掌握：

1.  **算法的分类和常用代表。**
2.  **迭代器范围的概念。**
3.  **谓词和函数对象（尤其是 Lambda 表达式）的使用。**
4.  **关键惯用法（如 Erase-Remove）。**

将极大地提升你的 C++ 代码质量（简洁性、可读性、可维护性）和性能。遇到数据处理任务时，养成优先思考“是否有合适的 STL 算法？”的习惯，往往能事半功倍。