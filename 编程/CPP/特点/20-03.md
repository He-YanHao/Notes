## constexpr if (C++17)

### 基本概念
编译期条件判断语句，允许在模板实例化过程中进行分支选择。

### 核心优势
- 简化模板代码
- 消除SFINAE的复杂性
- 提高编译效率

### 基本用法
```cpp
template<typename T>
auto process(T value) {
    if constexpr (std::is_integral_v<T>) {
        return value * 2;
    } else if constexpr (std::is_floating_point_v<T>) {
        return value / 2;
    } else {
        static_assert(false, "Unsupported type");
    }
}
```

### 与传统元编程对比
```cpp
// C++11/14方式（使用SFINAE）
template<typename T>
std::enable_if_t<std::is_integral_v<T>, void> process(T) { /*...*/ }

// C++17方式（更简洁）
template<typename T>
void process(T) {
    if constexpr (std::is_integral_v<T>) { /*...*/ }
}
```

## 3. 类型萃取 (Type Traits)

### 基本概念
类型萃取是编译期类型检查与操作的模板工具集，定义在 `<type_traits>` 头文件中。

### 主要分类

#### 类型检查
```cpp
std::is_integral_v<int>;      // true
std::is_class_v<std::string>; // true
std::is_pointer_v<int*>;      // true
```

#### 类型转换
```cpp
std::remove_pointer_t<int*>;   // int
std::add_const_t<int>;         // const int
std::decay_t<int[5]>;          // int*
```

#### 类型关系
```cpp
std::is_same_v<int, int>;     // true
std::is_base_of_v<Base, Derived>; // 继承关系检查
```

### 实际应用示例

#### 安全类型转换
```cpp
template<typename To, typename From>
To safe_cast(From from) {
    static_assert(std::is_convertible_v<From, To>,
                 "Types are not convertible");
    return static_cast<To>(from);
}
```

#### 条件类型选择
```cpp
template<bool B, typename T, typename F>
using conditional_t = std::conditional_t<B, T, F>;

using Type = conditional_t<sizeof(int)==4, int32_t, int64_t>;
```

## 三者的协同应用

### 示例：编译期多态
```cpp
template<typename T>
void handle(T value) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "Pointer: " << *value << "\n";
    } else if constexpr (std::is_integral_v<T>) {
        std::cout << "Integer: " << value << "\n";
    } else {
        static_assert(always_false_v<T>, "Unsupported type");
    }
}
```

### 示例：SFINAE + 类型萃取
```cpp
template<typename T, typename = void>
struct has_size : std::false_type {};

template<typename T>
struct has_size<T, std::void_t<decltype(std::declval<T>().size())>> 
    : std::true_type {};

template<typename T>
constexpr bool has_size_v = has_size<T>::value;
```

## 现代C++演进

| 技术       | C++标准 | 替代方案        | 优势                 |
| ---------- | ------- | --------------- | -------------------- |
| SFINAE     | C++03   | constexpr if    | 更简洁直观           |
| 类型萃取   | C++11   | Concept (C++20) | 更强大的约束表达能力 |
| 模板元编程 | C++14   | constexpr 函数  | 编译期计算更自然     |

## 最佳实践指南

1. **优先选择更现代的技术**：
   - 能用 `constexpr if` 就不用 SFINAE
   - 能用 Concepts 就不用类型萃取

2. **保持代码可读性**：
   ```cpp
   // 好：清晰表达意图
   template<std::integral T>
   void process(T val);
   
   // 不好：晦涩难懂
   template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
   void process(T val);
   ```

3. **合理使用静态断言**：
   ```cpp
   template<typename T>
   void foo(T) {
       static_assert(std::is_default_constructible_v<T>,
                    "T must be default constructible");
   }
   ```

4. **组合使用这些技术**：
   ```cpp
   template<typename T>
   auto serialize(T obj) {
       if constexpr (has_serialize_method_v<T>) {
           return obj.serialize();
       } else if constexpr (std::is_arithmetic_v<T>) {
           return std::to_string(obj);
       } else {
           static_assert(dependent_false_v<T>, "Unserializable type");
       }
   }
   ```

这些技术构成了现代C++模板元编程的核心工具集，合理运用可以创建出既强大又易于维护的泛型代码。 