# `.` `->` 运算符的异同

在 C++ 中，`.`（点运算符）和 `->`（箭头运算符）都用于访问类的成员（成员变量和成员函数），但它们在**使用场景**和**底层机制**上有重要区别：

---

### 主要区别

| 特性         | `.` 运算符         | `->` 运算符                     |
| ------------ | ------------------ | ------------------------------- |
| **操作对象** | 类实例（对象）     | 指向类实例的**指针**            |
| **本质**     | 直接访问对象成员   | 先解引用指针再访问成员          |
| **等价形式** | `obj.member`       | `ptr->member` ≡ `(*ptr).member` |
| **重载**     | **不可重载**       | **可重载**                      |
| **空指针**   | 不涉及指针（安全） | 对空指针使用导致未定义行为      |

---

### 详细说明

#### 1. **操作对象不同**
```cpp
class MyClass {
public:
    void method() {}
    int data;
};

MyClass obj;     // 对象实例
MyClass* ptr = &obj;  // 指向对象的指针

// 点运算符：操作对象实例
obj.method();    // ✅ 正确
obj.data = 10;   // ✅ 正确

// 箭头运算符：操作对象指针
ptr->method();   // ✅ 正确
ptr->data = 20;  // ✅ 正确
```

#### 2. **空指针安全性**
```cpp
MyClass* nullPtr = nullptr;

nullPtr->method();  // ❌ 未定义行为（通常是崩溃）
(*nullPtr).method(); // ❌ 同样崩溃（等价形式）
```

#### 3. **运算符重载**
```cpp
class SmartPtr {
    MyClass* rawPtr;
public:
    // 可重载箭头运算符
    MyClass* operator->() { 
        return rawPtr; 
    }
};

SmartPtr smart;
smart->method();  // ✅ 调用重载的 operator->
```

> ⚠️ **注意**：`.` 运算符**不能重载**（C++ 语言规范限制）

---

### 关键关系：`->` 的本质
箭头运算符是**语法糖**，其行为严格等价于：
```cpp
ptr->member  ===  (*ptr).member
```
编译器会自动将 `->` 转换为先解引用指针再使用 `.` 访问成员的操作。

---

### 使用场景对比

#### 适合使用 `.` 的场景
```cpp
// 栈上对象
MyClass obj;
obj.method();

// 引用类型
MyClass& ref = obj;
ref.data = 5;

// 对象数组
MyClass arr[10];
arr[0].method();
```

#### 适合使用 `->` 的场景
```cpp
// 堆上分配的对象
MyClass* heapObj = new MyClass();
heapObj->method();

// 智能指针
std::unique_ptr<MyClass> smartPtr = std::make_unique<MyClass>();
smartPtr->data = 42;  // 即使是指针也使用 ->

// 遍历链表
struct Node {
    int value;
    Node* next;
};
Node* head = /*...*/;
while (head) {
    std::cout << head->value;
    head = head->next;  // 混合使用 -> 和 .
}
```

---

### 特殊案例：操作符重载链式调用
当重载 `->` 时，它会**递归应用**直到返回原始指针：
```cpp
struct Wrapper {
    MyClass* operator->() {
        std::cout << "Access via Wrapper\n";
        return inner;
    }
    MyClass* inner;
};

struct DeepWrapper {
    Wrapper operator->() {
        return Wrapper{inner}; 
    }
    MyClass* inner;
};

DeepWrapper dw;
dw->method(); // 输出: "Access via Wrapper"
              // 实际调用: dw.operator->().operator->()->method()
```

---

### 总结：核心区别
| 维度         | `.`                      | `->`                       |
| ------------ | ------------------------ | -------------------------- |
| **操作数**   | 对象实例（非指针）       | 指向对象的指针             |
| **安全性**   | 直接访问（无解引用风险） | 需确保指针非空             |
| **灵活性**   | 不可重载                 | 可重载（常用于智能指针）   |
| **底层操作** | 直接成员访问             | 先解引用 (*ptr) 再成员访问 |

**经验法则**：
- 当你有 **实际对象**（或引用）时，使用 `.`
- 当你有 **指向对象的指针** 时，使用 `->`
- 智能指针（如 `std::unique_ptr`）虽然行为像指针，但访问成员时**仍用 `->`**