# 命名空间

## namespace

在 C++ 中，可以用`namespace` 关键字创建命名空间，其主要作用是为了避免命名冲突，尤其是在大型项目或多团队协作开发时。

命名空间将代码中的标识符（如变量、函数、类等）封装在一个特定的作用域内，使其与其他同名标识符隔离。

### **示例**：

   ```cpp
namespace A {
   void print() { std::cout << "A's print\n"; }
}
namespace B {
   void print() { std::cout << "B's print\n"; }
}
int main() {
   A::print(); // 调用 A 的 print
   B::print(); // 调用 B 的 print
}
   ```

### 作用：

1. **避免命名冲突**

   不同库或模块中可能定义相同的名称（如函数、类、变量等），通过命名空间可以区分它们。  


2. **组织代码逻辑**
   
   将相关的功能（如数学运算、文件操作等）归类到同一个命名空间，提高代码可读性和可维护性。
   
   **示例**：
   
   ```cpp
   namespace MathUtils {
       double add(double a, double b) { return a + b; }
    double sqrt(double x) { /* ... */ }
   }
   ```
   
3. **支持库的模块化**
   标准库（如 `std`）和第三方库（如 `boost`）通过命名空间暴露接口，避免污染全局作用域。

## 常见用法
1. **定义命名空间**  
   
   ```cpp
   namespace MyLib {
       class Data {};
       void process() {}
   }
```
   
2. **访问命名空间成员**  
   - 使用作用域解析符 `::`：  
     ```cpp
     MyLib::process();
     ```
   - 使用 `using` 声明（局部引入）：  
     ```cpp
     using MyLib::Data;
     Data obj; // 直接使用
     ```
   - 使用 `using namespace`（全局引入，慎用）：
     ```cpp
     using namespace MyLib;
     process(); // 直接调用
     ```

3. **嵌套命名空间**（C++11 起支持更简洁的语法）
   
   ```cpp
   namespace A::B::C {  // C++17 支持
       void func() {}
   }
   // 等价于
   namespace A {
       namespace B {
           namespace C {
               void func() {}
           }
       }
   }
```
   
4. **匿名命名空间**
   用于限制标识符仅在当前文件内可见（类似 `static` 的作用）：  
   
   ```cpp
   namespace {
       void internalHelper() {} // 仅在当前.cpp文件中可用
   }
   ```



## **注意事项**
- **避免滥用 `using namespace`** 
  尤其在头文件中，全局引入命名空间可能导致命名冲突（例如 `using namespace std;`）。
- **命名空间别名**
  可为长命名空间定义短别名：  
  
  ```cpp
  namespace fs = std::filesystem;
  fs::path filePath;
  ```



## **总结**
`namespace` 是 C++ 中管理作用域的关键机制，能有效解决命名冲突问题，提升代码的组织性和模块化程度。合理使用命名空间是编写高质量 C++ 代码的重要实践。