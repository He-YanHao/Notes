# 函数对象 Function Objects / Functors

## 基本概念

**函数对象**是一个**行为类似函数**的对象，具体来说：
- 它是类或结构体的实例
- 重载了函数调用运算符 `operator()`
- 可以像普通函数一样被调用

```cpp
class Adder {
    int value;//包含数据value
public:
    Adder(int v) : value(v) {}
    
    // 重载函数调用运算符
    int operator()(int x) const {
        //operator运算符运行对象可以像函数一样被调用
        return value + x;
    }
};

int main() {
    Adder add5(5);      // 创建函数对象
    //这个add5包含的value为5
    int result = add5(3); // 调用函数对象：输出 8
}
```

## 与普通函数的比较

| 特性         | 普通函数                   | 函数对象                     |
| ------------ | -------------------------- | ---------------------------- |
| **状态保持** | 只能通过静态变量或全局变量 | 可通过成员变量保持状态       |
| **多态性**   | 不支持                     | 支持继承和多态               |
| **内联优化** | 依赖编译器                 | 通常更容易内联               |
| **模板参数** | 需要函数指针语法           | 可直接作为模板参数           |
| **封装性**   | 弱                         | 强（可封装数据和逻辑）       |
| **重载**     | 基于参数类型               | 可定义多个 `operator()` 重载 |

## 核心优势

### 状态保持
函数对象可以携带状态，在多次调用间保留信息：

```cpp
class Counter {
    int count = 0;
public:
    int operator()() { return ++count; }
};

Counter c;
c(); // 1
c(); // 2 - 保持状态
```

### 类型作为模板参数
函数对象可以作为模板参数传递，编译器更容易优化：

```cpp
template <typename Func>
void process(int x, Func f) {
    std::cout << f(x) << std::endl;
}

process(5, Adder(3)); // 输出 8
```

### 自定义行为
可以通过继承和多态创建灵活的函数对象体系：

```cpp
struct MathOperation {
    virtual int operator()(int, int) const = 0;
};

struct Add : MathOperation {
    int operator()(int a, int b) const override { return a + b; }
};

struct Multiply : MathOperation {
    int operator()(int a, int b) const override { return a * b; }
};

void calculate(int x, int y, const MathOperation& op) {
    std::cout << op(x, y) << std::endl;
}
```

## 标准库中的函数对象

C++ 在 `<functional>` 头文件中提供了预定义的函数对象：

| 函数对象            | 功能              | 示例                               |
| ------------------- | ----------------- | ---------------------------------- |
| `std::plus<>`       | 加法 (a + b)      | `std::plus<int>()(2,3)` → 5        |
| `std::minus<>`      | 减法 (a - b)      | `std::minus<int>()(5,2)` → 3       |
| `std::multiplies<>` | 乘法 (a * b)      | `std::multiplies<int>()(3,4)` → 12 |
| `std::divides<>`    | 除法 (a / b)      | `std::divides<int>()(10,2)` → 5    |
| `std::modulus<>`    | 取模 (a % b)      | `std::modulus<int>()(10,3)` → 1    |
| `std::negate<>`     | 取负 (-a)         | `std::negate<int>()(5)` → -5       |
| `std::equal_to<>`   | 相等比较 (a == b) | `std::equal_to<int>()(5,5)` → true |
| `std::greater<>`    | 大于比较 (a > b)  | `std::greater<int>()(5,3)` → true  |
| `std::less<>`       | 小于比较 (a < b)  | `std::less<int>()(3,5)` → true     |

### 在算法中的应用：
```cpp
std::vector<int> v{3, 1, 4, 1, 5};
std::sort(v.begin(), v.end(), std::greater<int>());
// v 变为 {5, 4, 3, 1, 1}
```

## 函数对象适配器

标准库提供了适配器来修改或组合函数对象的行为：

### 1. 绑定器 (std::bind)
固定函数的部分参数：
```cpp
using namespace std::placeholders;
auto add5 = std::bind(std::plus<int>(), _1, 5);
std::cout << add5(3); // 输出 8
```

### 2. 取反器 (std::not_fn)
反转谓词的结果：
```cpp
auto is_not_even = std::not_fn([](int x){ return x % 2 == 0; });
std::cout << is_not_even(3); // true
```

### 3. 成员函数适配器
```cpp
struct Person {
    std::string name;
    int age;
};

std::vector<Person> people{{"Alice", 25}, {"Bob", 30}};
std::vector<std::string> names;
std::transform(people.begin(), people.end(), std::back_inserter(names),
               std::mem_fn(&Person::name));
```

## 函数对象 vs Lambda 表达式

C++11 引入的 lambda 表达式本质上是**匿名函数对象**：

```cpp
// Lambda 表达式
auto add5 = [value=5](int x) { return value + x; };

// 等效的函数对象
class __Lambda_add5 {
    int value = 5;
public:
    auto operator()(int x) const { return value + x; }
};
```

### 选择指南：
- **使用 lambda**：简单、一次性使用的函数逻辑
- **使用函数对象**：
  - 需要复杂状态管理
  - 需要多态行为
  - 需要定义多个重载版本
  - 需要在多处复用

## 高级应用

### 1. 函数组合
```cpp
template <typename F, typename G>
class Compose {
    F f;
    G g;
public:
    Compose(F f, G g) : f(f), g(g) {}
    
    template <typename... Args>
    auto operator()(Args&&... args) const {
        return f(g(std::forward<Args>(args)...));
    }
};

auto square = [](int x) { return x * x; };
auto add2 = [](int x) { return x + 2; };
Compose<decltype(square), decltype(add2)> func(square, add2);
std::cout << func(3); // (3+2)^2 = 25
```

### 2. 带状态的谓词
```cpp
class NthCall {
    int count = 0;
    const int n;
public:
    NthCall(int n) : n(n) {}
    
    template <typename T>
    bool operator()(T&&) {
        return ++count == n;
    }
};

std::vector<int> v{1,2,3,4,5};
auto it = std::find_if(v.begin(), v.end(), NthCall(3));
// 找到第三个元素: 3
```

## 最佳实践

1. **优先使用标准库函数对象**：如 `std::plus`, `std::greater` 等
2. **为复杂函数对象定义 operator() 为 const**：除非需要修改内部状态
3. **对于简单逻辑，使用 lambda 更简洁**
4. **在性能敏感场景使用函数对象**：更易被编译器内联优化
5. **注意对象生命周期**：避免悬挂引用

```cpp
// 良好实践示例：带配置的函数对象
class ConfigurableTransform {
    double factor;
    double offset;
public:
    ConfigurableTransform(double f, double o) 
        : factor(f), offset(o) {}
    
    double operator()(double x) const {
        return x * factor + offset;
    }
};

auto transform = ConfigurableTransform(1.5, 2.0);
std::vector<double> data{1,2,3};
std::transform(data.begin(), data.end(), data.begin(), transform);
// data 变为 {3.5, 5.0, 6.5}
```

函数对象是 C++ 泛型编程和函数式编程的基石，合理使用它们可以创建灵活、高效且易于维护的代码。