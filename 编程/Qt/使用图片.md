# QLabel::setPixmap() 函数使用案例代码

`setPixmap(const QPixmap &pixmap)` 是 QLabel 类的一个重要函数，用于在标签上显示图片。以下是几个详细的使用案例：

## 基础用法：从文件加载图片

```cpp
#include <QLabel>
#include <QPixmap>
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    // 创建一个窗口
    QWidget window;
    window.setWindowTitle("QPixmap 示例");
    window.resize(400, 300);
    
    // 创建标签
    QLabel *label = new QLabel(&window);
    label->setGeometry(50, 50, 300, 200);
    
    // 从文件加载图片并设置到标签
    QPixmap pixmap(":/images/sample.jpg"); // 使用资源文件路径
    // 或者使用绝对路径: QPixmap pixmap("C:/images/sample.jpg");
    // 或者使用相对路径: QPixmap pixmap("../images/sample.jpg");
    
    if(!pixmap.isNull()) {
        label->setPixmap(pixmap);
    } else {
        label->setText("图片加载失败!");
    }
    
    window.show();
    return app.exec();
}
```

## 调整图片大小

```cpp
// 创建标签和图片
QLabel *imageLabel = new QLabel(this);
QPixmap originalPixmap(":/images/large_image.jpg");

// 方法1: 使用scaled()调整图片大小
QPixmap scaledPixmap = originalPixmap.scaled(200, 150, Qt::KeepAspectRatio);
imageLabel->setPixmap(scaledPixmap);

// 方法2: 使用scaledToWidth()或scaledToHeight()
QPixmap widthScaled = originalPixmap.scaledToWidth(200);
imageLabel->setPixmap(widthScaled);

// 方法3: 设置标签自动缩放内容
imageLabel->setPixmap(originalPixmap);
imageLabel->setScaledContents(true); // 图片会自动缩放以适应标签大小
```

## 动态更新图片

```cpp
// 在头文件中声明
private slots:
    void changeImage();

// 在实现文件中
void MainWindow::changeImage()
{
    static int imageIndex = 0;
    QStringList imagePaths = {
        ":/images/image1.jpg",
        ":/images/image2.png",
        ":/images/image3.bmp"
    };
    
    // 循环显示图片
    QPixmap newPixmap(imagePaths[imageIndex]);
    ui->imageLabel->setPixmap(newPixmap.scaled(ui->imageLabel->size(), 
                                              Qt::KeepAspectRatio));
    
    imageIndex = (imageIndex + 1) % imagePaths.size();
}

// 使用定时器定期更换图片
QTimer *timer = new QTimer(this);
connect(timer, &QTimer::timeout, this, &MainWindow::changeImage);
timer->start(3000); // 每3秒更换一次图片
```

## 创建圆形或特殊形状的图片

```cpp
// 创建圆形头像
QPixmap createCircularPixmap(const QPixmap &source)
{
    if(source.isNull())
        return QPixmap();
    
    QPixmap circularPixmap(source.size());
    circularPixmap.fill(Qt::transparent);
    
    QPainter painter(&circularPixmap);
    painter.setRenderHint(QPainter::Antialiasing, true);
    
    QPainterPath path;
    path.addEllipse(0, 0, source.width(), source.height());
    painter.setClipPath(path);
    painter.drawPixmap(0, 0, source);
    
    return circularPixmap;
}

// 使用函数
QPixmap original(":/images/avatar.jpg");
QPixmap circularAvatar = createCircularPixmap(original);
ui->avatarLabel->setPixmap(circularAvatar);
```

## 处理图片加载错误

```cpp
void MainWindow::loadImage(const QString &path)
{
    QPixmap pixmap(path);
    
    if(pixmap.isNull()) {
        // 图片加载失败，显示错误图标或文本
        ui->imageLabel->setText("无法加载图片: " + path);
        ui->imageLabel->setStyleSheet("color: red; background-color: #f0f0f0;");
        
        // 或者使用默认图片
        QPixmap defaultPixmap(":/images/default.png");
        ui->imageLabel->setPixmap(defaultPixmap);
    } else {
        // 图片加载成功
        ui->imageLabel->setPixmap(pixmap.scaled(ui->imageLabel->size(), 
                                               Qt::KeepAspectRatio, 
                                               Qt::SmoothTransformation));
    }
}
```

## 结合资源系统使用

在Qt项目中，通常使用资源系统(.qrc文件)来管理图片：

1. 创建Qt资源文件(.qrc)
```xml
<RCC>
    <qresource prefix="/images">
        <file>images/sample.jpg</file>
        <file>images/avatar.png</file>
        <file>images/background.png</file>
    </qresource>
</RCC>
```

2. 在代码中使用资源路径
```cpp
// 使用资源路径加载图片
QPixmap pixmap(":/images/sample.jpg");
label->setPixmap(pixmap);
```

## 高级用法：图片滤镜效果

```cpp
// 应用灰度滤镜
QPixmap grayscalePixmap(const QPixmap &source)
{
    if(source.isNull())
        return QPixmap();
    
    QImage image = source.toImage();
    for(int y = 0; y < image.height(); y++) {
        for(int x = 0; x < image.width(); x++) {
            QColor color = image.pixelColor(x, y);
            int gray = qGray(color.rgb());
            image.setPixelColor(x, y, QColor(gray, gray, gray));
        }
    }
    return QPixmap::fromImage(image);
}

// 使用滤镜
QPixmap original(":/images/colorful.jpg");
QPixmap grayscale = grayscalePixmap(original);
ui->imageLabel->setPixmap(grayscale);
```

## 注意事项

1. **内存管理**：QPixmap 可能会占用大量内存，特别是高分辨率图片。使用完后应及时释放。

2. **图片格式支持**：Qt 支持多种图片格式，但某些格式可能需要插件支持。

3. **性能考虑**：频繁加载和缩放大型图片可能会影响性能，应考虑缓存处理过的图片。

4. **路径问题**：使用相对路径时要注意当前工作目录，使用资源路径(:/...)更可靠。

5. **图片缩放质量**：使用 `Qt::SmoothTransformation` 可以获得更好的缩放质量，但性能开销更大。

这些案例展示了 `setPixmap()` 函数的各种用法，从基础图片显示到高级图像处理。根据实际需求选择合适的方法。