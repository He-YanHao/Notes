# 输入输出设备QIODevice

## 基本介绍

`QIODevice` 本身是一个**抽象基类**（Abstract Base Class）。这意味着：

1. **你不能直接实例化它**（即不能 `new QIODevice`）。
2. **它定义了所有输入/输出设备的通用接口和行为**。它的子类负责实现这些接口，以操作具体的设备（如文件、内存、套接字等）。

**它的主要直接功能包括：**

- **打开/关闭设备**：`open()`, `close()`
- **读写数据**：`read()`, `readLine()`, `write()`
- **设备状态**：`isOpen()`, `isReadable()`, `isWritable()`, `atEnd()`
- **当前位置**：`pos()`, `seek()`
- **异步通信**：`readyRead()` 信号，`bytesWritten()` 信号
- **缓冲区**：提供内置的读/写缓冲区管理

## 成员函数

### 设备打开与关闭

这些函数控制设备的基本状态。

| 函数原型                            | 功能描述                                                 | 示例                                 |
| ----------------------------------- | -------------------------------------------------------- | ------------------------------------ |
| bool open(QIODevice::OpenMode mode) | 以指定的模式打开设备。必须成功打开后，才能进行读写操作。 | `device->open(QIODevice::ReadWrite)` |
| **`void close()`**                  | 关闭设备。                                               | `device->close();`                   |
| **`bool isOpen() const`**           | 判断设备是否已打开。                                     |                                      |
| **`bool isReadable() const`**       | 判断设备是否可读。                                       |                                      |
| **`bool isWritable() const`**       | 判断设备是否可写。                                       |                                      |

**`OpenMode` 常用标志（可组合使用 `|` ）：**

*   `QIODevice::ReadOnly`：只读模式。
*   `QIODevice::WriteOnly`：只写模式。
*   `QIODevice::ReadWrite`：读写模式。
*   `QIODevice::Append`：追加模式。所有写入的数据都将被添加到文件末尾。
*   `QIODevice::Truncate`：截断模式。打开时清空设备原有内容。
*   `QIODevice::Text`：文本模式。在读取时，将 `"\r\n"` 转换为 `'\n'`；在写入时，将 `'\n'` 转换为 `"\r\n"`（Windows平台行为）。

### 数据读取

这些函数用于从设备中读取数据。

| 函数原型                                      | 功能描述                                                     | 特点与注意事项                                               |
| :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`qint64 read(char *data, qint64 maxSize)`** | 从设备读取最多 `maxSize` 字节数据到 `data` 指向的缓冲区。    | **低级函数**。需要自己管理缓冲区。返回实际读取的字节数，`-1` 表示错误。 |
| **`QByteArray read(qint64 maxSize)`**         | 从设备读取最多 `maxSize` 字节数据，并返回一个 `QByteArray`。 | **更安全方便**。Qt帮你管理内存。如果 `maxSize` 为 `-1`，则读取所有可用数据（等效于 `readAll()`）。 |
| **`QByteArray readAll()`**                    | 读取设备中当前所有的可用数据并返回。                         | **非常常用**。通常在与 `readyRead()` 信号连接的槽函数中调用，一次性读取所有缓冲数据。 |
| **`QByteArray readLine(qint64 maxSize = 0)`** | 读取一行数据，直到遇到换行符 `'\n'` 或达到 `maxSize`。       | 适用于基于行的文本协议。返回的 `QByteArray` **包含换行符**。如果无数据可读，返回空 `QByteArray`。 |
| **`bool canReadLine() const`**                | 判断是否有一行数据可读。                                     | 通常与 `readLine()` 配合使用，在循环中判断：<br>`while (device->canReadLine()) { ... }` |
| **`bool atEnd() const`**                      | 判断是否已到达设备末尾（没有更多数据可读）。                 | 对于文件，指文件尾；对于网络套接字，指连接已关闭。           |
| **`qint64 bytesAvailable() const`**           | 返回可读字节的估计数量。                                     | 可用于预分配缓冲区或判断数据量是否足够。                     |



### 数据写入

这些函数用于向设备写入数据。

| 函数原型                                             | 功能描述                                                | 特点与注意事项                                               |
| :--------------------------------------------------- | :------------------------------------------------------ | :----------------------------------------------------------- |
| **`qint64 write(const char *data, qint64 maxSize)`** | 将 `data` 指向的缓冲区中的 `maxSize` 字节数据写入设备。 | **低级函数**。返回实际写入的字节数，`-1` 表示错误。          |
| **`qint64 write(const QByteArray &data)`**           | 将 `QByteArray` `data` 中的所有数据写入设备。           | **最常用**。返回实际写入的字节数。                           |
| **`qint64 write(const char *data)`**                 | 写入一个以 `'\0'` 结尾的 C 字符串。                     | 等价于 `write(data, strlen(data))`。                         |
| **`bool flush()`**                                   | 强制将缓冲区中的任何待写入数据刷新到设备。              | 确保数据被物理写入，而不是停留在 Qt 的内部缓冲区。对于串口、网络等实时性要求高的场景很有用。 |

### 位置与寻址

主要用于随机访问设备（如文件），对于顺序访问设备（如管道、网络套接字）可能无效。

| 函数原型                    | 功能描述                                                     |
| :-------------------------- | :----------------------------------------------------------- |
| **`qint64 pos() const`**    | 返回设备的当前读写位置。                                     |
| **`bool seek(qint64 pos)`** | 将设备的当前读写位置设置为 `pos`。成功返回 `true`。          |
| **`qint64 size() const`**   | 返回设备的大小（字节数）。对于某些设备（如动态网络连接），可能无法获取准确大小。 |



# 还没看

## 成员函数



### 异步通信信号



`QIODevice` 是 `QObject` 的子类，因此支持信号槽机制，这是其最强大的特性之一。

| 信号原型                              | 触发时机                                                     | 典型用法                                                     |
| :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`void readyRead()`**                | **当有新的数据可读时**发射。                                 | **最重要的信号**。连接到槽函数以实现异步、事件驱动的数据读取，无需轮询。<br>`connect(serialPort, &QSerialPort::readyRead, this, &MyClass::handleNewData);` |
| **`void bytesWritten(qint64 bytes)`** | 当数据的一部分被写入设备后发射。`bytes` 参数表示本次写入的字节数。 | 可用于实现大文件分块写入时的进度更新，或实现背压控制（等待一批数据写完再写下一批）。 |





### 错误处理

| 函数原型                                   | 功能描述                                                     |
| :----------------------------------------- | :----------------------------------------------------------- |
| **`QIODevice::OpenMode openMode() const`** | 返回设备当前的打开模式。                                     |
| **`void ungetChar(char c)`**               | 将一个字符 `c` 放回输入缓冲区，下次读取时会先读到它。        |
| **`virtual QString errorString() const`**  | 返回最后发生的错误的可读描述。在操作失败后调用此函数非常有用。`qDebug() << "Error:" << device->errorString();` |
