# 信号&槽&连接

某些窗口被操作后会产生信号(如按钮被点击)，

## 信号

由对象在特定事件发生时**发出**的公告（如按钮点击、数据更新）

一个信号可以连接到**多个槽**。

## 槽

用于**响应信号**的普通成员函数（可属于任何 QObject 派生类）

## 连接

建立信号与槽的**绑定关系**（1个信号可连接多个槽，1个槽可响应多个信号）

当信号被发出时，所有连接到它的槽函数将按照连接的顺序被**自动调用**。

连接是 Qt 实现**松耦合**的关键：发出信号的对象不需要知道哪个对象（如果有的话）会接收它，接收槽的对象也不需要知道是哪个信号触发了它。它们只需要通过 `connect` 建立关系。

### 函数重载类型

`Connection`函数有多种重载类型

#### 最常见的重载

```cpp
// 函数原型 (最常见的重载)
QMetaObject::Connection QObject::connect(
    const QObject *sender, // 发送对象
    PointerToMemberFunction signal, // 发送对象的信号成员函数指针
    const QObject *receiver, // 接收对象
    PointerToMemberFunction method, // 接收对象的槽函数成员函数指针
    Qt::ConnectionType type = Qt::AutoConnection // 连接类型
);
// 函数原型 (最常见的重载)
返回类型 连接函数(发送对象 发送对象的信号成员函数指针 接收对象 接收对象的槽函数成员函数指针 连接类型);
```

**成员解析：**

- **发送对象（sender）**
  - 必须是 `QObject` 或其子类的实例

  - 例如：`QPushButton`、`QTimer` 等

- **信号（signal）**
   - 发送者类中声明的信号
   - 格式：
     - Qt4 风格：`SIGNAL(signalName(参数类型))`
     - Qt5 风格：`&ClassName::signalName`

- **接收对象（receiver）**
- 必须是 `QObject` 或其子类的实例
   - 如果使用 Lambda，可为 `nullptr`

- **槽函数（method）**
  - 接收者类中的槽函数或普通成员函数
  - 格式：
    - Qt4 风格：`SLOT(slotName(参数类型))`
    - Qt5 风格：`&ClassName::slotName`
    - Lambda 表达式：`[capture]{ ... }`

- **连接类型（AutoConnection）**
  - **`Qt::AutoConnection`**：
    - 是一个智能的、自动决定的连接类型。它的行为规则是：当信号被发射（emit）时，Qt 会自动检查发送信号的对象（sender）和接收信号的对象（receiver）是否存在于同一个线程中。
      - **如果它们在同一个线程**，则采用 **`Qt::DirectConnection`** 的行为。
      - **如果它们在不同线程**，则采用 **`Qt::QueuedConnection`** 的行为。
  - **`Qt::DirectConnection`**：
    - 你需要槽函数**立即**执行。
    - 你明确知道发送者和接收者总是在同一线程，并且希望避免事件队列的微小开销。
    - **注意**：如果错误地在跨线程场景使用它，会导致槽函数在错误的线程中执行，引发数据竞争或崩溃。

  - **`Qt::QueuedConnection`**：
    *   你**明确要求**槽函数必须通过事件队列异步执行，即使发送者和接收者在同一线程。
    *   你正在进行一些复杂的元对象编程，需要确保调用被排队。

  - **`Qt::BlockingQueuedConnection`**：
    *   你需要发送线程**等待**接收线程的槽函数执行完毕后再继续。这是一种同步的跨线程调用。
    *   **警告**：必须确保发送者和接收者不在同一线程，否则会造成死锁。

  - **`Qt::UniqueConnection`**：
    *   你希望确保相同的信号和槽对之间只有一个连接，避免重复连接导致槽函数被多次调用。这个标志可以与上述任何类型按位或（`|`）使用。

#### 连接到自由函数/静态函数

```cpp
QMetaObject::Connection QObject::connect(
    const QObject *sender, // 发送对象
    PointerToMemberFunction signal, // 发送对象的信号成员函数指针
    Functor functor //任何可调用的对象
);
//返回类型 连接函数(发送对象 发送对象的信号成员函数指针 任何可调用的对象);
```

- **缺点/注意事项**：因为没有接收者对象，所以 **Qt 无法自动管理连接的生命周期**。

- 当 `sender` 被销毁时，连接会自动断开。
- 如果 `functor` 所依赖的上下文（尤其是被 Lambda 捕获的变量）被销毁了，而 `sender` 还存在，就会发生灾难性的错误（例如程序崩溃）。





### 连接方式

Qt 的连接方式主要分为两大流派：**基于字符串的旧语法（Qt 4）** 和 **基于函数指针的新语法（Qt 5+）**。新语法是现代 Qt 开发的首选。

#### 基于函数指针的新语法（推荐，Qt 5+）

这是最推荐的方式，提供了**编译期检查**（类型安全、参数个数匹配等），大大减少了运行时因拼写错误或签名不匹配而导致的连接失败。

**基本形式：连接两个普通的信号和槽**

```cpp
// 函数原型 (最常见的重载)
QMetaObject::Connection QObject::connect(
    const QObject *sender, // 发送对象
    PointerToMemberFunction signal, // 发送对象的信号成员函数指针
    const QObject *receiver, // 接收对象
    PointerToMemberFunction method, // 接收对象的槽函数成员函数指针
    Qt::ConnectionType type = Qt::AutoConnection // 连接类型
);

// 示例：点击按钮，关闭窗口
QPushButton *button = new QPushButton("Quit");
QObject::connect(button, &QPushButton::clicked, this, &MainWindow::close);
```

*   **优点**：编译器会检查 `sender` 和 `receiver` 的类型是否拥有指定的信号和槽，参数列表是否兼容。如果错误，编译会报错。

**连接到 Lambda 表达式或函子（Functor）**

这是新语法一个非常强大的特性，它允许你**无需定义一个单独的槽函数**，直接将信号连接到一段内联的代码。

```cpp
// 函数原型 (连接到函子的重载)
QMetaObject::Connection QObject::connect(
    const QObject *sender,
    PointerToMemberFunction signal,
    Functor functor
);

// 示例：点击按钮，执行一段Lambda代码
QPushButton *button = new QPushButton("Click me");
QObject::connect(button, &QPushButton::clicked, [=]() {
    qDebug() << "Button clicked!";
    // 可以直接捕获并使用作用域内的变量
});
```

*   **优点**：极其方便，代码更紧凑，尤其适合处理简单的响应逻辑。
*   **注意**：使用 Lambda 表达式时，需要关注**对象的生命周期**。如果 Lambda 捕获了可能会被销毁的对象（例如 `this`），而连接依然存在，则可能导致悬空引用。Qt 的连接机制会自动管理 `sender` 和 `receiver` 对象的生命周期，但不会管理 Lambda 捕获的变量。

**处理重载的信号和槽**

当一个信号或槽有重载版本时，需要使用 `static_cast` 来明确指定是哪一个。

```cpp
// 假设有一个重载的信号：void valueChanged(int); void valueChanged(const QString &);
QLCDNumber *lcd = new QLCDNumber;
QSlider *slider = new QSlider;

// 错误：编译器不知道选择哪个 valueChanged
// connect(slider, &QSlider::valueChanged, lcd, &QLCDNumber::display);

// 正确：使用 static_cast 明确指向 void (QSlider::*)(int) 这个重载版本
connect(slider, static_cast<void (QSlider::*)(int)>(&QSlider::valueChanged),
        lcd, static_cast<void (QLCDNumber::*)(int)>(&QLCDNumber::display));
```

*   **替代方案**：从 Qt 5.7 开始，提供了 `qOverload` 辅助函数，让语法更清晰：
    ```cpp
    connect(slider, qOverload<int>(&QSlider::valueChanged),
            lcd, qOverload<int>(&QLCDNumber::display));
    ```
    在 C++14 中，也可以使用 `qOverload<>`：
    ```cpp
    connect(slider, qOverload<int>(&QSlider::valueChanged), ...);
    ```

---

#### 基于字符串的旧语法（Qt 4，现已不推荐）

这是 Qt 4 及之前版本的主要方式，它使用 `SIGNAL()` 和 `SLOT()` 这两个宏，将函数名和参数类型转换为字符串。

```cpp
// 函数原型
QMetaObject::Connection QObject::connect(
    const QObject *sender,
    const char *signal, // 使用 SIGNAL() 宏生成
    const QObject *receiver,
    const char *member, // 使用 SLOT() 宏生成
    Qt::ConnectionType type = Qt::AutoConnection
);

// 示例
connect(button, SIGNAL(clicked()), this, SLOT(close()));
```

*   **缺点**：
    1.  **无编译期检查**：因为参数是字符串，编译器无法验证信号或槽是否存在，参数是否匹配。任何错误（如函数名拼错、参数数量不对）都只能在**运行时**通过查看 Qt 的输出日志来发现，调试困难。
    2.  **语法繁琐**：需要写 `SIGNAL` 和 `SLOT` 宏。
*   **现状**：**不推荐在新代码中使用**，除非你维护的是非常古老的 Qt 4 项目。































