# 定时器类Timer

## 基本功能

`QTimer` 类提供定时器功能，用于在指定时间间隔后触发信号。

定时器类需要头文件`#include <QTimer>`

## 构造函数&析构函数

### 构造函数

```cpp
QTimer(QObject *parent = nullptr)
```

创建一个新的 `QTimer` 对象，可指定父对象进行内存管理。

```cpp
QTimer *timer = new QTimer(this); // 创建定时器，父对象为当前窗口
```

### 析构函数

```cpp
~QTimer()
```

停止定时器并销毁对象。通常无需手动调用，由 Qt 对象树自动管理。

## 类成员函数

### 创建定时器

```cpp
QTimer *timer = new QTimer(this);
```

### 设置定时器

```cpp
void setInterval(int msec);
```

设置定时器的超时间隔（毫秒）。**此设置不会改变正在运行的定时器**，需调用 `start()` 生效。

```cpp
timer->setInterval(500); // 设置间隔为500毫秒
```

### 启动定时器

启动或重启定时器，设置超时间隔为 `msec` 毫秒。如果定时器已在运行，会先停止再以新间隔启动。  

```cpp
timer->start(1000);  //毫秒为单位 每秒触发一次
timer->start();  //使用之前设置的间隔启动定时器
```

### 停止定时器

停止正在运行的定时器。停止后不再发射 `timeout()` 信号。

```cpp
timer->stop();
```





### 单次定时器


```cpp
QTimer::singleShot(5000, []() {
    qDebug() << "This will run once after 5 seconds";
});
```



### 设置定时器是否为单次模式

```cpp
void setSingleShot(bool singleShot)
timer->setSingleShot(true); // 设置为单次触发
```

`true` 表示只触发一次超时信号后自动停止。



### 连接定时器超时信号

```cpp
connect(timer, &QTimer::timeout, []() {
    qDebug() << "Timer triggered at" << QTime::currentTime().toString();
});
```





## 高级定时器用法

### 高精度定时器

```cpp
QTimer *highPrecisionTimer = new QTimer(this);
highPrecisionTimer->setTimerType(Qt::PreciseTimer);  // 更高精度
highPrecisionTimer->start(100);
```

### 设置定时器属性

```cpp
timer->setInterval(500);      // 设置间隔为500毫秒
timer->setSingleShot(true);   // 设置为单次定时器
```





### 



### 补充说明：Qt::TimerType

在上面的 `singleShot` 函数中提到了 `Qt::TimerType` 参数，它控制定时器的精度：

| 类型                      | 描述                                                    |
| :------------------------ | :------------------------------------------------------ |
| **`Qt::PreciseTimer`**    | 高精度定时器（约1ms精度），但可能更耗电。               |
| **`Qt::CoarseTimer`**     | 粗精度定时器（约5ms精度），默认类型，平衡了精度和效率。 |
| **`Qt::VeryCoarseTimer`** | 非常粗的精度（约1000ms精度），适用于分钟级更新等场景。  |

### 综合使用案例

```cpp
// 在类的头文件中声明
private:
    QTimer *m_timer;

// 在类的实现文件中
MyClass::MyClass(QWidget *parent) : QWidget(parent) {
    // 创建定时器
    m_timer = new QTimer(this);
    
    // 设置间隔和模式
    m_timer->setInterval(1000); // 1秒
    m_timer->setSingleShot(false); // 重复触发（默认）
    
    // 连接信号槽
    connect(m_timer, &QTimer::timeout, this, &MyClass::onTimeout);
    
    // 启动定时器
    m_timer->start();
}

void MyClass::onTimeout() {
    qDebug() << "Timeout at" << QTime::currentTime().toString();
    
    // 5秒后停止定时器（使用单次定时器）
    static int count = 0;
    if (++count >= 5) {
        m_timer->stop();
        qDebug() << "Timer stopped after 5 times";
    }
}

// 使用静态单次定时器
void MyClass::startDelayedTask() {
    QTimer::singleShot(3000, this, [this]() {
        qDebug() << "This runs after 3 seconds, in the main thread";
        this->doSomething();
    });
}
```

这个表格和示例涵盖了 `QTimer` 最常用和重要的成员函数，应该能够满足大部分的开发需求。





# 还没看的

### QTimer 类成员函数详解

| **`int interval() const`**                                   | 返回当前设置的超时间隔（毫秒）。                             | `int ms = timer->interval(); // 获取当前间隔设置`            |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`bool isActive() const`**                                  | 返回定时器是否正在运行。                                     | `if (timer->isActive()) { qDebug() << "Timer is running"; }` |
| **`bool isSingleShot() const`**                              | 返回定时器是否为单次模式。                                   | `if (timer->isSingleShot()) { qDebug() << "One-shot timer"; }` |
| **`int remainingTime() const`**                              | 返回距离下一次超时的剩余时间（毫秒）。如果定时器未激活，返回 -1。 | `int remaining = timer->remainingTime(); // 获取剩余时间`    |
| **`void timeout()`**                                         | **信号**。当定时器超时时发射此信号。需要连接到槽函数进行处理。 | `connect(timer, &QTimer::timeout, this, &MyClass::updateUI);` |
| **`static void singleShot(int msec, const QObject *context, Functor functor)`** | **静态函数**。安排一个单次定时器，在 `msec` 毫秒后，在 `context` 线程上下文中调用 `functor`。 | `QTimer::singleShot(3000, this, [](){ qDebug() << "3 seconds later"; });` |
| **`static void singleShot(int msec, Qt::TimerType timerType, const QObject *context, Functor functor)`** | **静态函数**。同上，但可指定定时器精度类型。                 | `QTimer::singleShot(100, Qt::PreciseTimer, this, &MyClass::doTask);` |
| **`static void singleShot(int msec, const QObject *receiver, const char *member)`** | **静态函数**（旧式语法）。单次触发，超时后调用 `receiver` 对象的 `member` 方法。 | `QTimer::singleShot(0, this, SLOT(processEvents()));`        |
| **`void timerId() const`**                                   | 返回定时器的内部 ID。主要用于高级用途，如与 `QTimerEvent` 配合使用。 | `int id = timer->timerId(); // 获取定时器ID`                 |