# I2C

## 理论

I2C 使用 SDA 信号线来传输数据，使用SCL信号线进行数据同步。二者均设置为开漏输出或者复用开漏输出模式，并添加上拉电阻，阻值为4.7KΩ。

SDA 数据线在 SCL 的每个时钟周期传输一位数据。

初始 SDA 信号线和 SCL 信号线均默认为高电平。

传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。

当 SCL 为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。

I2C可以通过普通GPIO口用软件模拟出来，称为软件I2C，或者使用单片机本身的I2C功能，称为硬件I2C。



## I2C时序

**I2C的开始**

SCL和SDA平时均为高电平，当主机的SDA下降时，从机复位，并且主机的SCL下降，这是**I2C的开始**。

> 先释放主机的SCL和SDA，即将二者都拉高，作为平时状态，然后在SCL高电平期间，拉低SDA，产生起始信号，起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接。

**发送一个字节的数据**：主机的SCL低电平期间，将主机的数据位依此放在SDA线上， 从机读取，之后主机SCL恢复高电平，结束第一位，重复八次可以发送一个字节。

**接受一个字节的数据**：主机的SCL低电平期间，从机依次将数据位依此放在SDA线上，然后释放SCL，读取SDA的电平，结束第一位，重复八次可以发送一个字节。

**I2C结束**时SCL回到高电平，SDA跟着回到高电平。

> 拉低SDA，确保SDA为低电平，释放SCL，使SCL呈现高电平，在SCL高电平期间，释放SDA，产生终止信号。



## 写过程

**起始信号开始**

先释放主机的SCL和SDA，即将二者都拉高，作为平时状态，然后在SCL高电平期间，拉低SDA，产生起始信号，起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接。

注意：从机无法主动发送数据。

**发送7位从机地址**

I2C设备从机地址一般为七位，可以通过特定引脚的高低电平来改变地址。

**发送读或写**

传输方向选择位，1为读，0为写，与从机地址共同构成一个字节。

这里一般是将从机地址末尾加0，作为一个字节发送，读的时候与0x01取或。

**从机应答或不应答**

I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。

作为数据接收端时，当设备(无论主从机)接收到I2C传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送低电平“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送高电平“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。

传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制 SDA。

**发送数据**

一般包含两部分，指令和数据。




并非每传输8位数据之后，都会有ACK信号，有以下3中例外：

1. 当从机不能响应从机地址时(例如它正忙于其他事而无法响应IIC总线的操作，或者这个地址没有对应的从机)，在第9个SCL周期内SDA线没有拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。
2. 如果从机接收器在传输过程中不能接收更多的数据时，它不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。
3. 主机接收器在接收到最后一个字节后，也不会发出ACK信号。于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。

## 读过程

I2C的读数据流程分为两个阶段。第一阶段是写操作：主设备先发送起始信号，然后发送从设备地址和写标志位，接着发送要读取的寄存器地址。第二阶段是读操作：主设备发送重复起始信号，然后发送从设备地址和读标志位，开始接收数据。读取完成后，主设备发送非应答信号和停止信号。

```
[起始信号] → [从设备地址 + 写(0)] → [应答] → [寄存器地址] → [应答] → [重复起始信号] → [从设备地址 + 读(1)] → [应答] → [读取数据] → [非应答] → [停止信号]
```

#### **阶段一：设置要读取的寄存器地址（写操作）**

1.  **主设备发送起始条件**
    -   SDA线从高电平切换到低电平，同时SCL保持高电平
2.  **主设备发送从设备地址 + 写位**
    -   发送7位从设备地址
    -   第8位是读写控制位：**0表示写**
    -   格式：`[A6 A5 A4 A3 A2 A1 A0 0]`
3.  **从设备发送应答信号**
    -   从设备在第9个时钟周期将SDA拉低，表示收到地址
4.  **主设备发送寄存器地址**
    -   发送要读取的寄存器地址（通常是8位或16位，取决于具体器件）
5.  **从设备发送应答信号**
    -   从设备确认收到寄存器地址

#### **阶段二：实际读取数据（读操作）**

1.  **主设备发送重复起始条件**
    -   这是关键！不是停止后再开始，而是直接发送一个新的起始条件
2.  **主设备发送从设备地址 + 读位**
    -   同样的7位从设备地址
    -   第8位是读写控制位：**1表示读**
    -   格式：`[A6 A5 A4 A3 A2 A1 A0 1]`
3.  **从设备发送应答信号**
    -   从设备确认准备发送数据
4.  **主设备读取数据字节**
    -   从设备控制SDA线，在SCL的上升沿输出数据
    -   主设备在SCL的下降沿采样数据
5.  **主设备发送应答/非应答**
    -   **读取单个字节**：主设备在第9个时钟发送**非应答(1)**，告诉从设备"不要再发数据了"
    -   **读取多个字节**：主设备发送**应答(0)**，从设备继续发送下一个数据字节
6.  **主设备发送停止条件**
    -   SDA从低电平切换到高电平，同时SCL保持高电平





## I2C代码

### 软件模拟代码部分

**I2C的开始**

SCL和SDA初始均为高电平，当主机的SDA下降时，从机开始复位，并且主机的SCL也下降，这是I2C的开始。

即：

```c
void I2C_Start(void)//I2C的开始
{
	SDA(1);//释放SDA，确保SDA为高电平
	SCL(1);//释放SCL，确保SCL为高电平
	SDA(0);//在SCL高电平期间，拉低SDA，产生起始信号
	SCL(0);//起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接
}
```

**I2C的结束**

I2C结束时SCL回到高电平，SDA跟着回到高电平。

即：

```c
void I2C_Stop(void)//I2C的结束
{
	SDA(0);//拉低SDA，确保SDA为低电平
	SCL(1);//释放SCL，使SCL呈现高电平
	SDA(1);//在SCL高电平期间，释放SDA，产生终止信号
}
```

**I2C发送一个字节**

主机的SCL低电平期间，将主机的数据位依此放在SDA线上， 从机读取，之后主机SCL恢复高电平，结束第一位，重复八次可以发送一个字节。

首先发送七位从机地址，第八位为0则为写，为1则为读。

```c
void I2C_SendByte(uint8_t Byte)//I2C发送一个字节
{
	uint8_t i;
	for (i = 0; i < 8; i++)//循环8次，主机依次发送数据的每一位
	{
 	SDA(!!(Byte & (0x80 >> i)));//0x80==0b 1000 0000;向右移动i位就是将第i+1位的数字保留，其他的清零，若该位为0则Byte&(0x80>>i)为0，若该位为1则Byte&(0x80>>i)不为0，则(!!(Byte&(0x80>>i)))为1[不为零的数为真，!求非则为假，为0，再次!求非则为真，为1。]
 	SCL(1);//释放SCL，从机在SCL高电平期间读取SDA
 	SCL(0);//拉低SCL，主机开始发送下一位数据
	}
	SCL(1);//额外的一个时钟，不处理应答信号
	SCL(0);
}
```

无注释版本

```c
void I2C_SendByte(uint8_t Byte)//I2C发送一个字节
{
	uint8_t i;
	for (i = 0; i < 8; i++)
	{
 	SDA(!!(Byte & (0x80 >> i)));
 	SCL(1);
 	SCL(0);
	}
	SCL(1);
	SCL(0);
}
```

**I2C接受一个字节**

接受一个字节的数据：主机的SCL低电平期间，从机依次将数据位依此放在SDA线上，然后释放SCL，读取SDA的电平，结束第一位，重复八次可以发送一个字节。

```c
uint8_t MyI2C_ReceiveByte(void)//I2C接收一个字节
{
	uint8_t i, Byte = 0x00;					//定义接收的数据，并赋初值0x00，此处必须赋初值0x00，后面会用到
	I2C_W_SDA(1);							//接收前，主机先确保释放SDA，避免干扰从机的数据发送
	for (i = 0; i < 8; i ++)				//循环8次，主机依次接收数据的每一位
	{
		I2C_W_SCL(1);						//释放SCL，主机在SCL高电平期间读取SDA
		if (I2C_R_SDA() == 1)//读取SDA数据，并存储到Byte变量 当SDA为1时，置变量指定位为1，当SDA为0时，不做处理，指定位为默认的初值0
		{
		Byte |= (0x80 >> i);
		}
		I2C_W_SCL(0);						//拉低SCL，从机在SCL低电平期间写入SDA
	}
	return Byte;							//返回接收到的一个字节数据
}
```

**I2C应答**

默认应答为0。

