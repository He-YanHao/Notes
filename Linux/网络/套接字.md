# Linux

## 基础

好的，我们来详细介绍一下 Linux **套接字**。



## 什么是套接字？

简单来说，**套接字是网络通信的端点**。它提供了一个接口，允许运行在不同计算机（或同一台计算机上）的进程进行通信。

一个更形象的比喻是：
*   **IP 地址**像是房子的**地址**（标识了哪台主机）。
*   **端口号**像是房子的**门牌号**（标识了主机上的哪个应用程序）。
*   **套接字**就像是这个地址和门牌号所确定的**一扇门**。数据通过这扇门流入和流出应用程序。



### 套接字的工作原理（核心流程）

套接字通信通常采用客户端/服务器模型，其工作流程如下：

#### **服务器端（Server）**

1.  **创建套接字：** 调用 `socket()` 函数，创建一个通信端点（套接字描述符）。就像买一个电话机。
2.  **绑定地址和端口：** 调用 `bind()` 函数，将套接字与一个特定的 IP 地址和端口号绑定。就像给电话机申请一个固定的电话号码。
3.  **监听连接：** 调用 `listen()` 函数，告诉操作系统这个套接字开始等待客户端的连接请求。就像把电话机设为响铃模式，等待别人打进来。
4.  **接受连接：** 调用 `accept()` 函数，**阻塞**并等待客户端的连接。当有客户端连接时，`accept()` 会返回一个**新的套接字描述符**，专门用于与这个客户端通信。就像接起打来的电话，并为此专门拉了一条分机线。
5.  **收发数据：** 使用 `read()`/`recv()` 和 `write()`/`send()` 函数通过这个新的套接字与客户端进行数据交换。就像通过电话线对话。
6.  **关闭连接：** 通信完毕后，调用 `close()` 关闭套接字。就像挂断电话。

#### **客户端（Client）**

1.  **创建套接字：** 同样调用 `socket()` 函数创建一个套接字。就像买一个电话机。
2.  **连接服务器：** 调用 `connect()` 函数，向服务器指定的 IP 地址和端口发起连接请求。就像拨打服务器的电话号码。
3.  **收发数据：** 连接成功后，使用 `read()`/`recv()` 和 `write()`/`send()` 函数与服务器通信。就像通话。
4.  **关闭连接：** 调用 `close()` 关闭套接字。就像挂断电话。

### 3. 套接字的类型

Linux 支持多种类型的套接字，最主要的两种是：

#### **a) 流式套接字**

*   **类型：** `SOCK_STREAM`
*   **协议：** 通常使用 **TCP** 协议。
*   **特点：**
    *   **可靠的：** 保证数据能按顺序、无差错地送达。
    *   **面向连接的：** 通信前必须建立连接（三次握手）。
    *   **基于字节流的：** 数据没有边界，像水流一样。应用程序需要自己处理消息边界（如添加分隔符或使用固定长度）。
*   **应用场景：** Web 浏览（HTTP/HTTPS）、电子邮件（SMTP）、文件传输（FTP）等需要高可靠性的场景。

#### **b) 数据报套接字**

*   **类型：** `SOCK_DGRAM`
*   **协议：** 通常使用 **UDP** 协议。
*   **特点：**
    *   **不可靠的：** 不保证数据一定能送达，也不保证顺序。
    *   **无连接的：** 每个数据包（数据报）都是独立的，不需要预先建立连接。
    *   **有消息边界：** 发送多少次 `sendto()`，接收方就需要多少次 `recvfrom()`，一次读取一个完整的数据报。
*   **应用场景：** 视频流、语音通话、DNS 查询、在线游戏等对实时性要求高、允许少量数据丢失的场景。

#### **c) 其他类型**

*   **原始套接字：** 允许程序直接访问底层网络协议（如 IP、ICMP），常用于网络嗅探、数据包分析或实现自定义协议。

### 4. 地址族

套接字不仅可以用于网络通信，还可以用于同一台主机上的进程间通信。

*   **AF_INET：** IPv4 网络协议，这是最常用的。
*   **AF_INET6：** IPv6 网络协议。
*   **AF_UNIX / AF_LOCAL：** 用于**同一台主机**上的进程间通信，通过文件系统路径名来标识。它的效率远高于网络套接字，因为它不需要经过网络协议栈。

### 5. 一个简单的例子（C语言伪代码）

**服务器端：**

```c
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // 1. 创建套接字
    server_fd = socket(AF_INET, SOCK_STREAM, 0);

    // 2. 绑定
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY; // 绑定到所有本地IP
    address.sin_port = htons(8080);       // 绑定到8080端口
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));

    // 3. 监听
    listen(server_fd, 3);

    // 4. 接受连接
    new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);

    // 5. 通信（例如，发送一条消息）
    send(new_socket, "Hello from server", strlen("Hello from server"), 0);

    // 6. 关闭
    close(new_socket);
    close(server_fd);
    return 0;
}
```

**客户端：**

```c
#include <sys/socket.h>
#include <arpa/inet.h>

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;

    // 1. 创建套接字
    sock = socket(AF_INET, SOCK_STREAM, 0);

    // 配置服务器地址
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(8080);
    inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr); // 连接到本地回环地址

    // 2. 连接服务器
    connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

    // 3. 读取数据
    char buffer[1024] = {0};
    read(sock, buffer, 1024);
    printf("%s\n", buffer);

    // 4. 关闭
    close(sock);
    return 0;
}
```

### 总结

| 特性         | 流式套接字         | 数据报套接字           |
| :----------- | :----------------- | :--------------------- |
| **类型**     | `SOCK_STREAM`      | `SOCK_DGRAM`           |
| **协议**     | TCP                | UDP                    |
| **连接**     | 面向连接           | 无连接                 |
| **可靠性**   | 可靠，有序         | 不可靠，可能丢失或乱序 |
| **数据边界** | 字节流，无边界     | 数据报，有边界         |
| **速度**     | 较慢（有连接开销） | 较快                   |

Linux 套接字是构建所有网络服务的基石，从简单的网页服务到复杂的分布式系统，都离不开它。理解其工作原理和不同类型是进行网络编程的第一步。
